Aula02
01-O que é um modelo?
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui para continuar seus estudos.

Anteriormente, não ficou claro onde se encontrava a negociação no código. Nós vimos que havia ficado confuso onde estava o modelo e a apresentação. Definimos que seria interessante separar o modelo e a visualização, aplicando o MVC (Model-View-Controller). Mas o que é um modelo? Trata-se de uma abstração do mundo real. Por exemplo, um analista de mercado que quer entender como o mercado funciona, criará um modelo em que ele possa dar entradas e executar determinado procedimentos para tentar prever como é o seu funcionamento. No nosso caso, faremos a mesma coisa.

Nós queremos criar um modelo de negociação que programaticamente deve ser capaz de fazer tudo o que seria feito no mundo real. Para materializarmos o modelo de negociação, usaremos um recurso do paradigma da programação orientada de objetos: a criação de classes. Antes do ES6, já era possível aplicar o paradigma com o JavaScript, porém, a sintaxe era mais complexa. Por isso, o ES6 trouxe novos recursos para que seja mais fácil a aplicação do paradigma.

Então, primeiramente criaremos uma classe, ou seja, uma especificação da negociação com a abstração da mesma, dentro do código.
*******************
02-A classe Negociação
A seguir, criaremos a classe Negociacao. Nós não usaremos mais a classe index.js. Nós também seguiremos a seguinte convenção: dentro da pasta js, encontramos a app, que contêm todo o código da aplicação. Dentro dela, encontraremos a subpasta models, em que estão armazenados todos os modelos. Também convencionaremos que queremos criar a classe Negociacao.js, o script que iremos criar, começará em caixa alta (com letra maiúscula). Isto é um pouco incomum, mas isto deixará claro que o JS é uma classe. No arquivo index.html, importaremos a Negociacao.js.

Para criarmos a classe com o ES6, usaremos a sintaxe class Negociacao. Ela terá o mesmo nome do arquivo, propositalmente, para que haja uma paridade e maior organização - mas não era obrigatório. E como definiremos os atributos de uma classe no ES6? Utilizando a função constructor().

class Negociacao {

    constructor() {

        this.data = new Date();
        this.quantidade = 1;
        this.valor = 0.0;
    }
}
Especificamos que a negociação terá: data, quantidade e valor. Toda negociação terá a data atual por padrão, logo adicionamos o Date(). Para quantidade, começaremos com o valor padrão 1 e o valor, começará de 0.0.

Em seguida, no arquivo index.html, vamos incluir uma nova tag <script>. Nosso objetivo será criar duas instância de negociação, ou seja, dois objetos criados a partir da classe Negociacao. Usaremos as variáveis n1 e n2.

<script>

    var n1 = new Negociacao();
    console.log(n1);

    var n2 = new Negociacao();
    console.log(n2);

</script>
Vamos recarregar o navegador e abrir o Console. Veja que já aparecem duas Negociacoes:

duas negociacoes impressas

Ambas ganharam uma data, quantidade e o valor. Observe que nenhuma das Negociacoes tinham as propriedades especificadas no código. Elas foram impressas desta forma porque seguem a mesma classe.

Observe que utilizamos a palavra new no nosso código, dentro das variáveis:

var n2 = new Negociacao();
console.log(n2);
Vejamos o que aconteceria se ela não fosse utilizada na variável n2:

var n2 = Negociacao();
console.log(n2);
No navegador, uma mensagem de erro seria exibida no Console.

mensagem de erro

Somos informados que a classe constructor não pode ser invocada sem operador new. O operador new é o responsável pela inicialização do this de cada objeto criado. Cada objeto terá seu this com suas propriedades. O JavaScript é muito bonzinho e nos avisa do nosso erro:

class Negociacao {

    constructor() {

        this.data = new Date();
        this.quantidade = 1;
        this.valor = 0.0;
    }
}
Isto ocorre porque será o operador new que fará o this ser correspondente ao objeto criado no index.html. Então, se especificamos que a quantidade da variável n1 é igual a 10, saberemos que alteramos o valor unicamente da mesma. A variável n2 continuará com o mesmo valor.

<script>

    var n1 = new Negociacao();
    n1.quantidade = 10;
    console.log(n1);

    var n2 = new Negociacao();
    n2.quantidade = 20;
    console.log(n2);

</script>
O operador new é bastante importante por ser o responsável em criar um novo this para cada instância da classe. O this é uma variável implícita que sempre apontará para a instância que está executando a operação naquele momento.

Agora, se executarmos o código, no Console do navegador, veremos que cada Negociacao terá um valor diferente.

Negociacoes impressas 2

Caso o this não variasse para cada instância, quando alterássemos o valor da quantidade de n1, mudaríamos também a quantidade de n2. Por isso, o JavaScript não me deixa invocar uma instância sem adicionar termo new.

Então, realizamos o primeiro teste com duas estruturas semelhantes, mas com propriedades de valores diferentes.
*******************
03-Construtor da classe e métodos
Continuaremos com a construção do código. A primeira ação será apagarmos uma das Negociacoes, no arquivo index.html:


<script src="js/app/models/Negociacao.js"></script>
<script>

    var n1 = new Negociacao();
    n1.quantidade = 10;
    console.log(n1);

</script>
Agora, definiremos também o valor da variável, que será igual a 200.50.

<script>

    var n1 = new Negociacao();
    n1.quantidade = 10;
    n1.valor = 200.50;
    console.log(n1);

</script>
O valor já será impresso no Console.

valor no console

No entanto, existe uma outra forma para passarmos uma instância de Negociacao. Imagine que no momento em que criamos uma Negociacao e a instância está nascendo, já queremos que seja definida a quantidade, valor e data. Queremos que esses dados sejam passado imediatamente para o construtor.

Se o contructor() é uma espécie de função, significa que ela aceitará parâmetros. Considerando isto, adicionaremos os valores para Negocicao() no n1:

<script>

    var n1 = new Negociacao(new Date(), 5, 700);

</script>
Em Negociacao.js, adicionaremos os parâmetros de constructor():

class Negociacao {

    constructor(data, quantidade, valor) {

        this.data = data;
        this.quantidade = quantidade;
        this.valor = valor;

    }
}
Observe que jogamos os parâmetros para as propriedades.

Atenção: Fique atento sobre a ordem dos parâmetros. Caso a ordem seja alterada, no HTML, os valores das instâncias ficarão incorretos.

Faremos um teste no Console para ver se tudo funcionou corretamente:

teste no console

Os valores coincidem com os que especificamos no HTML. Porém, ainda não adicionamos o volume - a quantidade multiplicada pelo valor. Faremos isto agora:

<script>

    var n1 = new Negociacao(new Date(), 5, 700);
    var volume = n1.quantidade * n1.valor;
    console.log(volume);

</script>
Vamos imprimir o volume no Console:

volume

O valor 3500 é o resultado da operação de multiplicação. Mas estamos fazendo uma programação procedural, e sempre que o programador precisar do volume, ele mesmo terá que realizar este cálculo. Mas então, ele precisaria já saber como calcular o volume? Aumentaria a chance de erro. O que podemos fazer é dotar a classe Negociacao com comportamento. A programação orientada a objeto tem uma forte conexão entre o dado e o comportamento. Os dois caminharam juntos.

Caso você tenha alguma dúvida sobre o assunto, encontrará uma explicação mais detalhada na seguinte exemplificação.

Em seguida, no index.html, em vez de incluirmos o cálculo do volume na variável n1, faremos uma pergunta para a classe.

<script>

    var n1 = new Negociacao(new Date(), 5, 700);
    var volume = n1.obtemVolume();
    console.log(volume);

</script>
Depois, teremos que adicionar um método em Negociacao.js. Iremos combinar algo: quando criamos uma função dentro de uma classe, nós chamaremos a primeira de método. Quando a função estiver fora da classe, continuará sendo chamada de função. Então, criaremos o método obtemVolume dentro da classe Negociacao:

class Negociacao {

    constructor(data, quantidade, valor) {

        this.data = data;
        this.quantidade = quantidade;
        this.valor = valor;

    }

    obtemVolume() {

        return this.quantidade * this.valor;
    }
}
Agora, ao executarmos o código, o valor 3500 aparecerá novamente no Console:

volume 2

O valor foi calculado corretamente. O objeto sabe lidar com as propriedades trabalhadas. Logo, a regra de como obter o volume está no próprio objeto. Voltamos a ter uma conexão entre dado e comportamento.
*******************
04-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************
01-
*******************