Aula02
01-O que é um modelo?
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui para continuar seus estudos.

Anteriormente, não ficou claro onde se encontrava a negociação no código. Nós vimos que havia ficado confuso onde estava o modelo e a apresentação. Definimos que seria interessante separar o modelo e a visualização, aplicando o MVC (Model-View-Controller). Mas o que é um modelo? Trata-se de uma abstração do mundo real. Por exemplo, um analista de mercado que quer entender como o mercado funciona, criará um modelo em que ele possa dar entradas e executar determinado procedimentos para tentar prever como é o seu funcionamento. No nosso caso, faremos a mesma coisa.

Nós queremos criar um modelo de negociação que programaticamente deve ser capaz de fazer tudo o que seria feito no mundo real. Para materializarmos o modelo de negociação, usaremos um recurso do paradigma da programação orientada de objetos: a criação de classes. Antes do ES6, já era possível aplicar o paradigma com o JavaScript, porém, a sintaxe era mais complexa. Por isso, o ES6 trouxe novos recursos para que seja mais fácil a aplicação do paradigma.

Então, primeiramente criaremos uma classe, ou seja, uma especificação da negociação com a abstração da mesma, dentro do código.
*******************
02-A classe Negociação
A seguir, criaremos a classe Negociacao. Nós não usaremos mais a classe index.js. Nós também seguiremos a seguinte convenção: dentro da pasta js, encontramos a app, que contêm todo o código da aplicação. Dentro dela, encontraremos a subpasta models, em que estão armazenados todos os modelos. Também convencionaremos que queremos criar a classe Negociacao.js, o script que iremos criar, começará em caixa alta (com letra maiúscula). Isto é um pouco incomum, mas isto deixará claro que o JS é uma classe. No arquivo index.html, importaremos a Negociacao.js.

Para criarmos a classe com o ES6, usaremos a sintaxe class Negociacao. Ela terá o mesmo nome do arquivo, propositalmente, para que haja uma paridade e maior organização - mas não era obrigatório. E como definiremos os atributos de uma classe no ES6? Utilizando a função constructor().

class Negociacao {

    constructor() {

        this.data = new Date();
        this.quantidade = 1;
        this.valor = 0.0;
    }
}
Especificamos que a negociação terá: data, quantidade e valor. Toda negociação terá a data atual por padrão, logo adicionamos o Date(). Para quantidade, começaremos com o valor padrão 1 e o valor, começará de 0.0.

Em seguida, no arquivo index.html, vamos incluir uma nova tag <script>. Nosso objetivo será criar duas instância de negociação, ou seja, dois objetos criados a partir da classe Negociacao. Usaremos as variáveis n1 e n2.

<script>

    var n1 = new Negociacao();
    console.log(n1);

    var n2 = new Negociacao();
    console.log(n2);

</script>
Vamos recarregar o navegador e abrir o Console. Veja que já aparecem duas Negociacoes:

duas negociacoes impressas

Ambas ganharam uma data, quantidade e o valor. Observe que nenhuma das Negociacoes tinham as propriedades especificadas no código. Elas foram impressas desta forma porque seguem a mesma classe.

Observe que utilizamos a palavra new no nosso código, dentro das variáveis:

var n2 = new Negociacao();
console.log(n2);
Vejamos o que aconteceria se ela não fosse utilizada na variável n2:

var n2 = Negociacao();
console.log(n2);
No navegador, uma mensagem de erro seria exibida no Console.

mensagem de erro

Somos informados que a classe constructor não pode ser invocada sem operador new. O operador new é o responsável pela inicialização do this de cada objeto criado. Cada objeto terá seu this com suas propriedades. O JavaScript é muito bonzinho e nos avisa do nosso erro:

class Negociacao {

    constructor() {

        this.data = new Date();
        this.quantidade = 1;
        this.valor = 0.0;
    }
}
Isto ocorre porque será o operador new que fará o this ser correspondente ao objeto criado no index.html. Então, se especificamos que a quantidade da variável n1 é igual a 10, saberemos que alteramos o valor unicamente da mesma. A variável n2 continuará com o mesmo valor.

<script>

    var n1 = new Negociacao();
    n1.quantidade = 10;
    console.log(n1);

    var n2 = new Negociacao();
    n2.quantidade = 20;
    console.log(n2);

</script>
O operador new é bastante importante por ser o responsável em criar um novo this para cada instância da classe. O this é uma variável implícita que sempre apontará para a instância que está executando a operação naquele momento.

Agora, se executarmos o código, no Console do navegador, veremos que cada Negociacao terá um valor diferente.

Negociacoes impressas 2

Caso o this não variasse para cada instância, quando alterássemos o valor da quantidade de n1, mudaríamos também a quantidade de n2. Por isso, o JavaScript não me deixa invocar uma instância sem adicionar termo new.

Então, realizamos o primeiro teste com duas estruturas semelhantes, mas com propriedades de valores diferentes.
*******************
03-Construtor da classe e métodos
Continuaremos com a construção do código. A primeira ação será apagarmos uma das Negociacoes, no arquivo index.html:


<script src="js/app/models/Negociacao.js"></script>
<script>

    var n1 = new Negociacao();
    n1.quantidade = 10;
    console.log(n1);

</script>
Agora, definiremos também o valor da variável, que será igual a 200.50.

<script>

    var n1 = new Negociacao();
    n1.quantidade = 10;
    n1.valor = 200.50;
    console.log(n1);

</script>
O valor já será impresso no Console.

valor no console

No entanto, existe uma outra forma para passarmos uma instância de Negociacao. Imagine que no momento em que criamos uma Negociacao e a instância está nascendo, já queremos que seja definida a quantidade, valor e data. Queremos que esses dados sejam passado imediatamente para o construtor.

Se o contructor() é uma espécie de função, significa que ela aceitará parâmetros. Considerando isto, adicionaremos os valores para Negocicao() no n1:

<script>

    var n1 = new Negociacao(new Date(), 5, 700);

</script>
Em Negociacao.js, adicionaremos os parâmetros de constructor():

class Negociacao {

    constructor(data, quantidade, valor) {

        this.data = data;
        this.quantidade = quantidade;
        this.valor = valor;

    }
}
Observe que jogamos os parâmetros para as propriedades.

Atenção: Fique atento sobre a ordem dos parâmetros. Caso a ordem seja alterada, no HTML, os valores das instâncias ficarão incorretos.

Faremos um teste no Console para ver se tudo funcionou corretamente:

teste no console

Os valores coincidem com os que especificamos no HTML. Porém, ainda não adicionamos o volume - a quantidade multiplicada pelo valor. Faremos isto agora:

<script>

    var n1 = new Negociacao(new Date(), 5, 700);
    var volume = n1.quantidade * n1.valor;
    console.log(volume);

</script>
Vamos imprimir o volume no Console:

volume

O valor 3500 é o resultado da operação de multiplicação. Mas estamos fazendo uma programação procedural, e sempre que o programador precisar do volume, ele mesmo terá que realizar este cálculo. Mas então, ele precisaria já saber como calcular o volume? Aumentaria a chance de erro. O que podemos fazer é dotar a classe Negociacao com comportamento. A programação orientada a objeto tem uma forte conexão entre o dado e o comportamento. Os dois caminharam juntos.

Caso você tenha alguma dúvida sobre o assunto, encontrará uma explicação mais detalhada na seguinte exemplificação.

Em seguida, no index.html, em vez de incluirmos o cálculo do volume na variável n1, faremos uma pergunta para a classe.

<script>

    var n1 = new Negociacao(new Date(), 5, 700);
    var volume = n1.obtemVolume();
    console.log(volume);

</script>
Depois, teremos que adicionar um método em Negociacao.js. Iremos combinar algo: quando criamos uma função dentro de uma classe, nós chamaremos a primeira de método. Quando a função estiver fora da classe, continuará sendo chamada de função. Então, criaremos o método obtemVolume dentro da classe Negociacao:

class Negociacao {

    constructor(data, quantidade, valor) {

        this.data = data;
        this.quantidade = quantidade;
        this.valor = valor;

    }

    obtemVolume() {

        return this.quantidade * this.valor;
    }
}
Agora, ao executarmos o código, o valor 3500 aparecerá novamente no Console:

volume 2

O valor foi calculado corretamente. O objeto sabe lidar com as propriedades trabalhadas. Logo, a regra de como obter o volume está no próprio objeto. Voltamos a ter uma conexão entre dado e comportamento.
*******************
04-Encapsulamento
Já conseguimos trabalhar com a classe Negociacao,precisamos implementar a seguinte regra de negócio: após criada a negociação, esta não poderá ser alterada. Mas até, agora, podemos fazer alterações.

Vamos ver o que acontece se adicionamos um valor para quantidade diferente do que especificamos no parâmetro.

<script>

    var n1 = new Negociacao(new Date(), 5,700);
    n1.quantidade = 10;
    console.log(n1.quantidade);
</script>
Qual valor será impresso no Console, 5 ou 10?

regra alterada

Ele imprimiu o valor recém adicionado 10. Isto pode causar problemas... Imagine que acabamos de fazer uma negociação e combinamos um determinado valor, mas depois decidimos alterá-lo para benefício próprio. Nosso objetivo é que as propriedades de uma negociação sejam somente para leitura. No entanto, a linguagem JavaScript - até a atual data - não nos permite usar modificadores de acesso. Não podemos dizer que uma propriedade seja apenas leitura (ou gravação). O que podemos é utilizar a convenção de que nos atributos das propriedades de uma classe que não pode ser modificada, usaremos um underline (_).

class Negociacao {

    constructor(data, quantidade, valor) {

        this._data = data;
        this._quantidade = quantidade;
        this._valor = valor;

    }

    obtemVolume {

        return this._quantidade * this._valor;
    }
}
Esta será uma convenção que informará ao programador que as propriedades que contenham _ só poderão ser acessadas pelos próprios métodos da classe. Isto significa, que mesmo podendo imprimir a propriedade _quantidade com outro valor, não deveríamos mais poder acessá-la. O _ funciona como um aviso dizendo: "programador, você não pode alterar esta propriedade!". Então, se usamos a convenção de utilizar o prefixo, como faremos para imprimir a classe? Se não podemos acessá-la, como podemos fazer isso? Para isto, criou-se métodos chamados acessadores, em que serão utilizados o prefixo get. No caso, em Negociacao.js, adicionaremos o método getData(), que retornará o _data. Usaremos também o getQuantidade() e o getValor que terão finalidades semelhantes.


obtemVolume() {

    return this._quantidade * this._valor;

}

getData() {
    return this._data;
}

getQuantidade() {
    return this._quantidade;
}

getValor() {
    return this._valor;
}
Os métodos da classe poderão acessar os atributos que levam _. No entanto, de acordo com a nossa convenção, alguém fora da classe não poderá fazer o mesmo. Por isso, em index.html, já que não poderemos chamar n1._quantidade, chamaremos n1.getQuantidade().

<script>

    var n1 = new Negociacao(new Date(), 5, 700);
    console.log(n1.getQuantidade());
    console.log(n1.getData());
    console.log(n1.getValor());
</script>
Observe que estamos acessando os demais campos.

valores no console 

Os valores serão impressos corretamente no Console. Em seguida, modificaremos o obterVolume() para getVolume em Negocicacao.js:

getVolume() {

    return this._quantidade * this._valor;

}

getData() {
    return this._data;
}

getQuantidade() {
    return this._quantidade;
}

getValor() {
    return this._valor;
}
E adicioná-lo no index.html:

<script>

    var n1 = new Negociacao(new Date(), 5, 700);
    console.log(n1.getQuantidade());
    console.log(n1.getData());
    console.log(n1.getValor());
    console.log(n1.getVolume());
</script>
No navegador, veremos que os valores quantidade, data, valor e volume serão impressos corretamente.

quantidade e volume

DISCUTIR NO FORUM

*******************
05-A sintaxe get
Vamos ver como podemos "enxugar" a nossa classe Negociacao. Nós criamos métodos de leitura para poder acessar às variáveis que convencionamos que são privadas, ou seja, só a própria classe poderá acessá-las. Mas existe um atalho que poderá ser usado quando queremos acessar uma propriedade: usaremos o get.

get volume() {

    return this._quantidade * this._valor;

}

get data() {
    return this._data;
}

get quantidade() {
    return this._quantidade;
}

get valor() {
    return this._valor;
}
Observe que fizemos pequenos ajustes no código. O get foi seguido de um método, que tem o nome das propriedades antes de adicionarmos o _. Essa alteração irá trazer mudanças também no arquivo index.html. Agora, poderemos substituir o n1.getQuantidade por n1.quantidade.

<script>

    var n1 = new Negociacao(new Date(), 5, 700);

    console.log(n1.quantidade);
    console.log(n1.data);
    console.log(n1.valor);
    console.log(n1.volume);
</script>
Estamos criando uma propriedade getter de acesso à leitura. E mesmo sendo um método, poderemos acessá-lo como uma propriedade. Mas, debaixo dos panos, ele continuará sendo executado como um método.

console

Veja que os valores foram acessados corretamente, inclusive o valor de volume. Então, por mais que os valores se apresentem como uma propriedade, por debaixo dos panos, está sendo chamado um método. Agora, mesmo que definíssemos o valor 1000 para quantidade, ele não seria aplicado.

<script>

    var n1 = new Negociacao(new Date(), 5, 700);
    n1.quantidade = 1000;        
    console.log(n1.quantidade);
    console.log(n1.data);
    console.log(n1.valor);
    console.log(n1.volume);
</script>
O valor 1000 não será repassado para o _quantidade. O valor continuará sendo 5:

valor de quantidade inalterado

Isto acontece quando a propriedade é um getter (ou seja, é de leitura), não podemos atribuir para a mesma um valor. Mas ainda podemos acessá-la usando o n1._quantidade.

<script>

    var n1 = new Negociacao(new Date(), 5, 700);
    n1.quantidade = 1000;        
    n1._quantidade = 5000;
    console.log(n1.quantidade);
    console.log(n1.data);
    console.log(n1.valor);
    console.log(n1.volume);
</script>
quantidade alterada

No console, vemos que o valor da quantidade foi alterado para 5000. Mas a propriedade quantidade é somente de leitura, não aparece o _. Assim, se o programador tentar atribuir um valor, ele não será setado. Será que existe uma forma de garantirmos que uma negociação, depois de criada, não será alterada?
*******************
06-Objetos imutáveis
*******************
07Nós usaremos um artifício existente há algum tempo na linguagem JavaScript: "congelaremos" um objeto e com isso, qualquer alteração nas suas propriedades será ignorada. Isso funcionará no caso da classe Negociacao, porque nem mesmo os métodos da classe podem alterar as propriedades de uma negociação criada.

Para isso, usaremos o método Object.freeze() e vamos congelar o n1.

<script>

    var n1 = new Negociacao(new Date(), 5, 700);

    Object.freeze(n1);
    n1._quantidade = 100000000000;

    console.log(n1.quantidade);
    console.log(n1.data);
    console.log(n1.valor);
    console.log(n1.volume);
</script>
Por convenção, não podemos fazer isso. Mas será que conseguimos alterar um objeto congelado? Faremos um teste. No nosso caso, qual será o valor da quantidade: 5 ou 100000000000?

objeto congelado

No Console, veremos o valor 5, isto significa que não conseguimos alterar e o objeto foi congelado. Lembrando que quantidade, é uma propriedade que chamamos em Negociacao.js, que por "debaixo dos panos", rodará como um método e retornará this._quantidade:

 get quantidade() {
      return this._quantidade;
 }
Mesmo colocando n1._quantidade = 100000000000; no index.html, esse valor parece ter sido ignorado. Isso é bom, agora, o desenvolvedor já não conseguirá alterar esta quantidade. Vamos fazer um pequeno teste que nos mostrará o que está congelado no Console:

 <script>

     var n1 = new Negociacao(new Date(), 5, 700);

     console.log(Object.isFrozen(n1));
     Object.freeze(n1);
     console.log(Object.isFrozen(n1));
     n1._quantidade = 100000000000;

     console.log(n1.quantidade);
     console.log(n1.data);
     console.log(n1.valor);
     console.log(n1.volume);
 </script>
No Console, veremos o seguinte resultado:

Console com false e true

O objeto antes não era congelado e depois, foi. E por isso, não conseguimos alterar _quantidade, o atributo que por convenção definimos ser privado. Porém, essa solução é procedural, porque você terá sempre que lembrar de congelar a instância. No entanto, queremos que ao utilizarmos o new Negociacao, ele já devolva uma instância congelada. Nós podemos fazer isso, congelando a instância no construtor. Em Negociacao.js, adicionaremos Object.freeze() após último this:

class Negociacao {

    constructor(data, quantidade, valor) {

        this._data = data;
        this._quantidade = quantidade;
        this._valor = valor;
        Object.freeze(this);

    }

//...
No entanto, você se lembra que o this é uma variável implícita? E quando algum método é chamado, temos acesso à instância trabalhada? O this do Object.freeze() será o n1 no index.html.

<script>

    var n1 = new Negociacao(new Date(), 5, 700);

    n1._quantidade = 100000000000;

    console.log(n1.quantidade);
    console.log(n1.data);
    console.log(n1.valor);
    console.log(n1.volume);
</script>
Então, quando damos uma new Negociacao, ele já devolverá uma instância congelada. Aparentemente, resolvemos o nosso problema. Não é uma solução 100% de encapsulamento, porque ainda conseguimos enxergar o n1._quantidade - em linguagens como Java ou C#, não iríamos enxergá-lo. Em JS, enxergamos a _quantidade, mas não conseguimos alterá-la. Desta forma, garantimos que a negociação não será modificada.

Vamos verificar mais adiante se de fato a Negociacao não será alterada.-
*******************
07-A instância é imutável mesmo?
Pela regra de negócio, uma negociação deve ser imutável e não pode ser alterada depois de criada. Mas faremos um novo teste e nele vamos alterar a data da negociação. Já fizemos isto com a quantidade. Agora, criaremos a variável amanha que será referente a data de amanhã.

Usaremos o new Date() somado com 1. Sempre que trabalharmos com data, utilizaremos o setDate(). Como a data atual é 10, setaremos com o valor 11. Então, diremos que n1.data será igual a variável amanha.

<script src="js/app/models/Negociacao.js"></script>
<script>

    var n1 = new Negociacao(new Date(), 5, 700);

    console.log(n1.data);

    var amanha = new Date();
    amanha.setDate(11);

    n1.data = amanha;

    console.log(n1.data);
  </script>
Para verificar se o código funciona corretamente, adicionamos o console.log(). Se Negociação for realmente imutável, a data não poderá ser alterada.

negociacao imutavel

Vemos que ela continuou imutável.

Agora, quero fazer um teste diferente. Não vamos mais trabalhar com a variável amanha e vamos substituí-la por n1.data.setDate(). Como não é um método que existe na data, iremos defini-lo com 11:

<script>

    var n1 = new Negociacao(new Date(), 5, 700);

    console.log(n1.data);

    n1.data.setDate(11);

    console.log(n1.data);
</script>
Será que a data será alterada?

data alterada

Veja que a data foi alterada, no segundo console a data exibida foi 11. Isto significa que a nossa Negociacao é mutável. Assim, alguém pode acessar o sistema e alterá-lo, o que não pode acontecer.

Mas se nós utilizamos o Object.freeze(), por que isso aconteceu? O Object.freeze é shallow, ou seja, ele ficará na superfície. Quando congelamos um valor, não podemos alterá-lo. Porém, como _data é um objeto, não entrará como uma das propriedades do objeto. Então, não é feito o que chamamos de deep freeze. Quando trabalhamos com um objeto e dentro dele temos outras propriedades, estas não ficarão congeladas. Para resolver isso, aplicaremos uma aplicação defensiva mais adiante.
*******************
08-Programação defensiva
Uma maneira de tornar a instância imutável é quando chamam a propriedade getter data e é retornado uma nova instância de Date com a mesma data da negociação. Nós devolveremos uma nova referência, um novo objetivo. Atualmente, o get do arquivo Negociacao.js está assim:

get volume() {

    return this._quantidade * this._valor;

}

get data() {
    return this._data;
}

get quantidade() {
    return this._quantidade;
}

get valor() {
    return this._valor;
}
Vamos modificar o retorno do get data():

get data() {
    return new Date(this._data.getTime());
}
O getTime de uma data retornará um número long com uma representação da data. Se digitarmos no Console n1.data.getTime(), ele retornará um número que representará a data:

retorno da data

No construtor de Date(), este número será aceito para a construção de uma nova data. Então, quando pedimos uma nova data, ela será criada baseada na data da negociação. Trata-se de um novo objeto. Se tentarmos alterar no data do index.html, apenas a cópia será alterada - o novo objeto que retornei date, enquanto o interno seguirá inalterado. Isto é o que chamamos de programação defensiva. Vamos testar o nosso código, após as alterações feitas no get data() do Negociacao.js. Depois de recarregarmos a página no navegador, veremos a seguinte data no Console:

datas no console

Dessa vez não conseguimos alterar as datas no Console. Isto ocorreu porque apesar de termos usado o n1.data.setDate(11), ele não retornará a data original do objeto que ele já tem. Ele criará um novo objeto, uma nova referência baseada naquela data. Se alteramos o objeto, como fizemos no setDate(), não modificaremos a data da negociação. Devemos ter o mesmo cuidado com o construtor. Porque se passamos uma data no construtor do arquivo index.html, por exemplo, adicionando uma variável hoje.

<script>

    var hoje = new Date();

    var n1 = new Negociacao(hoje, 5, 700);

    console.log(n1.data);

    hoje.setDate(11);

    console.log(n1.data);
</script>
Observe que em vez de passarmos o new Date(), usamos o hoje. Quando a Negociacao receber o objeto hoje, ele guardará uma referência para o mesmo objeto. Isto significa que se alteramos a variável hoje, modificaremos a data que está na Negociacao. Se executarmos o código, a data será alterada para o dia 11.

data alterada 2

Por isso, usaremos o getTime() no construtor.

class Negociacao {

    construtor(data, quantidade, valor) {

        this._data = new Date(data.getTime());
        this._quantidade = quantidade;
        this._valor = valor;
        Object.freeze(this);

    }
//...
Ao fazermos isto, já não conseguiremos alterar a referência no index.html, porque o que estamos guardando no Negociacao não é mais uma referência para hoje, nós usaremos um novo objeto. Então, quando recarregarmos a página no navegador, a data que aparecerá no Console será 10.

No momento da criação do design das classes, seja cuidadoso com a imutabilidade.

Agora, você pode estar pensando o seguinte: apesar de _quantidade e _valor serem números, eles são objetos também. Mas isso não é um problema quando trabalhamos com o _quantidade, porque não temos nenhum método que irá alterá-lo. A única forma de fazermos isto é atribuindo um valor. Mas como _quantidade é imutável, não conseguiremos realizar esta ação também.

Com isso, finalizamos a blindagem da nossa classe para garantir a sua imutabilidade. Existem outras soluções mais avançadas no JS para tentarmos emular o privacy - a privacidade - do seu código. Mas, ao aplicá-las perdemos em legibilidade e performance. Então, a solução utilizada é a mais viável.
*******************
09-Substituindo var por let
Temos o estado do nosso modelo de negociação e podemos continuar com o nosso projeto. Mas antes de continuarmos, queremos implantar um novo hábito. Agora, que estamos utilizando ES6, em vez de usarmos o var para fazer a declaração de uma variável, usaremos o let.

<script>

    let hoje = new Date();

    let n1 = new Negociacao(hoje, 5, 700);

    console.log(n1.data);

    hoje.setDate(11);

    console.log(n1.data);
</script>
Se executarmos o código, tudo continuará funcionando normalmente.

data no console

Mas o que ganhamos com a mudança de var para let? Veremos um exemplo das vantagens de usarmos esta forma de declarar variável. Se formos declarar um for que vamos exibir de 1 a 100 escreveríamos o laço da seguinte forma:

<script>

    for(var i = 1; i<= 100; i++) {
        console.log(i);
    }
</script>
Ao executarmos o código, ele imprimirá corretamente os números de 1 a 100 no Console.

Porém, existe algo que programadores fora da linguagem JS acham estranho... Vamos adicionar um alert(i):

<script>

    for(var i = 1; i<= 100; i++) {
        console.log(i);
    }

    alert(i);
</script>
O que vai ser exibido no navegador?

alert

O alert exibiu o valor 101. Por quê? Quando se trabalha com linguagens como Java, C# e outras, as declaração de variáveis possuem escopo de bloco. Na prática, ao utilizarmos estas outras linguagens, jamais poderíamos acessar a variável i, como fizemos com o alert. Se adicionássemos uma variável chamada nome e depois, acrescentássemos um novo alert, o código ficaria assim:

<script>

    for(var i = 1; i<= 100; i++) {
        var nome = 'Flávio';
        console.log(i);
    }

    alert(i);
    alert(nome);
</script>
O segundo alert também seria exibido.

alert 2

Em JavaScript não existe escopo de bloco, então o fato de declararmos uma variável dentro de um bloco não garantirá que temos um escopo. No entanto, se declaramos as variáveis usando o let, estas ganharam um escopo de bloco.

<script>

    for(let i = 1; i<= 100; i++) {
         let nome = 'Flávio';
         console.log(i);
    }

    alert(i);
    alert(nome);
</script>
Agora, elas só existirão no bloco em que foram declaradas. Se executarmos o código, veremos a mensagem: i is not defined.

mensagem de erro

Isto ocorreu porque a variável i não existe fora do bloco. Desta forma, evitamos que as variáveis vazem fora do escopo que fazem parte.
*******************
10-Resumindo
Vamos revisar o que estudamos até aqui: vimos a criação de uma classe, utilizando novos recursos JavaScript que favorecem a implementação do paradigma orientado a objeto. Vimos também que uma classe possui um constructor com os quais definimos atributos - que chamamos de propriedades - e que podemos materializar uma abstração do mundo real usando um modelo, por meio de uma classe. Outro assunto abordado é que podemos passar parâmetros no construtor de uma classe e dessa forma, garantindo que no momento em que a instância de uma classe é criada, já tenha todos os dados necessários.

Por convenção, adotamos que os atributos privados devem usar o prefixo _ (underline), indicando para o desenvolvedor que ele só pode acessá-lo. Vimos como adicionar métodos nas classes, e estes, sim, podem acessar os atributos privados.

Apresentamos uma maneira de criar um atributo, que na prática é um método, e ao acessá-lo, podemos executar o código. Moral da história: temos um método que conseguimos acessar como uma propriedade, bastando ser antecedido pela palavra especial get, desta forma, estaríamos gerando um getter. Quem acessa a sua classe acredita que se trata de uma propriedade, mas na verdade, trata-se por "debaixo dos panos" de um método.

No entanto, isto não era suficiente para garantir a integridade da nossa negociação, que não pode ser alterada. Por isso, usamos o Object.freeze() para congelar um objeto depois de criado. Como Object.freeze() é shallow (raso), ele será aplicado nas propriedades do objeto, mas as propriedades que são objetos não serão todas congeladas. A ação ficará apenas na superfície. Para resolver esta questão, falamos um pouco sobre programação defensiva. Quando alguém tentar acessar a data, nós retornaremos uma nova data. Fizemos o mesmo com o construtor e com isso, evitamos que alguém consiga de fora da classe alterar algum item do estado interno.

O que vimos foi relevante porque o modelo é uma das coisas mais importantes quando desenvolvemos o sistema. Agora que temos o modelo pronto, a aplicação poderá crescer, tendo-o como base. No fim, deixamos a sugestão da adoção de um novo hábito: substituir nas declarações de variáveis o uso de var por let, que permite um escopo de bloco e evita que as mesmas vazem para um escopo global. Antes do ES6, em JavaScript, era comum o uso de funções para a criação de um escopo para a variável.

Vamos continuar com os nossos estudos e façam os exercícios para praticar os conceitos vistos.
*******************
11-Pequeno conto sobre orientação a objetos
Não é necessário responder a este exercício, ele apenas passa uma visão geral sobre o paradigma orientado a objetos.

Barney: Flávio, eu sou programador, mas até hoje não consigo entender o que seria orientação a objetos. Pode me explicar?

Flávio: orientação a objetos prega uma forte conexão entre dado e comportamento.

Barney: ...

Flávio: hehe, não captou ainda, certo?

Barney: não mesmo!

Flávio: bom, imagine que eu tenha aqui em minhas mãos uma garrafa de cerveja, aquelas tradicionais. Pense no líquido da garrafa como um dado, uma informação. Ok?

Barney: Ok!

Flávio: eu dou essa garrafa em suas mãos e peço para que você a abra. Como você faz?

Barney: eu uso um abridor.

Flávio: boa tentativa, mas eu te passei o abridor?

Barney: não!

Flávio: viu que além de passar a garrafa eu preciso lembrar de te passar um abridor? Eu pedi para você pensar no líquido da garrafa como dado, agora peço que você pense no abridor como comportamento. Ok?

Barney: perfeito!

Flávio: então, se eu não te passei o abridor, como você conseguirá chegar até o líquido (dado) da garrafa?

Barney: hum, eu posso tentar abrir com o dente.

Flávio: é uma forma de você conseguir acessar o liquido (dado). Que mais? Tem outra forma de acessar o líquido?

Barney: sei lá, talvez batendo na quina da mesa.

Flávio: Barney, eu tenho certeza que você criará diversas maneiras de acessar líquido da garrafa, inclusive se você der essa garrafa para outra pessoa ela pode tentar abrir a garrafa de outra forma.

Flávio: agora eu te dei um saca rolha.

Barney: pra quê? Para abrir a garrafa?

Flávio: sim, você vai conseguir?

Barney: bom, até posso conseguir, mas corro o risco de me machucar, assim como abrir a garrafa com dente.

Flávio: excelente, veja que nesse caso o dado (líquido) é separado do comportamento que acessa o dado (forma de abrir). Quando isso acontece, cada um tenta bolar sua forma de acesso aos dados. Em programação, isso pode levar a repetição de código, além disso, como o dado é separado do comportamento que opera sobre ele, temos que lembrar onde em nossos zilhões de arquivos e bibliotecas está aquele comportamento que deve operar o dado.

Barney: acho que estou entendendo. O cenário que você passou para mim é o da programação procedural. Certo?

Flávio: isso mesmo Barney! Na programação procedural o dado e o comportamento estão separados.

Barney: e na orientação a objetos, como fica?

Flávio: nela, como disse, temos uma forte conexão entre dado e comportamento. Onde o dado vai, os comportamentos que operam sobre aqueles dados vão junto.

Barney: pode me dar um exemplo, ainda no contexto da garrafa de cerveja?

Flávio: claro. Imagine que agora eu dou para você uma garrafa long-neck e eu peço para que você a abra.

Barney: isso é fácil, basta eu girar a tampa da garrafa.

Flávio: veja que nesse caso o dado (líquido) caminha com o comportamento que operava sobre ele (abridor, que é a própria tampa). Onde quer que você leve a garrafa, a forma de acessar seu líquido será a mesma, seja aqui no Brasil ou no Japão. Veja que temos dado e comportamento caminhando juntos. Sequer você precisa lembrar de me pedir um abridor ou inventar outras formas de acesso ao líquido, porque o dado é fortemente conectado com o comportamento que opera sobre ele.

Barney: finalmente entendi!
*******************
12-
*******************
11-
*******************
11-
*******************
11-
*******************
11-
*******************
11-
*******************
11-
*******************
11-
*******************
11-
*******************
11-
*******************
11-
*******************
11-
*******************
11-
*******************