Aula03
01-A classe NegociacaoController
Começando deste ponto? Você pode fazer o download completo do projeto até aqui e continuar seus estudos.

Nós já temos a negociação criada, agora, precisamos capturar as ações do usuário e interagir com o modelo por meio de uma controller no modelo MVC. Nós criaremos instâncias de negociação. Primeiramente, precisamos criar o controller.

Atualmente, no index.html, só temos a importação do arquivo Negociacao.js:

<script src="js/app/models/Negociacao.js"></script>
Lembrando que não temos mais a outra tag <script> usada nos testes. Caso você ainda a tenha, deve apagá-la.

Em seguida, criaremos a classe NegociacaoController.js. Usamos a convenção usada anteriormente de começar o nome da classe em caixa alta. Quando clicarmos no botão "Incluir" do formulário, vamos submetê-lo e depois, chamaremos uma ação do controller para adicionar uma negociação na tabela. Por enquanto, focaremos na criação da Negociacao com base nas informações dos formulários.

Usaremos o método adiciona() na classe NegociacaoController. O método receberá como parâmetro um event.

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();
        alert('Chamei ação no controller');
  }
}
Chamamos o event.preventDefault(). Quando submetemos o formulário, se não cancelamos o comportamento padrão do mesmo, ele será recarregado. Com o event.preventDefault(), a controller cancelará a submissão do formulário para poder capturar os dados da negociação e incluir na lista. Ainda não colocamos constructor, porque a negociação ainda não tem nenhum atributo de classe.

Como faremos a ligação do método adiciona() com a submissão do formulário? Precisaremos fazer a importação do NegociacaoController.js. Também teremos uma tag <script> com a qual iremos instanciar esta controller.

<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script>
    let negociacaoController = new NegociacaoController();
</script>
Observe que fizemos declaração da variável negociacaoController com o let, conforme convencionamos. Agora, nossa controller já está acessível na página inteira.

Em seguida, dentro da tag <form>, adicionaremos onsubmit para submeter o formulário. E na instância de negociacaoController, chamaremos o método adiciona(event):

<body class="container">

    <h1 class="text-center">Negociações</h1>

        <form class="form" onsubmit="negociacaoController.adiciona(event)">
            <div class="form-group">
                <label for="data">Data</label>
                <input type="date" id="data" class="form-control" required autofocus/>
            </div>

  //...
A estratégia utilizada aqui é um pouco diferente do que vem sendo feita, geralmente, a associação entre tag e o evento é feita no parte JS do projeto. Mas inspirado por framework como o AngularJS, por exemplo, que faz a associação de uma ação da controller utilizando um evento. Usaremos isso, para escrever menos código na parte JavaScript. Como nossa página é dependente de JS, podemos fazer isso facilmente.

Se atualizarmos a página e preenchermos o formulário com dados aleatórios, após submetermos as informações, veremos a mensagem do alert.

ação no controller

Então, a ação da controller foi chamada. Mas o nosso objetivo não é exibir a mensagem, nós queremos criar um negociação. Teremos que gerar o código que instância a negociação. Faremos isto mais adiante.
*******************
02-Associando métodos do controller às ações do usuário
Ao clicarmos no botão "Incluir" do formulário, já conseguimos executar as ações da controller. Agora, precisamos capturar os dados preenchidos. Primeiramente, iremos exibi-los no Console. Para isto, criaremos a variável inputQuantidade.

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let inputData = document.querySelector('#data');
        let inputQuantidade =  document.querySelector('#quantidade');
        let inputValor = document.querySelector('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}
O document.querySelector() será o responsável por buscar no DOM os elementos com id #data, #quantidade e #valor - observe que conseguimos utilizar os seletores CSS. Os itens foram dispostos na ordem do formulário. Lembrando que cada input tem id no arquivo index.html.

Vamos executar o código para ver se todos os dados aparecem no Console do navegador. Preencheremos o formulário com a data 11/12/2016, a quantidade 1 e o valor 100.

dados do console

Os dados apareceram corretamente no Console, nós já conseguimos capturá-los. Mas veja que repetimos bastante o código, ficou uma sintaxe trabalhosa de ser digitada. Como em JavaScript temos as First Class Functions, podemos declarar a variável $ - como usado no jQuery - e dentro, jogaremos o document.querySelector. Poderemos fazer as seguintes substituições no código:

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let $ = document.querySelector;
        let inputData = $('#data');
        let inputQuantidade =  $('#quantidade');
        let inputValor = $('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}
Desta forma, ficou menos trabalhoso escrever o código. Mas se o executarmos como está, veremos uma mensagem de erro no navegador.

Não funcionou colocarmos o querySelector na variável $ para criarmos um alias. Por que não funcionou? O querySelector é uma função que pertence ao objeto document - chamaremos tal função de método. Internamente, o querySelector tem uma chamada para o this, que é o contexto pelo qual o método é chamado. Logo, o this é o document. No entanto, quando colocamos o querySelector dentro do $, ele passa a ser executado fora do contexto de document e isto não funciona. O que devemos fazer, então? Queremos tratar o querySelector como uma função separada. Nós queremos que ao colocarmos o querySelector para o $, ele mantenha a associação com o document. Para isto, usaremos o bind() :

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let $ = document.querySelector.bind(document);
        let inputData = $('#data');
        let inputQuantidade =  $('#quantidade');
        let inputValor = $('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}
Agora, estamos informando que o querySelector irá para a variável $, mas ainda manterá uma associação com document. Desta vez, o código funcionará corretamente no navegador. Vimos um truque que copia um pouco o que o jQuery faz de melhor e cria um "mini-framework", ao associarmos a variável $ com o querySelector - um seletor CSS - e mantendo a ligação com o document.

Até aqui, vimos como manipular os dados do DOM, além do truque citado para otimizar nosso código. Precisaremos ainda construir uma negociação com base nestes dados. Mas será que esta forma de organizar os dados é performática? Veremos isto mais adiante.
*******************
03-Evitando percorrer o DOM muitas vezes
O código funciona, mas se adicionarmos dez negociações e clicarmos dez vezes em "Incluir", o querySelector buscará a #data, #quantidade e #valor dez vezes também. No entanto, devemos evitar ao máximo percorrer o DOM. Sempre que executamos o querySelector, ele irá no DOM - que é uma árvore de elementos. O querySelector terá que buscar entre todos estes elementos. Porém, a API de DOM é um tanto "preguiçosa" e não gosta de executar essa ação.

Então, se adicionamos 100 negociações, teremos que fazer esta busca 100 vezes. Apesar de só estarmos trabalhando com três elementos no caso, queremos melhorar a nossa performance. Atualmente, nosso código está assim:

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let $ = document.querySelector.bind(document);
        let inputData = $('#data');
        let inputQuantidade =  $('#quantidade');
        let inputValor = $('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}
Para melhorar a performance, adicionaremos o constructor e moveremos os inputs para dentro dele. Mas em vez de criarmos uma variável, criaremos atributos de instâncias com o this.

class NegociacaoController {

  constructor() {

            let $ = document.querySelector.bind(document);

            this.inputData = $('#data');
            this.inputQuantidade =  $('#quantidade');
            this.inputValor = $('#valor');
  }

  adiciona(event) {
        event.preventDefault();


        console.log(this.inputData.value);
        console.log(this.inputQuantidade.value);
        console.log(this.inputValor.value);

  }
}
Quando o NegociacaoController for criado pela primeira vez, ele buscará os elementos do DOM do document, que serão guardados nas propriedades da classe. Adicionamos o this no console também.

Agora, mesmo que façamos 300 negociações, ele só fará uma busca no DOM pelos elementos. Com isto, conseguimos melhorar a performance. O impacto neste cenário é ínfimo, mas poderia ser maior em outros cenários. Se executarmos o código, veremos que será exibido corretamente no console.

Usaremos esta estratégia como se fosse um caching até o fim do curso.

dados no console
*******************
04-Criando uma instância de Negociacao
Nós iremos seguir a convenção de que os inputs só poderão ser acessados com NegociacaoController, não podendo ser acessados por fora da aplicação. Só os métodos de NegociacaoController poderão acessar esses atributos. Para isto, usaremos o prefixo _, convencionado anteriormente, que indicará para o programador .

class NegociacaoController {

  constructor() {

            let $ = document.querySelector.bind(document);

            this._inputData = $('#data');
            this._inputQuantidade =  $('#quantidade');
            this._inputValor = $('#valor');
  }

  adiciona(event) {
        event.preventDefault();


        console.log(this._inputData.value);
        console.log(this._inputQuantidade.value);
        console.log(this._inputValor.value);

  }
}
Continuamos seguindo a convenção. Agora, podemos criar a negociação com os dados do formulário, vamos então criar a variável negociacao e incluiremos os três parâmetros.

adiciona(event) {

    event.preventDefault();

    let negociacao = new Negociacao(
        this._inputData.value,
        this._inputQuantidade.value,
        this._inputValor.value
      );

      console.log(negociacao);

}
Passamos os parâmetros data, quantidade e valor para o construtor de Negociacao. Com os dados do formulário, nós já temos uma negociação. Queremos que a negociação seja adicionada em uma lista, mas não a iremos implementar ainda.

Vamos ver como ficou a página recarregada.

mensagem de erro console

Recebemos uma mensagem de erro, mas não foi em NegociacaoController. O erro ocorreu na classe Negociacao.js. No Console, vemos ainda em qual linha foi o problema. A falha nos avisou que data.getTime não é uma função. Como isso é possível?

class Negociacao {

    constructor(data, quantidade, valor) {

      this._data = new Date(data.getTime());
      this._quantidade = quantidade;
      this._valor = valor;
      Object.freeze(this);

    }
}
O que significa? A data que estamos passando para o construtor não é uma data? Para resolver isso, vamos descobrir qual é o tipo da data, usaremos a função typeof().

adiciona(event) {

    event.preventDefault();

    console.log(typeof(this._inputData.value));

    let negociacao = new Negociacao(
        this._inputData.value,
        this._inputQuantidade.value,
        this._inputValor.value
      );

      console.log(negociacao);

}
No Console, veremos que é uma string.

string

Isto significa que quando passamos a data para Negociacao, ela ainda é uma string e, obviamente, não teremos o getTime(). O que precisamos resolver antes? Precisamos encontrar uma maneira de converter a data - que está em texto - para um objeto Data. Priorizaremos isso, e cancelaremos a criação da negociação.

adiciona(event) {

    event.preventDefault();

    console.log(typeof(this._inputData.value));

    console.log(this._inputData.value);

}
Ao executarmos o código, veremos o seguinte código:

data string

Temos que ser capazes de transformar uma string em um objeto do tipo Date e depois passá-lo para negociação.

Mais adiante, faremos este processo de conversão.
*******************
05-Criando um objeto Date
Existem várias maneiras de construirmos uma data passando parâmetros para o construtor. Uma das formas que já vimos é que se já temos uma data, podemos colocar o retorno de getTime e passar para o construtor de Date. Será que podemos fazer este processo de forma direta? Se for possível, já resolvemos o nosso problema.

adiciona(event) {

  event.preventDefault();

  let data = new Date(this._inputData.value);
  console.log(data);
}
Se der certo o que fizemos, será retornada a string 2015-11-12. É o texto que o construtor está recebendo. Vamos fazer um teste:

data errada no console

A data que apareceu no Console não foi a mesma, em vez disso, vemos que o dia é 11. Então, não funcionou. Temos que encontrar outra maneira de trabalhar com essa data. Outra maneira de trabalhar com Date é utilizando um array, que terá o ano, mês, dia.

Se digitarmos no Console...

new Date(['2016', '11', '12']);
O retorno será a data correta:

new Date

Esta é uma forma de resolvermos. Precisamos ainda encontrar uma forma de transformar a data que é uma string, fique dentro do array. Como faremos com que a string saiba qual é o separador que ela deve considerar? Para isto, adicionaremos split('-'), e assim, a data será separada com hífens. Faremos um teste digitando no Console dataString.split('-'):

dataString.split('-')
["2015", "12", "11"]
Ele nos retornou a data correta. Então, executaremos o seguinte código:

adiciona(event) {

  event.preventDefault();

  let data = new Date(this._inputData.value.split('-'));
  console.log(data);
}
Resolvemos o problema da data.

console com a data correta

Por que conseguimos solucionar passando um array? Quando geramos o array com ano, mês e dia, ele transforma cada item em uma string e adiciona o separado. Só que quando passamos o array '2016', '11', '12', o que é o reagrupamento por debaixo dos panos de cada item usando o separador ,.

metodo join

Existe no array o método join(), que une todos os itens e depois, forma uma string com separadores.

string recebida

Temos a string que esperávamos receber. Mas, além de usar o split(), poderíamos utilizar o replace(). Adicionaremos uma expressão regular pedindo que seja trocado o hífen de todas as ocorrências da string (ou seja, global) por ,: replace(/-/g, ',').

adiciona(event) {

    event.preventDefault();

    let data = new Date(this._inputData.value.replace(/-/g, ','));
    console.log(data);
}
outra forma de fazer a data

A data ficou correta. Vimos que existem várias formas de resolver a questão da data, e o array nem precisa ser de string. Pode ser um array de número, que também será aceito.
*******************
06-Exercicio - Executando ações de um controller
Vejamos a declaração de uma controller:

// ContadorController.js

class ContadorController {

    constructor() {
        this._contador = 0;
        alert(this._contador);
    }

    get contador() {
        return this._contador;
    }

    incrementar() {
        this._contador++;
        alert(this._contador);
    }
}
Veja que o único dado que a controller possui é o contador, que começa a partir de 0. Quando o método incrementar for chamado, o valor do contador será incrementado e o valor atual será exibido na tela.

Qual das opções abaixo associa corretamente o botão <button> com o método incrementar de ContadorController?

Alternativa correta
<html>
  <head></head>
  <body>
    <button onclick="contadorController.incrementar">Incrementar</button>
    <script src="ContadorController.js"></script>
    <script>
        let contadorController = new ContadorController();
    </script>
  </body>
</html>

Alternativa correta
<html>
  <head></head>
  <body>
    <button onclick="contadorController.incrementar()">Incrementar</button>
    <script src="ContadorController.js"></script>
    <script>
        let contadorController = new ContadorController();
    </script>
  </body>
</html>
Alternativa correta
<html>
  <head></head>
  <body>
    <button click="contadorController.incrementar()">Incrementar</button>
    <script src="ContadorController.js"></script>
    <script>
        let contadorController = new ContadorController();
    </script>
  </body>
</html>

Alternativa correta
<html>
  <head></head>
  <body>
    <button onclick="contadorController.incrementar()">Incrementar</button>
    <script src="ContadorController.js"></script>
    <script>
        let contadorController =  ContadorController();
    </script>
  </body>
</html>
*******************
07-O problema com datas
Vimos como lidar com a convenção das datas para criar um objeto Date, mas veremos mais uma forma de realizar tal ação. Escreveremos no Console a seguinte linha:

let data = new Date(2016, 11, 12)
No entanto, se imprimirmos esta data, veremos o retorno abaixo:

Console

A data impressa é Mon Dec 12 2016. Por que ele imprimiu dezembro, se escrevemos mês 11? Porque nesta forma de se passar o Date, o mês deve ser passado de 0 a 11. Então, se queremos que a data seja em novembro, precisaremos diminuir o valor do mês. Vamos fazer um novo teste no Console, digitando:

data = new Date(2016,10,12)
Agora, a data já aparece correta.

Data correta

A novidade é que essa é a maneira que queremos usar para aplicar as datas na aplicação. Apesar da outra forma ser mais fácil, desejamos encontrar uma solução para construir um Date a partir da string vinda do formulário. Ao tentarmos resolver este problema, podemos ver muitos assuntos de programação funcional.

Então, eu peço que você dê uma pausa no vídeo e pense como você vai conseguir converter uma data no formato 2016-11-12 e passá-la para o construtor de Date da seguinte forma:

new Date(2016, 10, 12)
Pense um pouco a respeito e veremos mais adiante como eu vou resolver o assunto.
*******************
08-Resolvendo um problema com o paradigma funcional
Talvez você tenha encontrado uma solução diferente da minha, mas darei a minha "versão dos fatos". Nosso objetivo é que o Date receba no construtor o ano, mês e dia. Faremos alguns ajustes no código:

adiciona(event) {

    event.preventDefault();

    let data = new Date(
        this._inputData.value
    );
    console.log(data);
}
Lembrando que cada um dos itens será um parâmetro do construtor. Mas o mês tem que ser decrescido de 1. Em seguida, transformaremos a string em um array, utilizando o split('-'). Ao fazermos isto, a string 2016-11-12 se tornará um array de três elementos. Sabemos que se passarmos da forma como já está, conseguiremos o resultado desejado. Porém, não quero que o Date receba um array, queremos que ele receba a primeira posição do array como a primeira posição do construtor e que o processo se repita com o segundo e terceiro elemento do array.

No ES6, temos o recurso spread operator. Observe o que faremos no código:

adiciona(event) {

    event.preventDefault();

    let data = new Date(...this._inputData.value.split('-'));
    console.log(data);
}
Adicionamos ... (reticências) posicionado antes do this. Com este spread operator, indicamos que o array será desmembrado - e o primeiro item do array, e cada parâmetro do Date será posicionado na mesma ordem no construtor. Como já construímos o código, a data será passada, mas o mês ficará incorreto e não será subtraído 1. Executaremos o código como está e a data aparecerá como o mês de Dezembro.

data incorreta

Mas conseguimos demonstrar que o spread operator está funcionando corretamente. Porém, temos que encontrar uma forma de, antes de reposicionarmos cada parâmetro para o constructor, decrementarmos 1 do valor do mês. Para isto, trabalharemos com a função map(), bem conhecida no mundo JavaScript e que nos permitirá subtrair 1. Então, iremos chamar a função map no array criado e dependendo do elemento, iremos diminuir -1.

adiciona(event) {

    event.preventDefault();

    let data = new Date(...
        this._inputData.value
        .split('-')
        .map(function(item) {
            return item;
        })
    );
    console.log(data);
}
Com o return item, varremos o array onde temos ano, mês e dia, e recriaremos a mesma lista de elementos. Ou seja, não teremos nenhuma transformação. Se executássemos o código como ele está, a data continuaria com o mesmo problema. Nós precisamos que o mês 11 se torne 10.

Continuaremos tentando resolver o problema, adicionando um segundo parâmetro na função map(): indice. Incluiremos um if, no qual especificaremos que quando passarmos pelo elemento 1 (o segundo) do array, vamos subtrair 1.

adiciona(event) {

    event.preventDefault();

    let data = new Date(...
        this._inputData.value
        .split('-')
        .map(function(item, indice) {
            if(indice == 1) {
                return item - 1;
            }
            return item;
        })
    );
    console.log(data);
}
Apesar de item ser uma string, quando usamos -1, o JS entende que deverá fazer um operação numérica e faz a conversão implícita da string. Caso não seja o segundo elemento, a posição do mês, o retorno será equivalente ao valor do elemento do array.

Veremos se o código vai funcionar. No formulário, preencheremos o campo da data com 12/11/2016. Desta vez, a data que aparecerá no Console estará correta.

datas correspondentes

Nós conseguimos, encadeando uma série de funções, converter só o segundo item do array e depois, decrementá-lo. Mas é possível eliminar o if. Em vez do laço, faremos alterações na função map():

return item - indice % 2  
O trecho do código ficará da seguinte forma:

//...
adiciona(event) {

    event.preventDefault();

    let data = new Date(...this._inputData
        .value.split('-')
        .map(function(item, indice) {
            return item - indice % 2;
        }));
Se estamos na primeira posição do array, o valor de indice é 0. Por isso, o resultado de indice % 2 será igual a 0 também. Se subtrairmos este valor de item, nada irá mudar. Mas quando estivermos na segunda posição do array, o indice será igual a 1. Agora, quando calcularmos 1 módulo de 2, o resultado será 1. E quando estivermos na terceira posição do array, 2 módulo de 2, também será igual a 0. Não diminuiremos nada do valor do item. Dessa forma conseguimos evitar a criação de um if.

Para entendermos melhor o que fizemos, calcularemos os módulos no Console:

0 % 2
modulo de 0

A última linha retornou o valor do resultado: 0, ou seja, a primeira posição do array. Se calcularmos os módulos dos demais, teremos os seguintes valores.

valores dos modulos

Desta forma, conseguimos evitar o if e ajustar apenas o mês. Até aqui, o nosso código ficou assim:



class NegociacaoController {

    constructor() {

        let $ = document.querySelector.bind(document);
        this._inputData = $('#data');
        this._inputQuantidade = $('#quantidade');
        this._inputValor = $('#valor');

    }

    adiciona(event) {

        event.preventDefault();

        let data = new Date(...this._inputData
            .value.split('-')
            .map(function(item, indice) {
                return item - indice % 2;
            }));

        let negociacao = new Negociacao(
            data,
            this._inputQuantidade.value,
            this._inputValor.value
        );

        console.log(negociacao);
    }
}
Se ele for executado, veremos que a data que surgirá no Console será 12 de novembro de 2016.
*******************
09-Arrow Functions: deixando o código ainda menos verboso
Podemos ainda deixar o nosso código menos "verboso", usando uma forma diferente de declarar função - utilizada a partir da versão ES2015: falamos das arrow functions. O termo arrow traduzido para o português significa flecha. Com estas funções, podemos eliminar a palavra function do código. Mas se simplesmente apagarmos a palavra e tentarmos executar o código, teremos um erro de sintaxe que será apontado no navegador. Para omitirmos o termo, teremos que adicionar => (que representa uma flecha). Ela sinalizará que temos uma arrow function que receberá dois parâmetros.

adiciona(event) {

    event.preventDefault();

    let data = new Date(...
        this._inputData.value
        .split('-')
        .map((item, indice) => {
            return item - indice % 2;
        })
    );
    console.log(data);
}
Quando usamos a sintaxe da flecha, já sabemos que se trata de uma arrow function. Se testarmos atualizar a página no navegador, veremos que tudo funciona.

A data preenchida no formulário corresponde com a data no Console. Agora, uma pergunta: no bloco da arrow functions, quantas instruções nós temos? Apenas uma: return item - indice % 2. A linha está dentro da função map():

.map((item, indice) => {
    return item - indice % 2;
});
Quando trabalhamos só com uma instrução, podemos omitir o bloco:

let data = new Date(...
    this._inputData.value
    .split('-')
    .map((item, indice) => item - indice % 2)
);
Temos que colocar a função com a instrução inline e não precisamos colocar o ;. Como só temos essa instrução, a arrow function já irá fazer o retorno e podemos apagar o return. O código fica muito mais simples!

Se rodarmos o código no navegador, o formulário está funcionando normalmente e a data aparecerá como desejamos no Console. Nós conseguimos reduzir a "verbosidade" do código, usando uma arrow function. Em seguida, criaremos a variável negociacao:

let data = new Date(...
    this._inputData.value
    .split('-')
    .map((item, indice) => item - indice % 2)
);

let negociacao = new Negociacao(
    data,
    this._inputQuantidade.value,
    this._inputValor.value
  );

  console.log(negociacao);
Se testarmos no navegador veremos no console a Negociacao impressa.
*******************
10-Resumindo
Vamos revisar o que vimos até aqui e entender o quanto evoluímos. Nós criamos a primeira Controller da negociação: NegociacaoController. Vimos como associar uma ação do usuário, como a submissão do formulário, e chamar o método controller. Para criar um negociação do DOM, tivemos que criar os elementos do DOM, equivalente ao input da quantidade, da data e do valor para capturar os valores, sendo possível depois, instanciar uma negociação. Comentamos também como não é recomendável fazer isto todas as vezes que chamarmos o método adiciona(). Por isso, colocamos como propriedade da classe NegociacaoController o elemento do DOM.

Para evitarmos escrever repetidas vezes document.querySelector, nós usamos o "truque" de colocá-lo na variável $. Mas vimos que neste processo, o querySelector perdia o contexto do document, e o this deixava de apontar para este. Para resolver o assunto, usamos a chamada para o método bind() e o $ - equivalente ao querySelector - fizesse uma referência para o document. Fizemos um sintaxe parecida com jQuery.

Falamos também que não era suficiente capturarmos a data do formulário e passá-la como parâmetro para o construtor de Date, porque o input vinha no formato ano, mês e dia. Depois, tivemos que fazer algumas transformações e vimos que o Date aceita trabalhar com alguns parâmetros. Passamos um array para o Date, também passamos uma string com ano, mês e dia, cada item separado por uma vírgula. Existem várias formas de trabalharmos com a data, mas precisamos ajustar a data que lemos no formulário e está num formato string, para o formato compatível para o construtor do Date.

Eu deixei um desafio para você: eu queria que fosse usado um construtor que usasse ano, mês e dia, cada um disposto como um parâmetro diferente no construtor. Porém, neste formato, o mês não pode ser passado de 1 a 12, no caso, precisaria ser de 0 a 11. então, foi necessário realizar algumas transformações e precisamos um pouco de programação funcional.
*******************
11-Exercicio - O modelo MVC
Sobre o modelo MVC, podemos afirmar que:

Alternativa correta
O C é o controller, aquele que disponibiliza um modelo para a view.


O controller é aquele que recebe as ações do usuário e que sabe interagir com o modelo. Como o modelo é independente da view, esta precisa ser renderizada para que reflita as alterações no modelo. Em suma, o controller é a ponte de ligação entre a view e o modelo.

Alternativa correta
M é o modelo, uma abstração do mundo real, os dados da aplicação e suas regras de negócio.


O padrão MVC permite que alterações de layout na view não acarretem alterações no modelo.

Alternativa correta
O modelo MVC é exclusivo de aplicações web.


Alternativa correta
A View é a representação do modelo em alguma tecnologia, por exemplo, HTML.


A view apresenta um modelo em uma tabela, em um formulário ou em parágrafos, e o padrão MVC permite que qualquer alteração na view não interfira com o modelo.
*******************
12-Exercicio - O que é má prática ontem pode ser boa prática hoje e vice-versa!
No mundo front-end, há uma separação clara entre HTML, CSS, JS. Tanto isso é verdade que a boa prática é que cada um fique no seu quadrado, ou seja, que cada um tenha seu arquivo dedicado. Essa separação visa facilitar a manutenção.

Contudo, quando manipulamos o DOM, vira e mexe precisamos associar eventos a elementos. Uma maneira de se fazer isso é encontrar o elemento que queremos associar o evento, e realizar essa associação via JavaScript. Vejamos um exemplo:

<p id="p1">Olá</p>
Temos um parágrafo com um id definido. No mundo JavaScript, se quisermos associar um evento click ao parágrafo, precisamos buscá-lo primeiro e depois associar o evento:

function mostra() {
    alert('Fui clicado');
}

document.querySelector('#p1').addEventListener('click', mostra);
O código anterior funciona perfeitamente, inclusive deixou marcante a separação entre HTML e JS, pois em nenhum momento no HTML referenciamos nosso JS (apenas a tag <script> que o carrega, claro).

Contudo, essa solução nos obriga a manipular o DOM toda vez que quisermos associar um evento com o elemento. Sendo assim, quando criamos SPA (Single Page Applications), páginas que não se recarregam durante seu uso é muito comum usar a abordagem clássica, que é associar a função do evento diretamente na tag <html> da nossa página.

Qual das opções abaixo associa diretamente na tag <p> o evento click para a função mostra?

Alternativa correta
<p id="p1" click="mostra()">Olá</p>

Precisamos associar ao evento onclick, em

, a chamada da função mostra()

Alternativa correta
<p id="p1" click="mostra">Olá</p>

Alternativa correta
<p id="p1" onclick="mostra()">Olá</p>
Dependendo do seu viés teórico, essa solução pode ser uma "heresia". Contudo, frameworks SPA, como Angular, adotam estrutura semelhante para associar a ação de um controller a um componente da página, dessa forma, removendo o desenvolvedor de ter que realizar essa associação manualmente.
*******************
13-Exercicio - As múltiplas facetas do this
Vejamos o seguinte código!

class Pessoa {

    constructor(nome) {
        this.nome = nome;
    }
}

function exibeNome() {
    alert(this.nome);
}

let pessoa = new Pessoa('Salsifufu');

exibeNome('Lampreia'); // PRIMEIRA CHAMADA <=============

exibeNome = exibeNome.bind(pessoa);

exibeNome(); // SEGUNDA CHAMADA <=============
O que será exibido na PRIMEIRA e SEGUNDA chamada respectivamente?

Alternativa correta
undefined e Salsifufu

Alternativa correta
Lampreia e undefined


Alternativa correta
undefined e Lampreia.


Alternativa correta
Salsifufu e undefined


A resposta correta é undefined e Salsifufu.

Na primeira chamada, o parâmetro Lampreia é ignorado pela função, pois a função não recebe parâmetros. Não acontece nenhum erro, mesmo a função não recebendo o parâmetro, uma característica do JavaScript. Sendo assim, quando exibeNome('Lampreia') é chamado, o this na verdade é window, o escopo global, e nele não temos o valor nome.

Contudo, quando executamos a linha:

exibeNome = exibeNome.bind(pessoa);
Estamos recebendo uma referência para uma nova função, que passa a ter o objeto pessoa como this. Ou seja, a função bind, presente em todas as funções, permite indicar qual será o valor de this quando ela for executada, em nosso caso pessoa. Como pessoa possui a propriedade nome, será exibido no alerta o valor Salsifufu.

É por isso que fizemos ao longo deste capítulo:

let $  = document.querySelector.bind(document);
O retorno da função bind é a função querySelector, que tem como contexto o document, ou seja, seu this será document. Se tivéssemos feito apenas:

let $  = document.querySelector;
A variável $ passa a ser querySelector, mas seu this deixará de ser document, porque estará sendo executada fora deste contexto.
*******************
14-"Prefiro evitar a fadiga!"
Temos o seguinte controller:

// ContadorController.js
class ContadorController {

    constructor() {
        this._contador = 0;
        alert(this._contador);
    }

    get contador() {
        return this._contador;
    }

    incrementa() {
        this._contador++;
        document.querySelector('#p1').textContent = this._contador;
    }
}
E claro, uma página que importa o script do controller, instanciando-o e associando um botão à ação contadorController.incrementa():

<html>
    <head></head>
    <body>
        <p id="p1">0</p>
        <button onclick="contadorController.incrementa()">Incrementar</button>
        <script src="ContadorController.js"></script>
        <script>
            let contadorController = new ContadorController();
        </script>
    </body>
</html>
Nosso código funciona, contudo, a maneira como organizamos nosso código pode causar problemas de performance em uma aplicação com escopo maior.

VER OPINIÃO DO INSTRUTOR
-----
Opinião do instrutor

Sob o ponto de vista funcional, não há problema algum em nosso código, pois ele funciona e atende o requisito, que é incrementar o total do contador e exibir o seu estado atual na view. Contudo, podemos melhorar esse código. Veja que a cada clique do usuário, solicitamos ao document que busque o elemento que desejamos. Qual o problema? Uma analogia pode nos ajudar.

Você tem 200 papéis importantes e pega na sala ao lado uma caneta para assinar o primeiro deles, para logo em seguida devolver a caneta. Imagine repetir esse processo para os 199 papéis restantes? Pois é, o DOM (document) também ficará fadigado se você buscar o mesmo elemento 200 vezes!

Para evitar a "fadiga", uma boa estratégia é realizar uma espécie de cache do elemento do DOM que você deseja manipular, ou seja, guardar sua referência, para que você o busque apenas uma vez. Em nosso modelo MVC, com o uso de classes fica fácil definir em que lugar guardaremos uma referência para o elemento que estamos buscando.

Podemos guardar a referência do elemento em uma propriedade na classe e toda vez que alguém precisar desse elemento basta acessar a propriedade que o referencia, evitando assim, percorrer o DOM, fatigando-o! Como as propriedades na classe são inicializadas através do operador new, que chama por debaixo dos panos o constructor da classe, podemos buscar o elemento assim que o nosso controller for instanciado, apenas.

Aplicando os conceitos que vimos anteriormente, nossa classe ContadorController fica assim:

class ContadorController {

    constructor() {
        this._contador = 0;
        this._elemento = document.querySelector('#p1'); // busca uma única vez
        alert(this._contador);
    }

    get contador() {
        return this._contador;
    }

    incrementa() {
        this._contador++;
        this._elemento.textContent = this._contador; // não precisa buscar o elemento, já temos uma referência para ele
    }
}
Apesar do problema original não ser suficiente para fatigar o DOM, ter sempre em mente escrever um código otimizado e sem comprometer sua legibilidade é um bom caminho a se trilhar.
*******************
15-"Isso" não encaixa em um "Date"? Se vira!
JavaScript possui um objeto especial para representar datas, o objeto Date. Sua criação é direta:

let hoje = new Date();
Quando instanciamos Date sem passar qualquer parâmetro para o seu construtor, é criado um objeto com a data naquele momento. Contudo, podemos criar uma data seguindo o seguinte formato:

let outraData = new Date('2016/05/17'); // formato ano/mês/dia
Internamente, o construtor de Date está preparado para lidar com uma string neste formato e criar uma instância correspondente. Podemos até obter o dia, o mês e o ano de uma data usando seus métodos correspondentes:

let outraData = new Date('2016/05/17'); 
console.log(outraData.getDate()); // imprime 17
console.log(outraData.getMonth()); // imprime 4
console.log(outraData.getFullYear()); // imprime 2016
Não podemos esquecer que um Date guarda internamente os meses de 0 a 11, é por isso que outraData.getMonth() retorna 4 e não 5.

Podemos construir uma nova data também dessa maneira:

let outraDataOutraManeira = new Date(2016, 4, 17);
Veja que o construtor recebe o ano, mês e dia, contudo esta forma precisa receber o mês menos um e foi exatamente o que fizemos. Para o mês 5, passamos o valor 4. Aliás, estamos passando valores que são Numbers, mas poderíamos ter passado esses valores como string que tudo continuaria funcionando do mesmo jeito.

Parta do princípio que você tem a seguinte variável:

let dataString = '17-05-2016';
E que usará o construtor de Date, que está preparado para receber uma data no formato ano/mes/dia.

Escreva um código que altere dataString para que seu conteúdo fique compatível com o formato ano/mes/dia. No final, instancie uma Date, exibindo no console seu valor.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Uma solução possível é a seguinte:

let dataString = '17-05-2016';

dataString = dataString.split('-').reverse().join('/');

let data = new Date(dataString);

console.log(data);
Ou podemos fazer de uma vez só:

let dataString = '17-05-2016';

let data = new Date(dataString.split('-').reverse().join('/'));
console.log(data);
A ideia é transformarmos nossa string em uma array, onde teremos três elementos com o dia, mês e ano respectivamente. Daí, usamos o método reverse do Array que inverte a sua ordem fazendo com que o ano seja o primeiro elemento e o dia o último. Nosso mês continuará na sua posição original. Por fim, criamos uma string a partir do array, usando o método join, que usará uma / para separar cada elemento.
*******************
16-Mais de spread
Para consolidar nosso conhecimento, observe este código:

let lista1 = ['banana', 'laranja', 'mamão'];
let lista2 = ['caju', 'tangerina', 'abacaxi'];

lista1.push(...lista2);
Teste se este código funciona no console.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Funciona! O método push de todo array aceita receber os dados que você deseja incluir separados por vírgula, ou seja, a função está preparada para receber N elementos. Quando passamos a lista2 para lista1.push com o spread operator, cada item da lista será passado como um parâmetro para lista.push:

let lista1 = ['banana', 'laranja', 'mamão'];
let lista2 = ['caju', 'tangerina', 'abacaxi'];

lista1.push(...lista2);

console.log(lista1);
//["banana", "laranja", "mamão", "caju", "tangerina", "abacaxi"]
*******************
17-O "mapa" da mina!
let numeros = [3,2,11,20,8,7];
Sua tarefa: criar uma nova lista com a mesma quantidade de números, mas cada elemento da nova lista deve ter seu valor dobrado quando for ímpar.

ATENÇÃO: a lista numeros não pode ser alterada! Você pode resolver do jeito que desejar, o mais importante é o resultado.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Tenho certeza que pode ter passado em sua cabeça zilhões de formas de resolver o problema passado, inclusive fica muito difícil para mim mapeá-las todas aqui. Porém, que tal usarmos uma maneira não funcional para resolver esse problema?

let numeros = [3,2,11,20,8,7];
let novosNumeros = [];

numeros.forEach(item => {

    if(item % 2  != 0) {
        novosNumeros.push(item * 2);
    } else {
        novosNumeros.push(item);
    }
});
console.log(novosNumeros);
Para sabermos se um número é par ou não, usamos item % 2, que retorna o resto da divisão por 2. Se for 0, é porque o número é par, se não for, é ímpar. Aliás, nem precisamos fazer item % 2 != 0, podemos simplesmente fazer item % 2. Se o resultado for 0, este número é considerado falso pelo JavaScript. Alterando nosso código:

let numeros = [3,2,11,20,8,7];
let novosNumeros = [];

numeros.forEach(item => {

    if(item % 2) { // só entra no IF se o resultado for diferente de zero
        novosNumeros.push(item * 2);
    } else {
        novosNumeros.push(item);
    }
});
console.log(novosNumeros);
Apesar de funcionar e termos usado o forEach, nossa solução não é uma solução funcional. Alterando nosso código e exaurindo o poder da programação funcional:

let numeros = [3,2,11,20,8,7];
let novosNumeros = numeros.map(item =>  item % 2 ? item * 2 : item);
console.log(novosNumeros);
Veja que usamos um if ternário para decidir se retornamos o item multiplicado por 2 ou o item em si. Um outro ponto importante é o seguinte: 0 é considerado falso em JavaScript e qualquer número diferente de 0 é considerado verdadeiro. Então, quando fazemos item % 2, se o resultado for 0, é porque o item é divisível por dois, ou seja, é par. Como 0 é falso, ele retornará o item sem qualquer modificação. Agora, se o resto da divisão de item % 2 for diferente de zero, é porque é impar. Como o resultado é diferente de zero, será verdadeiro e o que vem depois do interrogação será processado, no caso, item vezes dois.

Outra maneira de se conseguir o mesmo resultado, sem entretanto utilizar o operador ternário, é:

let numeros = [3,2,11,20,8,7];
let novosNumeros = numeros.map((item)=> (item%2 +1 ) * item);
console.log(novosNumeros);
Quando fazemos o módulo de dois um número par, o que sobra é 0, somando-se 1, e depois multiplicando pelo item, obtemos o mesmo item. Quando o número é impar, o modulo obtido é um, o qual incrementado dá 2.-
*******************
18- Ops, não encaixa. Podemos dar um jeitinho?
Temos a seguinte função:

function somaDoisNumeros(numero1, numero2) {
    return numero1 + numero2;                                            
}
É uma função simples, que retorna o somatório de dois números. Um exemplo:

console.log(somaDoisNumeros(10,30)); // exibe 40!
Muitas vezes não recebemos os dados em uma estrutura compatível com nossas funções. Vejamos um exemplo:

let numeros = [10, 30];
console.log(somaDoisNumeros(numeros[0], numeros[1]));
ES2015 trouxe uma novidade, o spread operator. Altere a passagem de parâmetros para somaDoisNumeros e faça uso do spread operator para receber um array, com isso, evitando a necessidade de usar numeros[0] e numeros[1].

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Usamos ... antes do array passado como parâmetro. Cada item do array será passado para cada parâmetro recebido pela função. Inclusive isso vale para o constructor de uma classe.

numeros = [10,30];
console.log(somaDoisNumeros(...numeros));

*******************
19-Menos é mais!
Temos as seguintes classes:

class Aluno {

    constructor(matricula, nome) {
        this.matricula = matricula;
        this.nome = nome;
    }
}

class Prova {

    constructor(aluno, nota) {
        this.aluno = aluno;
        this.nota = nota;
    }
}
Agora, vamos criar uma lista de avaliações. Cada item da lista é uma instância de Prova:

let avaliacoes = [
    new Prova(new Aluno(1, 'Luana'), 8),
    new Prova(new Aluno(2, 'Cássio'), 6),
    new Prova(new Aluno(3, 'Barney'), 9),
    new Prova(new Aluno(4, 'Bira'), 5)
];
Dessa lista, precisamos dos alunos que foram aprovados, ou seja, que possuam nota maior ou igual a 7. Contudo, não queremos uma lista de provas no final, apenas uma lista com os nomes:

let aprovados = avaliacoes
    .filter(function(prova) { return prova.nota >= 7; })
    .map(function(prova) { return prova.aluno.nome;});

console.log(aprovados);
Altere o código acima para fazer uso de arrow functions. Tente ser o mais sucinto possível, em outras palavras, tente escrever a menor quantidade de código.

VER OPINIÃO DO INSTRUTOR
Opinião do instrutor

Antes:

let aprovados = avaliacoes
    .filter(function(prova) { return prova.nota >= 7; })
    .map(function(prova) { return prova.aluno.nome;});
Depois:

let aprovados = avaliacoes
    .filter((prova) => prova.nota >= 7)
    .map((prova) => prova.aluno.nome);
Muito mais enxuto e apaixonante! :)

DICA!
Quando a arrow function possui apenas um parâmetro, podemos remover os parênteses. Vejamos como fica o código anterior:

let aprovados = avaliacoes
    .filter(prova => prova.nota >= 7)
    .map(prova => prova.aluno.nome);
Mais enxuto ainda!
*******************
20-
*******************
