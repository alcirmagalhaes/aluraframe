Aula03
01-A classe NegociacaoController
Começando deste ponto? Você pode fazer o download completo do projeto até aqui e continuar seus estudos.

Nós já temos a negociação criada, agora, precisamos capturar as ações do usuário e interagir com o modelo por meio de uma controller no modelo MVC. Nós criaremos instâncias de negociação. Primeiramente, precisamos criar o controller.

Atualmente, no index.html, só temos a importação do arquivo Negociacao.js:

<script src="js/app/models/Negociacao.js"></script>
Lembrando que não temos mais a outra tag <script> usada nos testes. Caso você ainda a tenha, deve apagá-la.

Em seguida, criaremos a classe NegociacaoController.js. Usamos a convenção usada anteriormente de começar o nome da classe em caixa alta. Quando clicarmos no botão "Incluir" do formulário, vamos submetê-lo e depois, chamaremos uma ação do controller para adicionar uma negociação na tabela. Por enquanto, focaremos na criação da Negociacao com base nas informações dos formulários.

Usaremos o método adiciona() na classe NegociacaoController. O método receberá como parâmetro um event.

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();
        alert('Chamei ação no controller');
  }
}
Chamamos o event.preventDefault(). Quando submetemos o formulário, se não cancelamos o comportamento padrão do mesmo, ele será recarregado. Com o event.preventDefault(), a controller cancelará a submissão do formulário para poder capturar os dados da negociação e incluir na lista. Ainda não colocamos constructor, porque a negociação ainda não tem nenhum atributo de classe.

Como faremos a ligação do método adiciona() com a submissão do formulário? Precisaremos fazer a importação do NegociacaoController.js. Também teremos uma tag <script> com a qual iremos instanciar esta controller.

<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script>
    let negociacaoController = new NegociacaoController();
</script>
Observe que fizemos declaração da variável negociacaoController com o let, conforme convencionamos. Agora, nossa controller já está acessível na página inteira.

Em seguida, dentro da tag <form>, adicionaremos onsubmit para submeter o formulário. E na instância de negociacaoController, chamaremos o método adiciona(event):

<body class="container">

    <h1 class="text-center">Negociações</h1>

        <form class="form" onsubmit="negociacaoController.adiciona(event)">
            <div class="form-group">
                <label for="data">Data</label>
                <input type="date" id="data" class="form-control" required autofocus/>
            </div>

  //...
A estratégia utilizada aqui é um pouco diferente do que vem sendo feita, geralmente, a associação entre tag e o evento é feita no parte JS do projeto. Mas inspirado por framework como o AngularJS, por exemplo, que faz a associação de uma ação da controller utilizando um evento. Usaremos isso, para escrever menos código na parte JavaScript. Como nossa página é dependente de JS, podemos fazer isso facilmente.

Se atualizarmos a página e preenchermos o formulário com dados aleatórios, após submetermos as informações, veremos a mensagem do alert.

ação no controller

Então, a ação da controller foi chamada. Mas o nosso objetivo não é exibir a mensagem, nós queremos criar um negociação. Teremos que gerar o código que instância a negociação. Faremos isto mais adiante.
*******************
02-Associando métodos do controller às ações do usuário
Ao clicarmos no botão "Incluir" do formulário, já conseguimos executar as ações da controller. Agora, precisamos capturar os dados preenchidos. Primeiramente, iremos exibi-los no Console. Para isto, criaremos a variável inputQuantidade.

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let inputData = document.querySelector('#data');
        let inputQuantidade =  document.querySelector('#quantidade');
        let inputValor = document.querySelector('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}
O document.querySelector() será o responsável por buscar no DOM os elementos com id #data, #quantidade e #valor - observe que conseguimos utilizar os seletores CSS. Os itens foram dispostos na ordem do formulário. Lembrando que cada input tem id no arquivo index.html.

Vamos executar o código para ver se todos os dados aparecem no Console do navegador. Preencheremos o formulário com a data 11/12/2016, a quantidade 1 e o valor 100.

dados do console

Os dados apareceram corretamente no Console, nós já conseguimos capturá-los. Mas veja que repetimos bastante o código, ficou uma sintaxe trabalhosa de ser digitada. Como em JavaScript temos as First Class Functions, podemos declarar a variável $ - como usado no jQuery - e dentro, jogaremos o document.querySelector. Poderemos fazer as seguintes substituições no código:

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let $ = document.querySelector;
        let inputData = $('#data');
        let inputQuantidade =  $('#quantidade');
        let inputValor = $('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}
Desta forma, ficou menos trabalhoso escrever o código. Mas se o executarmos como está, veremos uma mensagem de erro no navegador.

Não funcionou colocarmos o querySelector na variável $ para criarmos um alias. Por que não funcionou? O querySelector é uma função que pertence ao objeto document - chamaremos tal função de método. Internamente, o querySelector tem uma chamada para o this, que é o contexto pelo qual o método é chamado. Logo, o this é o document. No entanto, quando colocamos o querySelector dentro do $, ele passa a ser executado fora do contexto de document e isto não funciona. O que devemos fazer, então? Queremos tratar o querySelector como uma função separada. Nós queremos que ao colocarmos o querySelector para o $, ele mantenha a associação com o document. Para isto, usaremos o bind() :

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let $ = document.querySelector.bind(document);
        let inputData = $('#data');
        let inputQuantidade =  $('#quantidade');
        let inputValor = $('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}
Agora, estamos informando que o querySelector irá para a variável $, mas ainda manterá uma associação com document. Desta vez, o código funcionará corretamente no navegador. Vimos um truque que copia um pouco o que o jQuery faz de melhor e cria um "mini-framework", ao associarmos a variável $ com o querySelector - um seletor CSS - e mantendo a ligação com o document.

Até aqui, vimos como manipular os dados do DOM, além do truque citado para otimizar nosso código. Precisaremos ainda construir uma negociação com base nestes dados. Mas será que esta forma de organizar os dados é performática? Veremos isto mais adiante.
*******************
03-Evitando percorrer o DOM muitas vezes
O código funciona, mas se adicionarmos dez negociações e clicarmos dez vezes em "Incluir", o querySelector buscará a #data, #quantidade e #valor dez vezes também. No entanto, devemos evitar ao máximo percorrer o DOM. Sempre que executamos o querySelector, ele irá no DOM - que é uma árvore de elementos. O querySelector terá que buscar entre todos estes elementos. Porém, a API de DOM é um tanto "preguiçosa" e não gosta de executar essa ação.

Então, se adicionamos 100 negociações, teremos que fazer esta busca 100 vezes. Apesar de só estarmos trabalhando com três elementos no caso, queremos melhorar a nossa performance. Atualmente, nosso código está assim:

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let $ = document.querySelector.bind(document);
        let inputData = $('#data');
        let inputQuantidade =  $('#quantidade');
        let inputValor = $('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}
Para melhorar a performance, adicionaremos o constructor e moveremos os inputs para dentro dele. Mas em vez de criarmos uma variável, criaremos atributos de instâncias com o this.

class NegociacaoController {

  constructor() {

            let $ = document.querySelector.bind(document);

            this.inputData = $('#data');
            this.inputQuantidade =  $('#quantidade');
            this.inputValor = $('#valor');
  }

  adiciona(event) {
        event.preventDefault();


        console.log(this.inputData.value);
        console.log(this.inputQuantidade.value);
        console.log(this.inputValor.value);

  }
}
Quando o NegociacaoController for criado pela primeira vez, ele buscará os elementos do DOM do document, que serão guardados nas propriedades da classe. Adicionamos o this no console também.

Agora, mesmo que façamos 300 negociações, ele só fará uma busca no DOM pelos elementos. Com isto, conseguimos melhorar a performance. O impacto neste cenário é ínfimo, mas poderia ser maior em outros cenários. Se executarmos o código, veremos que será exibido corretamente no console.

Usaremos esta estratégia como se fosse um caching até o fim do curso.

dados no console
*******************
04-Criando uma instância de Negociacao
Nós iremos seguir a convenção de que os inputs só poderão ser acessados com NegociacaoController, não podendo ser acessados por fora da aplicação. Só os métodos de NegociacaoController poderão acessar esses atributos. Para isto, usaremos o prefixo _, convencionado anteriormente, que indicará para o programador .

class NegociacaoController {

  constructor() {

            let $ = document.querySelector.bind(document);

            this._inputData = $('#data');
            this._inputQuantidade =  $('#quantidade');
            this._inputValor = $('#valor');
  }

  adiciona(event) {
        event.preventDefault();


        console.log(this._inputData.value);
        console.log(this._inputQuantidade.value);
        console.log(this._inputValor.value);

  }
}
Continuamos seguindo a convenção. Agora, podemos criar a negociação com os dados do formulário, vamos então criar a variável negociacao e incluiremos os três parâmetros.

adiciona(event) {

    event.preventDefault();

    let negociacao = new Negociacao(
        this._inputData.value,
        this._inputQuantidade.value,
        this._inputValor.value
      );

      console.log(negociacao);

}
Passamos os parâmetros data, quantidade e valor para o construtor de Negociacao. Com os dados do formulário, nós já temos uma negociação. Queremos que a negociação seja adicionada em uma lista, mas não a iremos implementar ainda.

Vamos ver como ficou a página recarregada.

mensagem de erro console

Recebemos uma mensagem de erro, mas não foi em NegociacaoController. O erro ocorreu na classe Negociacao.js. No Console, vemos ainda em qual linha foi o problema. A falha nos avisou que data.getTime não é uma função. Como isso é possível?

class Negociacao {

    constructor(data, quantidade, valor) {

      this._data = new Date(data.getTime());
      this._quantidade = quantidade;
      this._valor = valor;
      Object.freeze(this);

    }
}
O que significa? A data que estamos passando para o construtor não é uma data? Para resolver isso, vamos descobrir qual é o tipo da data, usaremos a função typeof().

adiciona(event) {

    event.preventDefault();

    console.log(typeof(this._inputData.value));

    let negociacao = new Negociacao(
        this._inputData.value,
        this._inputQuantidade.value,
        this._inputValor.value
      );

      console.log(negociacao);

}
No Console, veremos que é uma string.

string

Isto significa que quando passamos a data para Negociacao, ela ainda é uma string e, obviamente, não teremos o getTime(). O que precisamos resolver antes? Precisamos encontrar uma maneira de converter a data - que está em texto - para um objeto Data. Priorizaremos isso, e cancelaremos a criação da negociação.

adiciona(event) {

    event.preventDefault();

    console.log(typeof(this._inputData.value));

    console.log(this._inputData.value);

}
Ao executarmos o código, veremos o seguinte código:

data string

Temos que ser capazes de transformar uma string em um objeto do tipo Date e depois passá-lo para negociação.

Mais adiante, faremos este processo de conversão.
*******************
05-Criando um objeto Date
Existem várias maneiras de construirmos uma data passando parâmetros para o construtor. Uma das formas que já vimos é que se já temos uma data, podemos colocar o retorno de getTime e passar para o construtor de Date. Será que podemos fazer este processo de forma direta? Se for possível, já resolvemos o nosso problema.

adiciona(event) {

  event.preventDefault();

  let data = new Date(this._inputData.value);
  console.log(data);
}
Se der certo o que fizemos, será retornada a string 2015-11-12. É o texto que o construtor está recebendo. Vamos fazer um teste:

data errada no console

A data que apareceu no Console não foi a mesma, em vez disso, vemos que o dia é 11. Então, não funcionou. Temos que encontrar outra maneira de trabalhar com essa data. Outra maneira de trabalhar com Date é utilizando um array, que terá o ano, mês, dia.

Se digitarmos no Console...

new Date(['2016', '11', '12']);
O retorno será a data correta:

new Date

Esta é uma forma de resolvermos. Precisamos ainda encontrar uma forma de transformar a data que é uma string, fique dentro do array. Como faremos com que a string saiba qual é o separador que ela deve considerar? Para isto, adicionaremos split('-'), e assim, a data será separada com hífens. Faremos um teste digitando no Console dataString.split('-'):

dataString.split('-')
["2015", "12", "11"]
Ele nos retornou a data correta. Então, executaremos o seguinte código:

adiciona(event) {

  event.preventDefault();

  let data = new Date(this._inputData.value.split('-'));
  console.log(data);
}
Resolvemos o problema da data.

console com a data correta

Por que conseguimos solucionar passando um array? Quando geramos o array com ano, mês e dia, ele transforma cada item em uma string e adiciona o separado. Só que quando passamos o array '2016', '11', '12', o que é o reagrupamento por debaixo dos panos de cada item usando o separador ,.

metodo join

Existe no array o método join(), que une todos os itens e depois, forma uma string com separadores.

string recebida

Temos a string que esperávamos receber. Mas, além de usar o split(), poderíamos utilizar o replace(). Adicionaremos uma expressão regular pedindo que seja trocado o hífen de todas as ocorrências da string (ou seja, global) por ,: replace(/-/g, ',').

adiciona(event) {

    event.preventDefault();

    let data = new Date(this._inputData.value.replace(/-/g, ','));
    console.log(data);
}
outra forma de fazer a data

A data ficou correta. Vimos que existem várias formas de resolver a questão da data, e o array nem precisa ser de string. Pode ser um array de número, que também será aceito.
*******************
06-Exercicio - Executando ações de um controller
Vejamos a declaração de uma controller:

// ContadorController.js

class ContadorController {

    constructor() {
        this._contador = 0;
        alert(this._contador);
    }

    get contador() {
        return this._contador;
    }

    incrementar() {
        this._contador++;
        alert(this._contador);
    }
}
Veja que o único dado que a controller possui é o contador, que começa a partir de 0. Quando o método incrementar for chamado, o valor do contador será incrementado e o valor atual será exibido na tela.

Qual das opções abaixo associa corretamente o botão <button> com o método incrementar de ContadorController?

Alternativa correta
<html>
  <head></head>
  <body>
    <button onclick="contadorController.incrementar">Incrementar</button>
    <script src="ContadorController.js"></script>
    <script>
        let contadorController = new ContadorController();
    </script>
  </body>
</html>

Alternativa correta
<html>
  <head></head>
  <body>
    <button onclick="contadorController.incrementar()">Incrementar</button>
    <script src="ContadorController.js"></script>
    <script>
        let contadorController = new ContadorController();
    </script>
  </body>
</html>
Alternativa correta
<html>
  <head></head>
  <body>
    <button click="contadorController.incrementar()">Incrementar</button>
    <script src="ContadorController.js"></script>
    <script>
        let contadorController = new ContadorController();
    </script>
  </body>
</html>

Alternativa correta
<html>
  <head></head>
  <body>
    <button onclick="contadorController.incrementar()">Incrementar</button>
    <script src="ContadorController.js"></script>
    <script>
        let contadorController =  ContadorController();
    </script>
  </body>
</html>
*******************
07-O problema com datas
Vimos como lidar com a convenção das datas para criar um objeto Date, mas veremos mais uma forma de realizar tal ação. Escreveremos no Console a seguinte linha:

let data = new Date(2016, 11, 12)
No entanto, se imprimirmos esta data, veremos o retorno abaixo:

Console

A data impressa é Mon Dec 12 2016. Por que ele imprimiu dezembro, se escrevemos mês 11? Porque nesta forma de se passar o Date, o mês deve ser passado de 0 a 11. Então, se queremos que a data seja em novembro, precisaremos diminuir o valor do mês. Vamos fazer um novo teste no Console, digitando:

data = new Date(2016,10,12)
Agora, a data já aparece correta.

Data correta

A novidade é que essa é a maneira que queremos usar para aplicar as datas na aplicação. Apesar da outra forma ser mais fácil, desejamos encontrar uma solução para construir um Date a partir da string vinda do formulário. Ao tentarmos resolver este problema, podemos ver muitos assuntos de programação funcional.

Então, eu peço que você dê uma pausa no vídeo e pense como você vai conseguir converter uma data no formato 2016-11-12 e passá-la para o construtor de Date da seguinte forma:

new Date(2016, 10, 12)
Pense um pouco a respeito e veremos mais adiante como eu vou resolver o assunto.
*******************
08-
*******************
01-
*******************
10-
*******************
10-
*******************
10-
*******************
10-
*******************
10-
*******************
10-
*******************
10-
*******************
10-
*******************
10-
*******************
10-
*******************
20-
*******************
