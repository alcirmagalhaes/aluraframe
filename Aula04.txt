01-Exibindo o objeto Date no formato dia/mês/ano
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui e continuar seus estudos.

Conseguimos capturar as entradas dos usuários, e quando este clica no botão "Incluir" e submete o formulário, a controller instancia uma negociação já com a data convertida. Então, estamos preparados para incluir as negociações na tabela do navegador. Porém, antes, vamos resolver um assunto: a exibição da data. Atualmente, temos a opção de adicionar no negociacao.data dentro do console, na classe NegociacaoController:

let negociacao = new Negociacao(
    data,
    this._inputQuantidade.value,
    this._inputValor.value
  );

  console.log(negociacao.data);
Na página do navegador, preencheremos o campo data com 12/11/2016 e veremos a data exibida na Console da seguinte forma:

Sat Nov 12 2016 00:00:00 GMT-0200 (BRST)
Temos que encontrar uma maneira de formatarmos a data para: dia/mês/ano. Para isto, criaremos a variável diaMesAno.

let diaMesAno = negociacao.data.getDate()
+ '/' + negociacao.data.getMonth()
+ '/' + negociacao.data.getFullYear();
console.log(diaMesAno);
Com o getDate() retornaremos o dia e depois, com o getMonth(), retornaremos o mês e com getFullYear(), o ano. Todos foram concatenados com a data. Observe que utilizamos o Full no ano, para que apareçam todos os dígitos do ano (nós queremos evitar o bug do milênio).

No entanto, a data que aparecerá no Console ainda não será a correta.

data errada no console

No Console, vemos o mês 10, isso acontece porque ele veio de um array que vai de 0 a 11. Então, se a data gravada for no mês 11, ele será impresso no mês 10. No entanto, não solucionaremos somando +1 ao valor no array.

let diaMesAno = negociacao.data.getDate()
    + '/' + negociacao.data.getMonth() + 1
    + '/' + negociacao.data.getFullYear();

console.log(diaMesAno);
data esquisita

Não existe mês 101! O JavaScript concatenou o dia com a / e resultado disso com o Month. No fim, isso virou uma string e ele então, concatenou com +1. Esta operação deve ocorrer primeiro antes da concatenação, por isso, adicionaremos os () (parentêses).

let diaMesAno = negociacao.data.getDate()
    + '/' + (negociacao.data.getMonth() + 1)
    + '/' + negociacao.data.getFullYear();

console.log(diaMesAno);
Básico de JavaScript. Agora, vamos executar o código e a data será impressa corretamente.
*******************
02-Isolando a responsabilidade de conversão de datas
Ao observarmos o código descobrimos que ele possui poucas linhas. Para criarmos uma data, o código deverá ser executado sempre que adicionarmos e imprimirmos uma data.


let data = new Date(...
    this._inputData.value
    .split('-')
    .map((item, indice) => item - indice % 2)
);

let negociacao = new Negociacao(
    data,
    this._inputQuantidade.value,
    this._inputValor.value
);

let diaMesAno = negociacao.data.getDate()
    + '/' + (negociacao.data.getMonth() + 1)
    + '/' + negociacao.data.getFullYear();

console.log(diaMesAno);
O nosso objetivo será isolar a responsabilidade de instanciar uma data e exibir a data num formato já conhecido numa classe. Esta será uma classe ajudante que chamaremos de helper e terá a responsabilidade isolada de lidar com a data.

Agora, dentro das pasta Helpers, criarei o arquivo DateHelper.js. Dentro da classe, teremos dois métodos: o primeiro método será textoParaData(), que receberá um texto e o converterá para data. O segundo será o dataParaTexto, que receberá uma data e a converterá em texto.

class DateHelper {

    textoParaData(texto) {

    }

    dataParaTexto(data) {

    }
}
Aproveitaremos o código que faz a conversão no NegociacaoController e adicionaremos nos métodos:

class DateHelper {

    textoParaData(texto) {

        return new Date(...texto.split('-').map((item,indice) => item - indice % 2));

    }

    dataParaTexto(data) {

        return data.getDate()
            + '/' + (data.getMonth() + 1)
            + '/' + data.getFullYear();
    }
  }
Fizemos alguns pequenos ajustes, por último, inverteremos a ordem dos métodos para que eles sigam a ordem usada anteriormente.

class DateHelper {

    dataParaTexto(data) {

        return data.getDate()
            + '/' + (data.getMonth() + 1)
            + '/' + data.getFullYear();
      }

    textoParaData(texto) {

        return new Date(...texto.split('-').map((item,indice) => item - indice % 2));

    }
}
Em seguida, carregaremos este script no index.html.

<!-- ... -->
 <script src="js/app/models/Negociacao.js"></script>
 <script src="js/app/controllers/NegociacaoController.js"></script>
 <script src="js/app/helpers/DateHelper.js"></script>
 <script>
     let negociacaoController = new NegociacaoController();
 </script>   
</body>
</html>
Faremos alterações também no NegociacoesController.js, apagaremos as variáveis data e diaMesAno geradas anteriormente e vamos criar uma nova data:

adiciona(event) {

        event.preventDefault();

        let data = new DateHelper().textoParaData(this._inputData.value);

        let negociacao = new Negociacao(
                data,
                this._inputQuantidade.value,
                this._inputValor.value
            );


        console.log(negociacao);

        console.log(diaMesAno);
    }
}
Observe que adicionamos o DateHelper dentro do data. Agora, queremos que a data da negociação seja exibida no formato diaMesAno, separada com barras /. Em vez de usarmos o new no DateHelper, vamos adicionar a variável helper. Em data, adicionaremos a helper que dará o texto para data

adiciona(event) {

        event.preventDefault();

        let helper = new DateHelper();
        let data = helper.textoParaData(this._inputData.value);

        let negociacao = new Negociacao(
                data,
                this._inputQuantidade.value,
                this._inputValor.value
            );


        console.log(negociacao);

        console.log(helper.dataParaTexto(negociacao.data));
    }
}
Agora, isolamos a responsabilidade das conversões de data para classe Helper. Se executarmos o código, será criada a data correta:

negociacao na controller

A data também é impressa corretamente no formato texto. A classe Helper cumpriu bem o seu trabalho.

Em seguida, faremos um novo ajuste. Em vez de utilizarmos a variável data, moveremos a seguinte linha para a negociacao:

helper.textoParaData(this._inputData.value)
Com a alteração, o código ficará assim:

adiciona(event) {

    event.preventDefault();

    let helper = new DateHelper();

    let negociacao = new Negociacao(
        helper.textoParaData(this._inputData.value),
        this._inputQuantidade.value,
        this._inputValor.value
    );
}
Não precisamos mais da variável data, usaremos diretamente o seu retorno.

Vamos testar o código no navegador, e veremos que a data 12/11/2019 aparecerá no Console.

data no console funcionando

Nós conseguimos isolar o código dentro do Helper. Mas será que ainda podemos melhorá-lo ainda mais? Sempre que falo isso, vocês sabem que é possível. Veremos como, mais adiante.
*******************
03-Métodos estáticos
Precisamos usar uma instância para invocar os métodos, quando queremos usar o DateHelper. Mas será que este possui alguma propriedade? Não. Nós configuramos um construtor diferente do padrão para o DateHelper? Não. Vale ressaltar que se não definimos um constructor, por padrão, é como se existisse vazio.

class DateHelper {

  constructor() {}

  dataParaTexto(data) {

      return data.getDate()
          + '/' + (data.getMonth() + 1)
          + '/' + data.getFullYear();

}

textoParaData(texto) {

  return new Date(...texto.split('-').map((item,indice) => item - indice % 2));

}
Como não definimos o constructor, não colocaremos propriedades na classe. Outra opção seria adicionar a variável helper2:

adiciona(event) {

    event.preventDefault();

    let helper = new DateHelper();
    let helper2 = new DateHelper();

    let negociacao = new Negociacao(
        helper.textoParaData(this._inputData.value),
        this._inputQuantidade.value,
        this._inputValor.value
    );

    console.log(negociacao);
    console.log(helper.dataParaTexto(negociacao.data));

}    
Ou seja, adicionaríamos uma instância em todos os lugares que precisasse do helper. Isto tem um impacto no uso da memória, apesar de insignificante no nosso caso. Uma melhor decisão é acessar diretamente o método da classe.

adiciona(event) {

    event.preventDefault();

    let helper = new DateHelper();
    let helper2 = new DateHelper();

//...
Nós substituímos a instância helper por DateHelper.

adiciona(event) {

    event.preventDefault();

    let helper = new DateHelper();
    let helper2 = new DateHelper();

    let negociacao = new Negociacao(
        DateHelper.textoParaData(this._inputData.value),
        this._inputQuantidade.value,
        this._inputValor.value
    );

    console.log(negociacao);
    console.log(DateHelper.dataParaTexto(negociacao.data));
}
Nós não queremos que o método seja uma instância do DateHelper, queremos poder invocá-lo diretamente da definição da classe. Para isto, no arquivo DateHelper.js, adicionaremos o static aos métodos:

class DateHelper {

  static dataParaTexto(data) {

      return data.getDate()
          + '/' + (data.getMonth() + 1)
          + '/' + data.getFullYear();

}

  static textoParaData(texto) {

      return new Date(...texto.split('-').map((item,indice) => item - indice % 2));
    }
Agora, os métodos serão invocamos diretamente da classe e o NegociacaoController ficou um pouco mais enxuto. Vamos testar submeter os dados no formulário:

!Negociacao no console

Vimos uma novidade em termos de orientação para objeto: a classe DateHelper tem métodos estáticos, o que torna desnecessário a criação de uma instância.

Em seguida, vamos definir um constructor(), depois, adicionaremos a função throw new Error(). Várias funções do JavaScript não foram migradas para classe e são construtoras.

class DateHelper {

    constructor() {

        throw new Error('DateHelper não pode ser instanciada');

//...
No Console, digitaremos :

x = new DateHelper ()
Veremos o seguinte retorno.

mensagem de erro

Ao ver esta mensagem, o programador saberá que trabalhamos com métodos estáticos. Se clicarmos no erro, veremos qual é a classe e onde está o problema. Faremos um pequeno ajuste na mensagem que aparecerá, deixando-a mais genérica:

class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instanciada');
    }
//...
esta classe não pode ser instanciada

Mais adiante, vamos melhorar ainda mais a classe.
*******************
04-Template Strings
Vamos voltar ao arquivo DateHelper.js e analisar o método dataParaTexto. Neste, faremos a concatenação de strings:

class DateHelper {

    dataParaTexto(data) {

        return data.getDate()
            + '/' + (data.getMonth() + 1)
            + '/' + data.getFullYear();
      }
...
Adicionamos os parênteses para trabalharmos corretamente com o elemento mês. Nós temos a opção de utilizar um recurso das versões posteriores ao ES2015: template string. Vamos ver como ela funciona.

Primeiramente, digitaremos no Console:

let nome = 'Flávio'
undefined
let idade = 18
undefined
console.log('A idade de' + nome + ' é ' + idade + '.')
A idade de Flávio é 18.
undefined
Para usarmos o template string, adicionaremos a seguinte linha:

console.log(`A idade de nome é idade.`)
Observe que adicionamos o ` (backtick), mas se executarmos o código desta forma, será exibida a frase: A idade de nome é idade.. Ele não entendeu que o nome deve ser substituído pelo valor da variável. Mas se colocarmos nome dentro de uma expressão, conseguiremos o resultado esperado.

console.log(`A idade de ${nome} é ${idade}.`);
A idade de Flávio é 18.
Com o uso de ${} dentro da string, ele fará o mecanismo de interpolação. A expressão irá interpolar o conteúdo das variáveis nome e idade na string. Se entendemos corretamente esta estrutura, ela é menos sujeita a erro do que a anterior que continha várias concatenações. Se transpormos isto no DateHelper, podemos melhorar o código:

  return `${data.getDate()}/${data.getMonth()+1}/${data.getFullYear()}`;
Observe que somamos o mês com 1. O trecho do código ficou assim:

class DateHelper {

    dataParaTexto(data) {

        return `${data.getDate()}/${data.getMonth()+1}/${data.getFullYear()}`;
    }

    static textoParaData(texto) {

        return new Date(...texto.split('-').map((item,indice) => item - indice % 2));
      }
  }      
Desta vez, não foi necessário adicionar parênteses, porque cada expressão será avaliada individualmente para fazer a interpolação com a string. Outra vantagem do template string é que podemos apagar os sinais + entre as expressões e apenas, separar cada uma em linhas diferentes:

static dataParaTexto(data) {

    return `${data.getDate()}
        /${data.getMonth()+1}
        /${data.getFullYear()}`;
}
Mas manteremos o código como estava, apenas em uma linha. Feito isso, vamos testar o código no navegador.

negociacao no console corretamente

A data aparecerá corretamente. Este foi o nosso primeiro contato com o template string, veremos que este é um recurso poderoso do JavaScript. Você verá o que faremos com ele. Por enquanto, já não precisamos ficar concatenando um monte de coisa, porque ele faz a interpolação automaticamente.

Outro ação que realizaremos: pediremos para o DateHelper converter o texto com /. No console, digitaremos:

DateHelper.textoParaData(`11/12/2017`)
Ele retornará que a data é inválida, porque o texto para data deve receber o ano-mês-dia. Nós já vamos validar na variável textoParaData se passamos uma string no padrão estabelecido, exibindo uma mensagem caso o padrão não seja exibido. Faremos algo denominado fail-fast, assim que passar algo errado pelo método, falharemos rápido.

Vamos adicionar um expressão regular, que será sinalizada por barras (//):

static textoParaData(texto) {

    /\d{4}-\d{2}-\d{2}/.test(texto)
    return new Date(...texto.split('-').map((item, indice) => item - indice % 2));
}
Os valores 4, 2 e 2 sinalizam que os números terão tais quantidade de dígitos, respectivamente. Com test, pedimos que a expressão teste se o texto segue o padrão.

Você pode se aprofundar no assunto com o curso de Expressão Regular da Alura.

Queremos lançar um erro caso o texto não siga o padrão, por isso, adicionaremos um if. Caso siga, o retorno será verdadeiro. Em seguida, adicionaremos othrow new Error>

if(!/\d{4}-\d{2}-\d{2}/.test(texto))
    throw new Error('Deve estar no formato aaaa-mm-dd');
A linha com o throw new só será executada se o if for falso, por isso, usamos o sinal de !.. Se quisemos colocar mais uma instrução abaixo, teremos que lembrar de colocá-las em um bloco usando {} e assim, evitar problemas. Será que funcionará? Vamos fazer um teste no Console:

DateHelper.textoParaData('2017-11-12')
Sun Nov 12 2017 00:00:00 GMT-0200 (BRST)
A data exibida está correta. Depois, forçaremos o erro no Console para ver o que acontece.

DateHelper.textoParaData('2017/11/12')
Uncaught Error: Deve estar no formato aaaa-mm-dd(..)
Ele nos retornará uma mensagem de erro. O mesmo ocorrerá se digitarmos no campo ano, por exemplo, um número com a quantidade de dígitos maior ou menor que 4. Vemos que a expressão regular é usada justamente para encontrar padrões, podendo ser usadas no nosso código JavaScript. É a oportunidade de utilizarmos diferentes conhecimentos que vimos nos cursos da Alura.

Observe ainda que se inserirmos uma data com caracteres adicionais à esquerda ou à direita, o erro não será lançado. Por exemplo, se definirmos a data 30/09/20199, o ano será truncado para os primeiros dígitos. Se informarmos ao método a data 130/09/2019, o dia será truncado para os 2 últimos dígitos.

Para que a validação funcione corretamente, acrescente marcadores na expressão regular para indicar que queremos validar o texto exato, e nenhum caracter a mais:

if (!/^\d{4}-\d{2}-\d{2}$/.test(texto))
    throw new Error('Deve estar no formato aaaa-mm-dd');
*******************
05-Criando nosso ListModel
A negociação está pronta! Agora temos que adicionar as demais negociações cadastradas na lista - lembrando que uma vez adicionadas, estas não serão mais removidas e tampouco poderemos alterá-las.

Se optarmos por trabalhar com array de negociacoes, não temos esse tipo de controle e podemos fazer várias operações sobre o array. A solução é criar um modelo (model) que vai encapsular a regra de uma lista de negociações. Dentro da pasta models, criaremos o arquivo ListaNegociacoes.js. A nova classe criada terá como atributo uma lista de negociações que começará com 0:

class ListaNegociacoes {

    constructor() {
        this._negociacoes = []
    }

    adiciona(negociacao) {
        this._negociacoes.push(negociacao);
    }
}
Observe que usamos o prefixo _ para indicar que a lista não deve ser alterada. Se ninguém pode acessar as propriedades de negociação dentro da lista, adicionamos o método adiciona que receberá uma negociacao. Precisamos de um método que nos permita ler a lista de negociações para então, podermos exibi-la.

Em seguida, criaremos o getter de negociacoes. Ao instanciarmos uma lista de negociações, ela estará vazia. Por meio do método adiciona(), podemos adicionar negociações e com o método get poderemos listá-las.

adiciona(negociacao) {
    this._negociacoes.push(negociacao);
}

get negociacoes() {

    return this._negociacoes;
}
Depois, no index.html, temos que importar a nossa classe.

<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
De volta ao NegociacaoController, adicionaremos um atributo que chamarei _listaNegociacoes.

class NegociacaoController {

    constructor() {

        let $ = document.querySelector.bind(document);
        this._inputData = $('#data');
        this._inputQuantidade = $('#quantidade');
        this._inputValor = $('#valor');
        this._listaNegociacoes = new ListaNegociacoes();

    }
    //...
Temos um atributo da Controller. Assim que cadastramos uma nova negociação, é preciso também construir uma nova Negociacao com os dados do formulário. Para isto, adicionaremos um novo this ao método adiciona().

adiciona(event) {

        event.preventDefault();

        let negociacao =
            new Negociacao(
                DateHelper.textoParaData(this._inputData.value),
                this._inputQuantidade.value,
                this._inputValor.value
            );

        this._listaNegociacoes.adiciona(negociacao);
        console.log(this._listaNegociacoes.negociacoes);
Para testar se funciona, usamos o console.log() para exibir a lista de negociações. No navegador vamos preencher o formulário adicionando 12/11/2016 no campo Data, 1 em Quantidade e 100 no Valor. Veremos que os dados serão exibidos corretamente.

negociacao no console

Queremos adicionar os dados de uma nova negociação, mas o formulário ainda tem nos campos as informações preenchidas anteriormente. Vamos encontrar uma forma de limpar o formulário para que a ação não seja realizada pelos usuários. Podemos adicionar também o foco no campo data. Faremos tudo isso, adicionando abaixo do método adiciona(), o _limpaFormulario, que só poderá ser chamado pela própria classe NegociacaoController.

_limpaFormulario() {
        this._inputData.value = '';
        this._inputQuantidade.value = 1;
        this._inputValor.value = 0.0

        this._inputData.focus();

    }
Assim que acabarmos de fazer a negociação, chamaremos o this._limpaFormulario():

adiciona(event) {

    event.preventDefault();

    let negociacao = new Negociacao{
        DateHelper.textoParaData(this._inputData.value),
        this._inputQuantidade.value,
        this._inputValor.value
    };

    this._listaNegociacoes.adiciona(negociacao);
    this._limpaFormulario();

    console.log(this._listaNegociacoes.negociacoes);
}
Não podemos nos esquecer de importar o script em index.html. No lugar de importá-lo como último script, vamos agrupá-lo com a importação de Negociacao.js; sendo assim, tudo o que for model será importado um após o outro. Só estamos imprimindo, por enquanto, porque ainda não estamos exibindo a negociação na tela. Vamos testar novamente e preencher os dados do formulário.

Após preenchermos uma primeira vez todos os campos e enviarmos os dados, o formulário ficará vazio. Mas o dados da negociação foram salvos. O mesmo ocorrerá quando preenchermos pela segunda vez os dados do formulário.

exibições do array

Temos duas negociações dentro do array, cada uma com a sua devida configuração. Já estamos conseguindo adicionar elementos à lista. Mas podemos melhorar ainda o código. Nós criamos a negociações dentro do método adiciona(). Logo abaixo, criaremos outro método auxiliar que se chama _criaNegociacao. Neste, aproveitaremos o return do adiciona(). Agora o novo método será responsável por criar Negociacao:

_criaNegociacao() {

  return new Negociacao(
        DateHelper.textoParaData(this._inputData.value),
        this._inputQuantidade.value,
        this._inputValor.value
    );
//...
Removeremos a variável negociacao do adiciona() e em vez de passarmos negociacao no this., passaremos o this._criaNegociacao:

adiciona(event) {

    event.preventDefault();

    this._listaNegociacoes.adiciona(this._criaNegociacao());
    this._limpaFormulario();

    console.log(this._listaNegociacoes.negociacoes);
}   
Até aqui, os três métodos estão assim:

adiciona(event) {

    event.preventDefault();

    this._listaNegociacoes.adiciona(this._criaNegociacao());
    this._limpaFormulario();

    console.log(this._listaNegociacoes.negociacoes);
}   

_criaNegociacao() {
    return new Negociacao(
        DateHelper.textoParaData(this._inputData.value),
        this._inputQuantidade.value,
        this._inputValor.value);
  }

_limpaFormulario() {
    this._inputData.value = '';
    this._inputQuantidade.value = 1;
    this._inputValor.value = 0.0

    this._inputData.focus();

            }
Testaremos o formulário para conferir se não quebramos nada.

4.5_negociacao funciona

Tudo está funcionando corretamente. Então, criamos dois métodos auxiliares da controller que não devem ser chamados por fora da classe. A convenção é que apenas a classe pode chamar propriedades e métodos sinalizados com _.

Mas será que a classe, o modelo de negociações, é imutável? Será que podemos interagir com a lista de negociação? Será que podemos alterar sem passar pelo adiciona()? Vamos fazer um teste para descobrir.
*******************
06-Blindando as negociações dentro da lista
Colocamos em cheque a questão da imutabilidade da lista de negociações. A classe ListaNegociacoes será a única que poderá ter acesso a esta. A seguir, vamos incluir a seguinte linha no adiciona() do NegociacaoController, :

this._listaNegociacoes.negociacoes.length = 0;
Com isso, o trecho ficou assim:

adiciona(event) {

    event.preventDefault();

    this._listaNegociacoes.adiciona(this._criaNegociacao());
    this._limpaFormulario();

    this._listaNegociacoes.negociacoes.length = 0;
    console.log(this._listaNegociacoes.negociacoes);
}
Ao definirmos que o length é igual a 0, estamos esvaziando o array. Quando imprimimos no Console, devemos ver quantas negociacoes são exibidas. Se conseguimos esvaziar o array, ou seja, se alteramos a lista, isto significa que as negociações não foram blindadas:

array vazio

Você pode perguntar "mas não colocamos em getter?". A resposta é: sim, mas negociacoes é um array. Trata-se de uma referência. Quando usamos o length, alteramos a propriedade do objeto... Da mesma forma, não temos uma única forma de adicionar uma negociação. Não usamos apenas o método adiciona(). Por exemplo, podemos usar o negociacoes.push():

adiciona(event) {

    event.preventDefault();

    this._listaNegociacoes.adiciona(this._criaNegociacao());
    this._listaNegociacoes.negociacoes.push(this._criaNegociacao());
    this._limpaFormulario();
    console.log(this._listaNegociacoes.negociacoes);
}
O método adiciona() deveria ser o único caminho para adicionarmos uma negociação, mas se executarmos o código, veremos que conseguimos salvar duas negociações. Se preenchermos o formulário uma vez, veremos que temos duas Negociacao. Alguém conseguiu adicionar fora do método adiciona(). Resolveremos o problema com programação defensiva. Quando alguém pedir uma lista de negociações, devolveremos uma nova lista - uma cópia da que tenho dentro da ListaNegociacoes. Mesmo que adicionarmos o length = 0 ou inserir um elemento, como a lista está separada, não será possível adicionar outra negociação.

Em ListaNegociacoes.js, usaremos um truque: daremos um return com array vazio, seguido pelo método concat():

get negociacoes() {

    return [].concat(this._negociacoes);
  }
Ao passarmos o this._negociacoes dentro do concat(), o retorno será uma nova lista, um novo array. Agora se tentarmos usar o push() do NegociacaoController, só conseguiremos fazer a alteração na cópia da lista, mas não na original. Se fizermos um teste no formulário e preenchermos os campos uma vez, só deverá ter uma negociação.

array blindado

Só é exibida uma Negociacao. O push() só funcionou na cópia da lista. Podemos fazer pequenos ajustes no método adiciona, que ficará assim:

adiciona(event) {

    event.preventDefault();
    this._listaNegociacoes.adiciona(this._criaNegociacao());
    this._limpaFormulario();
}
Conseguimos incluir negociações dentro da lista que só pode ser alterada por intermédio do método adiciona().
*******************
07-Resumindo
Vamos revisar o que foi visto até aqui. Vimos que quando trabalhamos com data, precisamos transformar o formato da string para um objeto Data, com dia-mês-ano. É importante evitar a repetição do código sempre que for preciso usar a data no sistema, para isto, isolamos o trecho referente às conversões numa classe: o DateHelper. Em vez de usarmos concatenações nesta, optamos por usar uma template string que é criada com um ` (backtick, em inglês). Quando usamos a crase no início e no fim, podemos colocar expressões dentro da template string, sem precisar das concatenações. Mais adiante, nos aprofundaremos no assunto.

Como a Negociacao está pronta, começamos a preparar a listagem de negociações para a exibição. Porém, nesta listagem não podemos incluir, remover ou alterar uma Negociacao - uma das regras de negócio. Então, nós criamos uma classe do modelo que recebeu o nome ListaNegociacoes. Depois, conseguimos adicionar e obter essas negociações, por meio do método adiciona() e do getter negociacoes. Porém, vimos que essa lista de negociações dentro do model não estava blindada. Qualquer um que chamasse o getter conseguiria apagar ou incluir a lista, por isso, lançamos mão da programação defensiva.

Caso o getter de ListaNegociacoes fosse chamado, o retorno seria um array original e independente de qualquer interferência de fora. Fizemos isto utilizando um array vazio, seguido da função concat(). Criamos também alguns métodos auxiliares "privados" na Controller, além de brincarmos um pouco com as expressões regulares para validarmos o texto passado para conversão de data.
*******************
08-Olhar aguçado para o paradigma da orientação a objetos
Temos o seguinte código que define uma função que sabe validar um código:


let codigo = 'GWZ-JJ-12';

function validaCodigo(codigo) {

    if(/\D{3}-\D{2}-\d{2}/.test(codigo)) {
          alert('Código válido!');
      } else {
          alert('Código inválido');
      }

}

validaCodigo('GWZ-JJ-12'); // válido
validaCodigo('1X1-JJ-12'); // inválido
Muita coisa acontecendo? Se você não é ninja em expressão regular, vamos desmembrar o código para facilitar sua leitura:


function validaCodigo(codigo) {

    // cria a expressão regular. Poderíamos ter usado 
    // a sintaxe new RegExp(/\D{3}-\D{2}-\d{2}/)
    // \D é qualquer coisa não dígito
    // \D{3} é qualquer coisa não dígito que forme um grupo de 3 caracteres
    // \d é qualquer dígito.
    let expressao = /\D{3}-\D{2}-\d{2}/; 

    // toda expressão regular possui o método test 
    // que recebe o alvo do teste, retornando true
    // se passou, e false se falhou
    if(expressao.test(codigo)) {
          alert('Código válido!');
      } else {
          alert('Código inválido');
      }

}

validaCodigo('GWZ-JJ-12'); // válido
validaCodigo('1X1-JJ-12'); // inválido
Essa solução é procedural. Veja que toda vez que criarmos um código precisaremos buscar em algum lugar do nosso sistema alguém que o valide. Temos uma separação entre dado e comportamento.

Refaça o código acima adotando o paradigma da orientação a objetos. Uma dica: tudo começa com a criação da classe Codigo. Não se preocupe, a ideia aqui é instigar algumas percepções em você sobre este paradigma.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Vou criar uma classe que representa um código e encapsular a regra de que o código deve ter determinado formato. Realizarei a validação no construtor da classe. Se o código for inválido, nenhum objeto será instanciado e o programador ainda receberá uma mensagem de erro o alertando do problema. Isto é, independente do lugar que eu tenha uma instância de Codigo todo código criado será validado!

class Codigo {

    constructor(texto) {

        if(!this._valida(texto)) throw new Error(`O texto ${texto} não é um código válido`);
        this._texto = texto;        
    }

    _valida(texto) {

        return /\D{3}-\D{2}-\d{2}/.test(texto);
    }

    get texto() {

        return this._texto;
    }
}

let codigo1 = new Codigo('GWZ-JJ-12'); // válido
console.log(codigo1.texto);
let codigo2 = new Codigo('1X1-JJ-12'); // inválido
console.log(codigo2.texto);
Onde quer que tenhamos um código, dado e comportamento caminham juntos, mesmo que esse comportamento/regra esteja no construtor. Aliás, o _valida está prefixado desta forma porque esse método só deve ser chamado pela própria classe.
*******************
09-O parâmetro não encaixa, e agora?
Um programador amigo do coração criou uma função genérica para imprimir todos os itens de qualquer lista no console:

function exibeNoConsole(lista) {
    lista.forEach(item => console.log(item));
}
Excelente, mas em nossa aplicação dentro de um contexto específico temos duas listas distintas que queremos imprimir no console. Sendo assim, precisamos chamar a função duas vezes.

let listaDeNomes1 = ['Flávio', 'Rogers', 'Júlia'];
exibeNoConsole(listaDeNomes1);
let listaDeNomes2 = ['Vieira', 'Fernanda', 'Gerson'];
exibeNoConsole(listaDeNomes2);
Para evitar de chamarmos a função duas vezes, uma vez para cada lista, podemos juntar uma lista na outra. Implemente o código que cria uma nova lista que é a junção dos elementos de listaDeNomes1 e listaDeNomes2.

VER OPINIÃO DO INSTRUTOR
Opinião do instrutor

Em uma abordagem procedural faríamos:

function exibeNoConsole(lista) {
    lista.forEach(item => console.log(item));
}
Excelente, mas em nossa aplicação dentro de um contexto específico temos duas listas distintas que queremos imprimir no console. Sendo assim, precisamos chamar a função duas vezes.

let listaDeNomes1 = ['Flávio', 'Rogers', 'Júlia'];
let listaDeNomes2 = ['Vieira', 'Fernanda', 'Gerson'];
let lista = [];

listaDeNomes1.forEach(item => lista.push(item));
listaDeNomes2.forEach(item => lista.push(item));

exibeNoConsole(lista);
Contudo, todo array em JavaScript possui o método concat. Alterando nosso código:

let listaDeNomes1 = ['Flávio', 'Rogers', 'Júlia'];
let listaDeNomes2 = ['Vieira', 'Fernanda', 'Gerson'];
let lista = listaDeNomes1.concat(listaDeNomes2);

exibeNoConsole(lista);
O resultado de concat é um novo array com todos os elementos de quem realizou o concat e quem foi passado para a função.

Se quisermos, podemos enxugar ainda mais nosso código:

let listaDeNomes1 = ['Flávio', 'Rogers', 'Júlia'];
let listaDeNomes2 = ['Vieira', 'Fernanda', 'Gerson'];
exibeNoConsole([].concat(listaDeNomes1, listaDeNomes2));
Veja que não criamos mais a variável temporária lista. Estamos passando o resultado da concatenação de um array vazio [] com outras duas listas. Aliás, a função concat aceita receber um número infinito de parâmetros, inclusive aqueles que não são um array. Vejamos um exemplo:

let listaDeNomes1 = ['Flávio', 'Rogers', 'Júlia'];
let listaDeNomes2 = ['Vieira', 'Fernanda', 'Gerson'];
exibeNoConsole([].concat(listaDeNomes1, listaDeNomes2, 'Rômulo'));
Com isso, a lista criada terá também um item de valor Rômulo.
*******************
10-Exercicio - Template String
Qual a maneira correta de se utilizar a Template String?

Alternativa correta
let nome = 'Juca';
let sobrenome = 'Monteiro';

let frase = `${nome} ${sobrenome} também sabe JavaScript`;

Correta!

Alternativa correta
let nome = 'Juca';
let sobrenome = 'Monteiro';

let frase = '${nome} ${sobrenome} também sabe JavaScript.';

Alternativa correta
let nome = 'Juca';
let sobrenome = 'Monteiro';

let frase = `#{nome} #{sobrenome} também sabe JavaScript.`;
*******************
11-Exercicio - E a lista de negociações?
O que podemos dizer sobre a propriedade negociacoes da classe ListaNegociacoes?

class ListaNegociacoes {

    constructor() {
        this._negociacoes = [];
    }

    adiciona(negociacao) {
        this._negociacoes.push(negociacao);
    }

    get negociacoes() {
        return this._negociacoes;
    }
}
Alternativa correta
É impossível a alteração da lista interna da classe ListaNegociacao. Alguém mal intencionado, ao resgatar as negociações pela propriedade negociacoes não conseguirá realizar qualquer alteração. Isso porque toda propriedade, por padrão, devolve um objeto imutável.


Alternativa correta
É possível, através da propriedade negociacoes, pegar uma referência da lista interna, que guarda as negociações. Por conta disso, alguém mal intencionado pode fazer o que quiser com ela.

Alternativa correta
O nome da lista marca a propriedade como privada. Isso significa que ao tentar acessar a propriedade negociacoes um erro ocorrerá.
*******************
12-Criando o "ajudante"
Que tal um exemplo diferente do que foi apresentado no vídeo? Caso você queira implementá-lo, sugiro que você crie outro projeto para não interferir no código do projeto deste curso, combinado?

Temos a página upload.html, na qual o usuário insere os dados do arquivo que deseja fazer upload. É claro que é um formulário de mentirinha, até porque o processo de upload é mais complexo, mas a ideia aqui é exercitar seu conhecimento adquirido em JavaScript:

<!-- upload.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Upload de arquivo</title>
</head>
<body>
    <label>Informações do arquivo</label>
    <input class="dados-arquivo" placeholder="formato: nome/tamanho/tipo">

    <button onclick="arquivoController.envia()"  >Enviar</button>

    <script src="Arquivo.js"></script>
    <script src="ArquivoController.js"></script>
    <script>
        let arquivoController = new ArquivoController();
    </script>
</body>
</html>
Aprendemos a organizar nosso código no padrão MVC e por isso temos uma classe que é uma abstração de um arquivo. Suas propriedade são nome, tamanho, tipo:

class Arquivo {

    constructor(nome, tamanho, tipo) {
        this._nome = nome;
        this._tamanho = tamanho;
        this._tipo = tipo;
    }

    get nome() {
        return this._nome;
    }

    get tamanho() {
        return this._tamanho;    
    }

    get tipo() {
        return this._tipo;
    }
}
É claro, temos um controller que sabe instanciar um modelo da classe Arquivo com os dados do formulário, toda vez que o usuário clicar no botão "Enviar":

class ArquivoController {

    constructor() {
        this._inputDados = document.querySelector('.dados-arquivo');
    }

    envia() {
        //cria um Arquivo com as suas propriedades;
        this._limpaFormulario();
        // exibe mensagem no console com os dados do arquivo.
    }

    _limpaFormulario() {
        this._inputDados.value = '';
        this._inputDados.focus();
    }
}
Veja que o método envia, de ArquivoController, não está completo porque temos um problema. O problema é que o designer achou melhor ter apenas um campo onde o usuário digita na sequência o nome, o tamanho e o tipo do arquivo. Infelizmente o construtor de Arquivo não está preparado para receber a string com todos os dados, mas cada um em separado como parâmetro do construtor. E por fim, para complicar só mais um pouquinho, a entrada do usuário deve ser toda considerada em caixa alta, ou seja, maiúsculo.

Sua tarefa é implementar o método envia de ArquivoController. Ele deverá ler a entrada do usuário e adequá-la ao construtor de Arquivo. Assim que você conseguir criar uma instância de arquivo, você deve imprimir seus dados no console.

Lembre-se que o usuário digita no campo de entrada os dados do arquivo no formato: nome / tamanho / tipo e deve estar em caixa alta!

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Vejamos uma implementação do método envia:

envia() {
    let dados = this._inputDados.value.split('/').map(item => item.toUpperCase());
    let arquivo = new Arquivo(...dados); // usando spread operator
    console.log(`Dados do arquivo: ${arquivo.nome}, ${arquivo.tamanho}, ${arquivo.tipo}`);
    this._limpaFormulario();
}
Primeiramente, resolvemos o problema do input! A string com todos os dados do arquivo será desmembrada através da função split, que nos devolve um array com cada informação. Depois, a função map cria um novo array, colocando cada informação em caixa alta. No entanto, não podemos passar esse array diretamente para o construtor de Arquivo, pois ele não está preparado para receber um array, mas três parâmetros. Como esses parâmetros equivalem a cada informação no array que criamos a partir da string, passamos o array como parâmetro para o construtor de Arquivo usando o spread operator. Por fim, abusamos salutarmente de template string para exibir as informações do arquivo no console.

Usamos a função map, mas nem era necessário. Que tal converter primeiro para maiúscula antes de realizar o split?

envia() {
    let dados = this._inputDados.value.toUpperCase().split('/');
    let arquivo = new Arquivo(...dados); // usando spread operador
    console.log(`Dados do arquivo: ${arquivo.nome}, ${arquivo.tamanho}, ${arquivo.tipo}`);
    this._limpaFormulario();
}
Não é porque map é poderoso que forçaremos seu uso, certo?

Se o tratamento da entrada dos dados do arquivo é feito em outros lugares do sistema, podemos isolar essa responsabilidade em uma classe que pode nos ajudar sempre com essa tarefa, um helper:

class ArquivoHelper {

    static cria(informacao) {
        return new Arquivo(...informacao.toUpperCase().split('/'));
    }
}
Não podemos esquecer de importar o script do nosso helper, certo?

Por fim, alterando nosso método.

//ArquivoController.js

envia() {
    let arquivo = ArquivoHelper.cria(this._inputDados.value);
    console.log(`Dados do arquivo: ${arquivo.nome}, ${arquivo.tamanho}, ${arquivo.tipo}`);
    this._limpaFormulario();
}
A prática leva à perfeição :)
*******************
13-Por que...
Temos a seguinte classe:

class ConversorXML {

    static converte(objeto) {
        // converte um objeto em XML
    }
}
Agora, vamos criar uma instância desta classe e chamar o método converte:

let conversor = new ConversorXML();
conversor.converte({nome: 'Guaraci', idade: 40});
Teste este código no console.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Este código não funciona porque o método converte é estático e não será encontrado na instância de uma classe, mas diretamente na classe. Alterando o código para ser válido:

ConversorXML.converte({nome: 'Guaraci', idade: 40});
Métodos estáticos antes do ES6
Curiosidade: como criávamos métodos estáticos antes do ES6? Vejamos um exemplo, com a classe Pessoa:

Vejamos um exemplo do ES6 para declarar uma classe com métodos de instância e métodos estáticos:

class Pessoa {

    constructor(nome, sobrenome) {
        this.nome = nome;
        this.sobrenome = sobrenome;
    }

    obterNomeCompleto() {
        return `${this.nome} ${this.sobrenome}`;
    }

    static metodoStaticoQualquer() {
        console.log('Método estático chamado');
    }

}
E antes do ES6. Como implementávamos algo semelhante a métodos estáticos? Vejamos um exemplo:

function Pessoa(nome, sobrenome) {
    this.nome = nome;
    this.sobrenome = sobrenome;
}

// método de instância
Pessoa.prototype.obterNomeCompleto = function() {
    return this.nome + ' ' + this.sobrenome;
};

// declarando equivalente a método estático

Pessoa.metodoStaticoQualquer = function() {

    console.log('Método estático chamado');

};
*******************
14-Expressão regular ainda melhor
Durante o treinamento utilizamos a seguinte expressão regular para validar se uma data digitada pelo usuário é válida ou não:

/\d{4}-\d{2}-\d{2}/
Contudo, ela não garante que a data será sempre correta, pois se o usuário digitar um ano com mais de 4 dígitos ou um dia com mais de dois dígitos ela considerará como correta.

Para ficar ainda melhor, vamos alterar a expressão para

/^\d{4}-\d{2}-\d{2}$/
O ˆ indica "começando com " e o $ "terminando com".

Temos um curso de expressão regular para que fiquemos ainda melhor no assunto!

Sucesso e bom estudo meus alunos.

VER OPINIÃO DO INSTRUTOR
Opinião do instrutor

Nunca é tarde para revermos o que pode ficar ainda melhor!
*******************
15-Consolidando seu conhecimento
Chegou a hora do exercício do capítulo. Para fazê-lo, é importante que você tenha feito o último exercício do capítulo anterior ou tenha baixado o stage com o código completo do capítulo anterior no texto explicativo deste capítulo. Pronto para a linhas gerais do que deve ser feito? Vamos lá!

1 - No lugar de deixarmos espalhado pelo nosso sistema a lógica que converte um texto para a data e uma objeto data para texto vamos criar uma classe com essa responsabilidade. Dessa forma, toda vez que precisarmos lidar com a data pediremos para esta classe. Crie o arquivo aluraframe/client/js/app/helpers/DateHelper.js e defina a classe DateHelper com os métodos textoParaData e dataParaTexto (envolve o uso de template string). Uma exigência é que ambos sejam estáticos e que haja uma validação no construtor e nos métodos. Ainda lembra como criamos métodos estáticos?

2 - Não esqueça de importar o script da classe em index.html e alterar NegociacaoController para utilizá-la.

3 - Crie o arquivo aluraframe/client/js/app/models/ListaNegociacoes.js e defina a classe ListaNegociacoes com os métodos adiciona e getter negociacoes, não se esqueça de usar programação defensiva no getter. Importe o script em index.html.

4 - Agora, em NegociacaoController, adicione uma propriedade que é uma instância de ListaNegociacoes. Crie um método privado chamado criaNegociacao, que isolará aquela parte do código que cria a negociação. Adicione cada nova negociação à lista de negociações.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

O gabarito deste exercício é o passo a passo demonstrado no vídeo. Tenha certeza de que tudo está certo antes de continuar. Ficou com dúvida? Recorra ao nosso fórum, não perca tempo! :)
*******************
16-
*******************
