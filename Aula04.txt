01-Exibindo o objeto Date no formato dia/mês/ano
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui e continuar seus estudos.

Conseguimos capturar as entradas dos usuários, e quando este clica no botão "Incluir" e submete o formulário, a controller instancia uma negociação já com a data convertida. Então, estamos preparados para incluir as negociações na tabela do navegador. Porém, antes, vamos resolver um assunto: a exibição da data. Atualmente, temos a opção de adicionar no negociacao.data dentro do console, na classe NegociacaoController:

let negociacao = new Negociacao(
    data,
    this._inputQuantidade.value,
    this._inputValor.value
  );

  console.log(negociacao.data);
Na página do navegador, preencheremos o campo data com 12/11/2016 e veremos a data exibida na Console da seguinte forma:

Sat Nov 12 2016 00:00:00 GMT-0200 (BRST)
Temos que encontrar uma maneira de formatarmos a data para: dia/mês/ano. Para isto, criaremos a variável diaMesAno.

let diaMesAno = negociacao.data.getDate()
+ '/' + negociacao.data.getMonth()
+ '/' + negociacao.data.getFullYear();
console.log(diaMesAno);
Com o getDate() retornaremos o dia e depois, com o getMonth(), retornaremos o mês e com getFullYear(), o ano. Todos foram concatenados com a data. Observe que utilizamos o Full no ano, para que apareçam todos os dígitos do ano (nós queremos evitar o bug do milênio).

No entanto, a data que aparecerá no Console ainda não será a correta.

data errada no console

No Console, vemos o mês 10, isso acontece porque ele veio de um array que vai de 0 a 11. Então, se a data gravada for no mês 11, ele será impresso no mês 10. No entanto, não solucionaremos somando +1 ao valor no array.

let diaMesAno = negociacao.data.getDate()
    + '/' + negociacao.data.getMonth() + 1
    + '/' + negociacao.data.getFullYear();

console.log(diaMesAno);
data esquisita

Não existe mês 101! O JavaScript concatenou o dia com a / e resultado disso com o Month. No fim, isso virou uma string e ele então, concatenou com +1. Esta operação deve ocorrer primeiro antes da concatenação, por isso, adicionaremos os () (parentêses).

let diaMesAno = negociacao.data.getDate()
    + '/' + (negociacao.data.getMonth() + 1)
    + '/' + negociacao.data.getFullYear();

console.log(diaMesAno);
Básico de JavaScript. Agora, vamos executar o código e a data será impressa corretamente.
*******************
02-Isolando a responsabilidade de conversão de datas
Ao observarmos o código descobrimos que ele possui poucas linhas. Para criarmos uma data, o código deverá ser executado sempre que adicionarmos e imprimirmos uma data.


let data = new Date(...
    this._inputData.value
    .split('-')
    .map((item, indice) => item - indice % 2)
);

let negociacao = new Negociacao(
    data,
    this._inputQuantidade.value,
    this._inputValor.value
);

let diaMesAno = negociacao.data.getDate()
    + '/' + (negociacao.data.getMonth() + 1)
    + '/' + negociacao.data.getFullYear();

console.log(diaMesAno);
O nosso objetivo será isolar a responsabilidade de instanciar uma data e exibir a data num formato já conhecido numa classe. Esta será uma classe ajudante que chamaremos de helper e terá a responsabilidade isolada de lidar com a data.

Agora, dentro das pasta Helpers, criarei o arquivo DateHelper.js. Dentro da classe, teremos dois métodos: o primeiro método será textoParaData(), que receberá um texto e o converterá para data. O segundo será o dataParaTexto, que receberá uma data e a converterá em texto.

class DateHelper {

    textoParaData(texto) {

    }

    dataParaTexto(data) {

    }
}
Aproveitaremos o código que faz a conversão no NegociacaoController e adicionaremos nos métodos:

class DateHelper {

    textoParaData(texto) {

        return new Date(...texto.split('-').map((item,indice) => item - indice % 2));

    }

    dataParaTexto(data) {

        return data.getDate()
            + '/' + (data.getMonth() + 1)
            + '/' + data.getFullYear();
    }
  }
Fizemos alguns pequenos ajustes, por último, inverteremos a ordem dos métodos para que eles sigam a ordem usada anteriormente.

class DateHelper {

    dataParaTexto(data) {

        return data.getDate()
            + '/' + (data.getMonth() + 1)
            + '/' + data.getFullYear();
      }

    textoParaData(texto) {

        return new Date(...texto.split('-').map((item,indice) => item - indice % 2));

    }
}
Em seguida, carregaremos este script no index.html.

<!-- ... -->
 <script src="js/app/models/Negociacao.js"></script>
 <script src="js/app/controllers/NegociacaoController.js"></script>
 <script src="js/app/helpers/DateHelper.js"></script>
 <script>
     let negociacaoController = new NegociacaoController();
 </script>   
</body>
</html>
Faremos alterações também no NegociacoesController.js, apagaremos as variáveis data e diaMesAno geradas anteriormente e vamos criar uma nova data:

adiciona(event) {

        event.preventDefault();

        let data = new DateHelper().textoParaData(this._inputData.value);

        let negociacao = new Negociacao(
                data,
                this._inputQuantidade.value,
                this._inputValor.value
            );


        console.log(negociacao);

        console.log(diaMesAno);
    }
}
Observe que adicionamos o DateHelper dentro do data. Agora, queremos que a data da negociação seja exibida no formato diaMesAno, separada com barras /. Em vez de usarmos o new no DateHelper, vamos adicionar a variável helper. Em data, adicionaremos a helper que dará o texto para data

adiciona(event) {

        event.preventDefault();

        let helper = new DateHelper();
        let data = helper.textoParaData(this._inputData.value);

        let negociacao = new Negociacao(
                data,
                this._inputQuantidade.value,
                this._inputValor.value
            );


        console.log(negociacao);

        console.log(helper.dataParaTexto(negociacao.data));
    }
}
Agora, isolamos a responsabilidade das conversões de data para classe Helper. Se executarmos o código, será criada a data correta:

negociacao na controller

A data também é impressa corretamente no formato texto. A classe Helper cumpriu bem o seu trabalho.

Em seguida, faremos um novo ajuste. Em vez de utilizarmos a variável data, moveremos a seguinte linha para a negociacao:

helper.textoParaData(this._inputData.value)
Com a alteração, o código ficará assim:

adiciona(event) {

    event.preventDefault();

    let helper = new DateHelper();

    let negociacao = new Negociacao(
        helper.textoParaData(this._inputData.value),
        this._inputQuantidade.value,
        this._inputValor.value
    );
}
Não precisamos mais da variável data, usaremos diretamente o seu retorno.

Vamos testar o código no navegador, e veremos que a data 12/11/2019 aparecerá no Console.

data no console funcionando

Nós conseguimos isolar o código dentro do Helper. Mas será que ainda podemos melhorá-lo ainda mais? Sempre que falo isso, vocês sabem que é possível. Veremos como, mais adiante.
*******************
03-Métodos estáticos
Precisamos usar uma instância para invocar os métodos, quando queremos usar o DateHelper. Mas será que este possui alguma propriedade? Não. Nós configuramos um construtor diferente do padrão para o DateHelper? Não. Vale ressaltar que se não definimos um constructor, por padrão, é como se existisse vazio.

class DateHelper {

  constructor() {}

  dataParaTexto(data) {

      return data.getDate()
          + '/' + (data.getMonth() + 1)
          + '/' + data.getFullYear();

}

textoParaData(texto) {

  return new Date(...texto.split('-').map((item,indice) => item - indice % 2));

}
Como não definimos o constructor, não colocaremos propriedades na classe. Outra opção seria adicionar a variável helper2:

adiciona(event) {

    event.preventDefault();

    let helper = new DateHelper();
    let helper2 = new DateHelper();

    let negociacao = new Negociacao(
        helper.textoParaData(this._inputData.value),
        this._inputQuantidade.value,
        this._inputValor.value
    );

    console.log(negociacao);
    console.log(helper.dataParaTexto(negociacao.data));

}    
Ou seja, adicionaríamos uma instância em todos os lugares que precisasse do helper. Isto tem um impacto no uso da memória, apesar de insignificante no nosso caso. Uma melhor decisão é acessar diretamente o método da classe.

adiciona(event) {

    event.preventDefault();

    let helper = new DateHelper();
    let helper2 = new DateHelper();

//...
Nós substituímos a instância helper por DateHelper.

adiciona(event) {

    event.preventDefault();

    let helper = new DateHelper();
    let helper2 = new DateHelper();

    let negociacao = new Negociacao(
        DateHelper.textoParaData(this._inputData.value),
        this._inputQuantidade.value,
        this._inputValor.value
    );

    console.log(negociacao);
    console.log(DateHelper.dataParaTexto(negociacao.data));
}
Nós não queremos que o método seja uma instância do DateHelper, queremos poder invocá-lo diretamente da definição da classe. Para isto, no arquivo DateHelper.js, adicionaremos o static aos métodos:

class DateHelper {

  static dataParaTexto(data) {

      return data.getDate()
          + '/' + (data.getMonth() + 1)
          + '/' + data.getFullYear();

}

  static textoParaData(texto) {

      return new Date(...texto.split('-').map((item,indice) => item - indice % 2));
    }
Agora, os métodos serão invocamos diretamente da classe e o NegociacaoController ficou um pouco mais enxuto. Vamos testar submeter os dados no formulário:

!Negociacao no console

Vimos uma novidade em termos de orientação para objeto: a classe DateHelper tem métodos estáticos, o que torna desnecessário a criação de uma instância.

Em seguida, vamos definir um constructor(), depois, adicionaremos a função throw new Error(). Várias funções do JavaScript não foram migradas para classe e são construtoras.

class DateHelper {

    constructor() {

        throw new Error('DateHelper não pode ser instanciada');

//...
No Console, digitaremos :

x = new DateHelper ()
Veremos o seguinte retorno.

mensagem de erro

Ao ver esta mensagem, o programador saberá que trabalhamos com métodos estáticos. Se clicarmos no erro, veremos qual é a classe e onde está o problema. Faremos um pequeno ajuste na mensagem que aparecerá, deixando-a mais genérica:

class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instanciada');
    }
//...
esta classe não pode ser instanciada

Mais adiante, vamos melhorar ainda mais a classe.
*******************
04-Template Strings

*******************
05-
*******************
06-
*******************
07-
*******************
08-
*******************
09-
*******************
10-
*******************
11-
*******************
12-
*******************
13-
*******************
14-
*******************
15-
*******************
16-
*******************
