Aula05
01-Classes que representam nossas Views
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui e continuar seus estudos.

Temos um modelo de Negociacao, outro de ListaNegociacoes, e temos uma controller que orquestra o acesso aos modelos de acordo com as ações do usuário. No entanto, ainda não conseguimos refletir o estado do modelo para a tela. A tabela ainda não exibe os dados cadastrados. Agora temos que atacar a View, do MVC, já temos o model e a controller. Para que possamos aplicar vários conceitos e conhecer novos recursos da linguagem JavaScript, minha proposta é que em cada parte da View que sincronizarmos com o modelo, não será feita no arquivo HTML. Em vez disso, criaremos a classe NegociacoesView dentro da pasta views que irá encapsular a apresentação que exibiremos para o usuário. É o arquivo NegociacoesView.js que terá as definições de como será a tabela. Começaremos com ela assim:

<table class="table table-hover table-bordered">
    <thead>
        <tr>
            <th>DATA</th>
            <th>QUANTIDADE</th>
            <th>VALOR</th>
            <th>VOLUME</th>
        </tr>
    </thead>

    <tbody>
    </tbody>

    <tfoot>
    </tfoot>
</table>
Como retiramos o trecho do código referente à tabela, no index.html, ela já não será mais exibida abaixo do formulário.

formulario sem tabela

Ao incluirmos uma negociação na lista, queremos que ela seja incluída e exibida na tabela. Para isto, em NegociacoesView.js, adicionaremos a classe NegociacaoView, e dentro dela, criaremos a função template() - que retornará uma template string. Depois, jogaremos o conteúdo da tabela dentro do return da função.

class NegociacoesView {

    template() {

        return `
        <table class="table table-hover table-bordered">
            <thead>
                <tr>
                    <th>DATA</th>
                    <th>QUANTIDADE</th>
                    <th>VALOR</th>
                    <th>VOLUME</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
     </table>
            `;
    }
}
Se o retorno não fosse uma template string, não poderíamos "identar" o código desta forma. Se fosse uma string, não poderíamos quebrar o código em linhas desta maneira. Ele não funcionaria. Nós teríamos que concatenar todas as linhas.

Em seguida, no NegociacaoController, adicionaremos a propriedade this._negociacao View:


class NegociacaoController {

    constructor() {

        let $ = document.querySelector.bind(document);
        this._inputData = $('#data');
        this._inputQuantidade = $('#quantidade');
        this._inputValor = $('#valor');
        this._listaNegociacoes = new ListaNegociacoes();
        this._negociacoesView = new NegociacoesView();
    }
//...
Precisaremos importar o arquivo também no index.html:

    <script src="js/app/models/Negociacao.js"></script>
    <script src="js/app/controllers/NegociacaoController.js"></script>
    <script src="js/app/helpers/DateHelper.js"></script>
    <script src="js/app/models/ListaNegociacoes.js"></script>
    <script src="js/app/views/NegociacoesView.js"></script>
    <script>
        let negociacaoController = new NegociacaoController();
</script>   
Após recarregarmos a página vamos digitar a seguinte linha no Console:

let NegociacoesView = new NegociacoesView()
Teremos uma instância de NegociacoesView. Se chamamos NegociacoesView.template(), recebemos uma mensagem de erro:

string no console

No Console, será exibida a string da tabela. Então, qual será nosso próximo objetivo? O template que está no NegociacoesView.js tem que aparecer no index.html, onde estava a marcação do HTML da tabela. Para isto, sinalizaremos o local em que o template será renderizado, adicionando a tag <div> e dentro, o id.

<div id="negociacoesView"></div>
Mas o NegociacoesView precisa saber que construiremos a tabela nesta <div>. Precisamos de alguma forma associar o elemento do DOM com a NegociacoesView. Por isso, vamos gerar um constructor() que recebe um elemento, responsável por receber o template:

class NegociacoesView {

    constructor(elemento) {

        this._elemento = elemento;
    }

    template() {

        return `<table class="table table-hover table-bordered">
                    <thead>
                        <tr>
                            <th>DATA</th>
                            <th>QUANTIDADE</th>
                            <th>VALOR</th>
                            <th>VOLUME</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
             </table>
            `;
    }
}
Em NegociacaoController, teremos que buscar o #negociacaoView:


class NegociacaoController {

    constructor() {

        let $ = document.querySelector.bind(document);
        this._inputData = $('#data');
        this._inputQuantidade = $('#quantidade');
        this._inputValor = $('#valor');
        this._listaNegociacoes = new ListaNegociacoes();
        this._negociacoesView = new NegociacoesView($('#negociacoesView'));

        this._negociacoesView.update();
    }
//...
Assim que a negociação for criada, pediremos para o negociacoesView fazer um update, então, a tabela aparecerá dentro da View. Depois, adicionaremos a função update dentro de NegociacoesView. Também vamos inserir o _ ao template, sinalizando que será uma função privada.

_template() {

    return `
    <table class="table table-hover table-bordered">
                <thead>
                    <tr>
                        <th>DATA</th>
                        <th>QUANTIDADE</th>
                        <th>VALOR</th>
                        <th>VOLUME</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
         </table>
        `;
      }
O método update() que será criado, pegará o elemento do DOM e acessará a propriedade innerHTML. Ela será o retorno da função _template():

update() {

      this._elemento.innerHTML = this._template();
}
O innerHTML será responsável por converter as strings em elementos do DOM. Isto será inserido com filho da <div>.

Após as últimas alterações, quando recarregarmos a página no navegador, a tabela já será visualizada.

tabela na pagina

O problema é que ao chamarmos a função update(), a View que estamos renderizando no HTML, deveria refletir a lista de negociações. Se tivermos cinco negociações, todas deverão ser exibidas. Veremos mais adiante como atualizar a View com os dados do modelo.

Nosso objetivo era chamar na View a função update(), quando o modelo fosse atualizado, passando como parâmetro o model - que será enviado para o template da View. Depois, este será processado e usará como base os dados do model. A string final será colocada no atributo do elemento que a View associada no DOM. Toda string colocada na propriedade innerHTML será convertida em elementos do DOM.

Desta forma, conseguimos cadastrar as negociações, sendo atualizada no modelo e este notificará a View que deverá ser renderizada.
*******************
02-Construindo um template dinâmico com a função map
A função update() para atualização da View está funcionando e a tabela já pode ser visualizada abaixo do formulário. Porém, os dados do modelo ainda não são levados em consideração na construção dinâmica da tabela. Primeiramente, passaremos a ListaNegociacoes como parâmetro do método update(). Ou seja, quando o modelo for alterado, a lista deverá ser atualizada da tabela.

class NegociacaoController {

    constructor() {

        let $ = document.querySelector.bind(document);
        this._inputData = $('#data');
        this._inputQuantidade = $('#quantidade');
        this._inputValor = $('#valor');

        this._listaNegociacoes = new ListaNegociacoes();
        this._negociacoesView = new NegociacoesView($('#negociacoesView'));


    }
A ação não será realizada apenas quando a controller for carregada, mas também quando o adiciona() for chamado. Porque atualizamos a lista, assim que acabamos de adicionar uma nova negociação, temos que solicitar para View que esta se renderize com o novo modelo. Em NegociacoesView.js, faremos com que o método update() recebe o model.

update(model) {

    this._elemento.innerHTML = this._template(model);
}
Passamos o model como parâmetro do _template().

_template(model)

    return `
    <table class="table table-hover table-bordered">
                <thead>
                    <tr>
                        <th>DATA</th>
                        <th>QUANTIDADE</th>
                        <th>VALOR</th>
                        <th>VOLUME</th>
                    </tr>
                </thead>

                <tbody>
                </tbody>
         </table>
        `;
      }
Dentro da tag <tbody>, adicionaremos tags <tr> com base em cada negociação do ListaNegociacoes. Para isto, usaremos uma expressão que conterá o map() - podemos usar, inclusive, uma arrow function.

<tbody>
    ${model.negociacoes.map(n => {

      })}
</tbody>
Se adicionarmos um console.log(n) e executarmos o código, a negociação será impressa no Console. Com o return n, será gerada uma nova lista, com base na modificação. O código ficaria assim:

<tbody>
    ${model.negociacoes.map(n => {
        console.log(n);
        return n;
      })}
</tbody>
Porém, se selecionarmos esta opção, teremos um problema: a expressão precisa nos devolver uma string, que seja enxertada no template. Seguiremos outro caminho: varreremos cada negociação e usaremos o return de outra template string.

<tbody>
    ${model.negociacoes.map(n => {

      return `
        <tr>
            <td>${DateHelper.dataParaTexto(n.data)}</td>
            <td>${n.quantidade}</td>
            <td>${n.valor}</td>
            <td>${n.volume}</td>
        </tr>
      `
      })}
</tbody>
Dentro da template string, adicionamos as tags <tr> e <td>, e usamos várias expressões para definirmos a exibição de data, quantidade, valor e volume. Quando o _template() for retornar a string, terá que processar o trecho do return primeiramente, e depois retornar a template string. Para cada negociação será criada uma lista - cada uma com as tags <tr> e os dados cadastrados. Estamos varrendo a lista e para um objeto Negociacao, estamos criando um array, mas o novo elemento será uma string com os dados. No entanto, por enquanto, o retorno será um array. Por isso, adicionaremos o join().

<tbody>
    ${model.negociacoes.map(n => {

      return `
        <tr>
            <td>${DateHelper.dataParaTexto(n.data)}</td>
            <td>${n.quantidade}</td>
            <td>${n.valor}</td>
            <td>${n.volume}</td>
        </tr>
      `
      }).join('')}
</tbody>
Ao utilizarmos o join(), usamos como critério de junção uma string em branco. Agora, teremos uma string com todos os dados do array concatenados. Vamos ver o que será exibido no navegador, após o preenchimento do formulário:

tabela com valores

Em seguida, adicionaremos uma nova negociação e os dados também serão exibidos na tabela.

tabela com duas negociações

Se completarmos os dados do formulário novamente, a tabela terá dados das três negociações. Observe que não manipulamos o DOM de maneira imperativa, em vez disso, fizemos de maneira declarativa. Nós declaramos o template, ele recebeu um modelo e com base nos dados do modelo, usamos a template string.

Conseguimos de maneira elegante, utilizando apenas recursos do JavaScript, fazer um template render. Porém, faltam algumas ações para que nossa tabela fique completa.
*******************
03-Enxugando o código
Faremos um pequeno ajuste que passou despercebido no vídeo anterior, antes de completarmos o código. Deixamos incompleto o fechamento da tag <tr>. Corrigiremos a falha dentro da <tbody>:

<tbody>
    ${model.negociacoes.map(n => {

      return `
        <tr>
            <td>${DateHelper.dataParaTexto(n.data)}</td>
            <td>${n.quantidade}</td>
            <td>${n.valor}</td>
            <td>${n.volume}</td>
        </tr>
      `
      })}
</tbody>
Felizmente, o navegador entendeu que tratava-se de um tag <tr>. Outro ajuste será na arrow function. Quando trabalhamos com um único retorno, não precisamos usar as chaves ({}). Também podemos remover o return. Veja como nosso código ficará mais enxuto:

<tbody>
    ${model.negociacoes.map(n => `

          <tr>
            <td>${DateHelper.dataParaTexto(n.data)}</td>
            <td>${n.quantidade}</td>
            <td>${n.valor}</td>
            <td>${n.volume}</td>
          </tr>

      `).join('')}
</tbody>
Facilitamos a leitura do código. Fizemos a declaração do template.

A seguir, trabalharemos com a tag <tfoot>, com a qual criaremos o rodapé.
*******************
04-Totalizando o volume em nosso Template
Vamos trabalhar com o rodapé... Atualmente, o método _template() está assim:

_template(model)

    return `
    table class="table table-hover table-bordered">
                <thead>
                    <tr>
                        <th>DATA</th>
                        <th>QUANTIDADE</th>
                        <th>VALOR</th>
                        <th>VOLUME</th>
                    </tr>
                </thead>

                <tbody>
                    ${model.negociacoes.map(n => `

                          <tr>
                            <td>${DateHelper.dataParaTexto(n.data)}</td>
                            <td>${n.quantidade}</td>
                            <td>${n.valor}</td>
                            <td>${n.volume}</td>
                          </tr>

                      `)join('')
                    }
                </tbody>

                <tfoot>
                </tfoot>

         </table>
        `;
      }
Para totalizarmos o volume, adicionaremos a tag <td> dentro da <tfoot>:

<tfoot>
    <td colspan="3"></td>
    <td>0</td>
</tfoot>
Observe que utilizamos a colspan com o valor 3, assim teremos três colunas. Usamos também uma <td> que tem o valor igual a 0. Mas se executarmos o código agora, ainda não será totalizado o volume.

volume 0

Para totalizar, poderíamos usar o forEach() e somar cada volume da negociação com uma variável.

<tfoot>
    <td colspan="3"></td>
    <td>${
        (function() {

            let total = 0;
            model.negociacoes.forEach(n => total+= n.volume);
            return total;
       })()
      }
    </td>
</tfoot>
Porém, dentro da expressão, precisamos retornar um valor. Só que quando usamos uma instrução, não podemos adicionar uma sequência de instruções. Seremos espertos e adicionaremos uma função dentro do $. Utilizaremos uma Immediately-invoked function expression (IIFE) ou a função imediata. Trata-se de um recurso usado na criação de escopo em JavaScript, que nos ajudará a colocar um bloco na expressão, sendo executado imediatamente. No caso, o $ receberá o total.

tabela com o volume total

Se testarmos no navegador, já será exibido o total do volume. Mas depois dessa "gambiarra", o código não ficou bonito. É possível fazer a ação de totalização de outra maneira funcional. Veremos mais adiante.
*******************
05-
*******************
06-
*******************
07-
*******************
08-
*******************
09-
*******************
11-
*******************
11-
*******************
12-
*******************
13-
*******************
14-
*******************