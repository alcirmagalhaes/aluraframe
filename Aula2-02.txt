Aula2-02
01-Modelo e reutilização em projetos
Você pode fazer o download completo até aqui e continuar seus estudos.

Para liberarmos o desenvolvedor da responsabilidade de atualizar programaticamente a View sempre que o modelo fosse atualizado, nós colocamos "armadilhas": funções que eram chamadas quando métodos específicos eram executados. Desta forma, chamávamos automaticamente a atualização da View. Nós declaramos o modelo no inicio, definimos as ações que deveriam acontecer quando ocorria a modificação, e assim liberamos o desenvolvedor da responsabilidade.

No entanto, esta solução deixa a desejar porque coloca código de infraestrutura - ou seja, de atualização da View - no modelo. Geralmente, a parte mais reutilizada de um sistema é o modelo. Então, ao acessarmos um modelo de negociação e encontrarmos um atributo chamado _armadilha, por exemplo:

class ListaNegociacoes {

    constructor(armadilha) {

        this._negociacoes = [];
        this._armadilha = armadilha;
    }
//...
O que _armadilha tem a ver com a lista de negociação? Ela foi usada apenas para aplicar o artifício que chama a View automaticamente. E se tivéssemos outros métodos que quiséssemos monitorar e executar uma armadilha? Teríamos que alterar a classe do modelo. Então, o modelo é a parte mais reutilizável. Se agora não quisermos mais utilizar um sistema baseado em MVC, podemos optar em usar o AngularJS ou outro framework.

Mas se começamos a incluir diversos itens de infraestrutura, de recursos para que ela gere benefícios - como a atualização de View - começamos a não reutilizar continuamente o modelo. Encontraremos uma forma de manter o modelo intacto, sem utilizarmos armadilhas e ainda assim, conseguir executar um código arbitrário quando algum método for chamado. A seguir, encontraremos uma solução para a questão.
*****************
02-O padrão de projeto Proxy
Veremos qual é a solução que nos permite manter o modelo... Começaremos retirando o _armadilha de ListaNegociacoes:

class ListaNegociacoes {

  constructor() {

        this._negociacoes = [];
  }
  adiciona(negociacao) {
      this._negociacoes.push(negociacao);
  }

  get negociacoes() {
      return [].concat(this._negociacoes);
  }

  esvazia() {
      this._negociacoes = [];
  }
}
Como removemos o _armadilha, o construtor de NegociacaoController deixará de funcionar e descobriremos uma forma de resolver problema da View. Temos ainda outro problema com a solução que usa o _armadilha: se quisermos monitorar os models Mensagem e Negociacoes, teremos que abrir a classe para alterar e colocar a armadilha - mas, não faremos isto.

Existe um famoso padrão de projeto chamado Proxy, que de forma resumida, é "um cara mentiroso". Vimos que não é bom inserirmos armadilhas na classe, porque estaremos perdendo a reutilização do modelo e teremos que repetir em todos os modelos do sistema. No entanto, o Proxy é idêntico ao objeto que queremos trabalhar, e teremos bastante dificuldade de diferenciá-los. Nós acessamos o Proxy como se ele fosse o objeto real, este último ficará escondido dentro do outro. Nós substituímos o objeto real, que só poderá ser acessado por meio do Proxy - que pode ou não ser executado em um código arbitrário se assim definirmos.

Observe que ListaNegociacoes tem o métodos adiciona() e negociacoes(), que também estarão presentes no Proxy.

class ListaNegociacoes {

  constructor(armadilha) {

        this._negociacoes = [];
        this._armadilha = armadilha;
  }
  adiciona(negociacao) {
      this._negociacoes.push(negociacao);
      this._armadilha(this);
  }

  get negociacoes() {
      return [].concat(this._negociacoes);
  }

  esvazia() {
      this._negociacoes = [];
      this._armadilha(this);
  }
A diferença está em que quando chamarmos o adiciona(), o Proxy delegará a chamada do método para o objeto encapsulado por ele. Mas ainda não temos benefícios com esta mudança. A vantagem está que colocaremos as armadilhas entre a chamada do Proxy e o objeto real. Toda vez que acessamos o Proxy, executaremos um código antes de chamarmos um método ou propriedade correspondente ao objeto real.

A boa notícia é que não precisamos implementar esse padrão de projeto.

A partir da versão 2015 do ECMAScript, a própria linguagem já possui um recurso de Proxy. Então, implementaremos o padrão de projeto Proxy usando o ES6.
*****************
03-Aprendendo a trabalhar com o Proxy
Vamos aprender a trabalhar com o Proxy. Começaremos comentando o código de NegociacaoController, porque ele não está válido devido a remoção da armadilha passada para o construtor.

class NegociacaoController {

    constructor() {

        let $ = document.querySelector.bind(document);
        this._inputData = $('#data');
        this._inputQuantidade = $('#quantidade');
        this._inputValor = $('#valor');

        /*
        this._listaNegociacoes = 
            new ListaNegociacoes(model => this._negociacoesView.update(model));
            */
//...
Depois, abriremos o Console no navegador. Veremos uma mensagem de erro, porque a negociação está com problema. Começaremos criando um negociacao:

let negociacao = new Negociacao(new Date(), 1, 100);
undefined
let negociacaoProxy = new Proxy(negociacao, {});
Criaremos um Proxy de negociacao. O segundo parâmetro é um objeto no formato literal {}, em que iremos configurar nossas armadilhas. Em seguida, digitaremos a seguinte linha:

negocicacaoProxy.valor
100
Ao acessarmos valor, o retorno será 100. Conseguimos ter acesso a quantidade e volume:

negocicacaoProxy.valor
100
negociacaoProxy.quantidade
1
negocicacaoProxy.volume
100
O Proxy terá exatamente o mesmo comportamento do objeto.

Proxy no console

No entanto, não queremos que ninguém tenha acesso ao objeto real (negociacao), caso contrário, ninguém cairá nas armadilhas. Para isto, executaremos a seguinte linha no Console:

let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {});
Neste caso, negociacao é o Proxy:

negociacao é o Proxy

Agora, a única maneira de lidar com a instância de negociação criada é por intermédio do Proxy. Precisamos aprender como passamos o handlers ({}) para colocarmos nossas armadilhas. Adicionaremos outra tag <script> no index.html e depois, colocaremos o código que executamos no Console.

<script>

    let negociacao = new Proxy(new Negociacao(new Date(), 2, 100), {

      });

</script>
Mais adiante, definiremos o handler.
*****************
04-Construindo armadilhas de leitura
Nós já criamos uma Proxy. Em seguida, adicionaremos o console.log:

<script>
    let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {});

    console.log(negociacao.quantidade);
    console.log(negociacao.valor);

</script>
Se executarmos o código, veremos os valores 1 e 100 impressos no Console.

valores no console

No entanto, queremos executar um código antes de exibirmos o valor de quantidade, queremos que seja visualizado um texto informando que a quantidade foi acessada. Faremos com que o texto também seja exibido antes da propriedade valor. A seguir, adicionaremos uma função que receberá três parâmetros: target, prop e receive.

<script>
    let negociacao = new Proxy(new Negociacao(new Date(), 2, 100), {

        get: function(target, prop, receiver) {

              console.log(`a propriedade "${prop}" foi interceptada`);
        }
    });

    console.log(negociacao.quantidade);
    console.log(negociacao.valor);

  </script>
O getserá chamado sempre que tentarmos ler uma das propriedades do objeto. Ao ser chamado, ele tem o target (uma referência ao objeto original que está encapsulado pelo Proxy), a propriedade (prop) que está sendo acessada, e uma referência (receiver) para o Proxy. Agora, antes de ser exibidos os valores das propriedades, os textos devem ser exibidos.

No navegador, vamos obter o resultado esperado:

a propriedade foi interceptada

Porém, os valores das propriedades resultaram em undefined. Isto ocorreu, porque quando executamos uma armadilha (trap, traduzido para o inglês), é necessário informar qual será o valor retornado após a interceptação da propriedade de leitura. Adicionaremos o return:

   <script>

       let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {

           get: function(target, prop, receiver) {

                 console.log(`a propriedade "${prop}" foi interceptada`);
                 return 'Flávio';
           }
       });
       console.log(negociacao.quantidade);
       console.log(negociacao.valor);
 </script>
Veja o que será exibido no Console:

return Flavio

Quando acessamos negociacao.valor, ele retorna Flávio. Mas não é o que queremos... Queremos o valor verdadeiramente guardado. Para isto, vamos pedir auxilio para a API de Reflect.get() e os três parâmetros. Nós queremos executar uma operação de leitura.

get: function(target, prop, receiver) {

     console.log(`a propriedade "${prop}" foi interceptada`);
     return Reflect.get(target, prop, receiver);
}
No navegador, ele imprimirá o texto e os valores das propriedades.

mensagens no console

Mas por que a mensagem foi impressa duas vezes, com um pequena diferença. Isto ocorre, porque no arquivo Negociacao.js, ele irá interceptar para quantidade e _quantidade.

get quantidade() {

    return this._quantidade;
}

get valor() {
  return this._valor;
}
O mesmo acontecerá com valor e _valor. Então nosso código funciona.

Nós vimos como executar um código, antes da leitura das propriedades do objeto. Mas para resolvermos o problema da atualização automática da View - lembrando que não queremos atualizá-la enquanto estivermos lendo um dado. Mas este não é o nosso foco. O objetivo é encontrar uma forma de executar o código quando uma propriedade é modificada. Veremos mais adiante.
*****************
05-Construindo armadilhas de escrita

*******Não estamos interessados em executar um código quando ocorrer a leitura, e sim, quando acontecer a modificação de alguma propriedade. Em seguida, faremos pequenas alterações no arquivo index.html. Atualmente, o get está assim:

<script>

    let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {
    get: function(target, prop, receiver) {

         console.log(`a propriedade "${prop}" foi interceptada`);
         return Reflect.get(target, prop, receiver);
    }
    });
    negociacao.quantidade = 10;
    negociacao.valor = 100;
</script>
Mas esse código ainda não funcionará, porque quantidade e valor em Negociacao.js são getters. Por isso, não podemos fazer uma atribuição, considerando que são apenas leitura e não podem ser alterados. De volta ao index.html, faremos uma "licença poética" e acessaremos diretamente as propriedades privates.

negociacao._quantidade = 10;
negociacao._valor = 100;
Vamos desrespeitar a convenção da nossa propriedade, mas com isso, poderemos disparar a nossa armadilha.

A primeira coisa que devemos fazer para executar uma armadilha quando estou atribuindo, é alterarmos de get para set. Também adicionaremos outro parâmetro: value.

<script>

    let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {
    set: function(target, prop, value, receiver) {

         console.log(`a propriedade "${prop}" foi interceptada`);
         return Reflect.set(target, prop, value, receiver);
    });
    negociacao._quantidade = 10;
    negociacao._valor = 100;
</script>
Quando atribuímos 10 para _quantidade, a função no set será chamada e retornará os quatro parâmetros. No console.log() queremos exibir o valor atual e o que será exibido depois.

<script>

    let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {
    set: function(target, prop, value, receiver) {

         console.log(`novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
}
    });
    negociacao._quantidade = 10;
    negociacao._valor = 100;
</script>
Com o value no console.log exibiremos o valor que queremos atribuir.

novo valor

A armadilha foi executada e os valores exibidos estão corretos. Mas também queremos mostrar o valor antigo, para isto, só teremos acesso ao target que é o objeto Negociacao. Vamos tentar usar o seguinte código no console.log:

console.log(`${target.quantidade} novo valor: ${value}`);
return Reflect.set(target, prop, value, receiver);
No Console. veremos os seguintes valores:

target no Console

Para quantidade, o valor antigo ficou igual a 1, e o mesmo para o valor. A explicação é que a linha do console.log está sendo executada também quando tentamos descobrir o negociacao._valor. Então, o valor de quantidade deve ser igual ao valor de prop. Mas como conseguiremos fazer a property dinâmica? Não temos a opção de usar ${target.prop}, mas podemos usar um recurso do JS, podemos passar ${target[prop]}. O trecho do código ficará assim:

<script>

  let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {
    set: function(target, prop, value, receiver) {

         console.log(`${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
}
    });
    negociacao._quantidade = 10;
    negociacao._valor = 100;
</script>
O prop junto com o target será o _quantidade e conseguirá ler o valor. Em seguida, adicionaremos valor anterior: à linha.

<script>

  let negociacao = new Proxy(new Negociacao(new Date(), 2, 100), {
    set: function(target, prop, value, receiver) {

         console.log(`valor anterior: ${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
}
    });
    negociacao._quantidade = 10;
    negociacao._valor = 200;
</script>
No Console, veremos os seguintes valores:

valor anterior no Console

Com isso, resolvemos o problema da execução de um código que só atualizará a View quando _quantidade e _valor forem alterados.
**********
06-Método que não altera propriedade
Agora que ensaiamos com o negociacao, vamos nos focar em criar a Proxy no modelo do ListaNegociacoes. No index.html, vamos substituir no código negociacao por ListaNegociacoes. Mudaremos também o console.log pelo lista.adiciona().

<script>

  let lista = new Proxy(new ListaNegociacoes(), {
    set: function(target, prop, value, receiver) {

         console.log(`valor anterior: ${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
    }
  });
  lista.adiciona(new Negociacao(new Date(), 1, 100));
</script>
Se tentarmos executar o código como está, nada acontecerá. Nós já entendemos que devemos usar o get quando estamos olhando uma propriedade e o set quando queremos modificar uma propriedade. No entanto, a armadilha não foi disparada no lista.adiciona(). Sabe por que isto aconteceu? O adiciona() é um método, que no arquivo ListaNegociacoes.js, pede internamente para negociacoes fazer o push().

adiciona(negociacao) {

    this._negociacoes.push(negociacao);

}
Porém, nós não atribuímos valores para uma propriedade, sendo assim, o set não será chamado. Teremos que encontrar uma solução, porque tanto o método adiciona() como o esvazia() terá este tipo de problema - ainda que o segundo, atribua um valor para negociacoes. Vamos fazer um teste, adicionando o esvazia(), no index.html:

<script>

  let lista = new Proxy(new ListaNegociacoes(), {
    set: function(target, prop, value, receiver) {

         console.log(`valor anterior: ${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
    }
  });
  lista.adiciona(new Negociacao(new Date(), 1, 100));
  lista.esvazia();
</script>
esvazia no Console

O esvazia() executou o código, porque o valor anterior: era um objeto e o novo valor: ficou vazio. Nós queremos que o interceptador dispare com o lista.adiciona. No entanto, por padrão, não conseguiremos fazer isto usando o Proxy do ES6.

Mas não vamos ignorar o que vimos até aqui.
*****************
07-Uma solução para método que não altera propriedade
Nós não vamos nos abdicar de utilizar o Proxy. Mas a primeira tentativa de solucionar o assunto será com uma "gambiarra". Em ListaNegociacoes, vamos forçar uma atribuição em this._negociacoes.

class ListaNegociacoes {

    constructor() {
        this._negociacoes = [];
    }

    adiciona(negociacao) {

        this._negociacoes = [].concat(this._negociacoes, negociacao);
        // this._negociacoes.push(negociacao);
    }
Com o concat(), podemos passar tanto o array quanto o elemento, além de outros parâmetros - e todos serão concatenados. Como forçamos uma atribuição, quando recarregamos a página, veremos no Console:


_negociacoes => valor anterior: , novo valor: [object Object]
_negociacoes => valor anterior: está saindo em branco, porque o valor anterior é um array vazio. O novo valor tem o object porque se trata do novo array.

É possível resolver com esta gambiarra, mas não será esta a solução que utilizaremos. Imagine que fazemos um loop de 100 negociações, se nosso código ficar assim, a cada negociação adicionada, teremos que criar um nova lista e reatribuir para ListaNegociacoes. Teríamos problema com a performance. Apesar de termos feito o mesmo no get:

get negociacoes() {

    return [].concat(this._negociacoes);
}
Mas neste caso, quem pede a lista de negociação não fará solicitação infinitas vezes seguidas. É possível varrer a lista diversas vezes, sem chamar get sempre. O mesmo não ocorre com adiciona(). Se queremos fazer uma operação em lote, usaremos o adiciona(). Precisamos descobrir uma outra estratégia - mais de "cangaceiro" do que de "ninja". Ao identificarmos o adiciona() como um método no index.html, queremos executar a armadilha.

<script>

  let lista = new Proxy(new ListaNegociacoes(), {
    set: function(target, prop, value, receiver) {

         console.log(`valor anterior: ${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
    }});
    lista.adiciona(new Negociacao(new Negociacao(new Date(), 1, 100));
</script>
Não há uma maneira de interceptarmos o método com o Proxy. Quando chamamos um método no JavaScript, por exemplo o adiciona(), ele fará um get na função e depois, executará o Reflect.apply. Então, será passado o valor para a função dentro do parênteses. Mas o set não está incluso no método.

A seguir, resolveremos o assunto.

*****************
08-
*****************