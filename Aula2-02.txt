Aula2-02
01-Modelo e reutilização em projetos
Você pode fazer o download completo até aqui e continuar seus estudos.

Para liberarmos o desenvolvedor da responsabilidade de atualizar programaticamente a View sempre que o modelo fosse atualizado, nós colocamos "armadilhas": funções que eram chamadas quando métodos específicos eram executados. Desta forma, chamávamos automaticamente a atualização da View. Nós declaramos o modelo no inicio, definimos as ações que deveriam acontecer quando ocorria a modificação, e assim liberamos o desenvolvedor da responsabilidade.

No entanto, esta solução deixa a desejar porque coloca código de infraestrutura - ou seja, de atualização da View - no modelo. Geralmente, a parte mais reutilizada de um sistema é o modelo. Então, ao acessarmos um modelo de negociação e encontrarmos um atributo chamado _armadilha, por exemplo:

class ListaNegociacoes {

    constructor(armadilha) {

        this._negociacoes = [];
        this._armadilha = armadilha;
    }
//...
O que _armadilha tem a ver com a lista de negociação? Ela foi usada apenas para aplicar o artifício que chama a View automaticamente. E se tivéssemos outros métodos que quiséssemos monitorar e executar uma armadilha? Teríamos que alterar a classe do modelo. Então, o modelo é a parte mais reutilizável. Se agora não quisermos mais utilizar um sistema baseado em MVC, podemos optar em usar o AngularJS ou outro framework.

Mas se começamos a incluir diversos itens de infraestrutura, de recursos para que ela gere benefícios - como a atualização de View - começamos a não reutilizar continuamente o modelo. Encontraremos uma forma de manter o modelo intacto, sem utilizarmos armadilhas e ainda assim, conseguir executar um código arbitrário quando algum método for chamado. A seguir, encontraremos uma solução para a questão.
*****************
02-O padrão de projeto Proxy
Veremos qual é a solução que nos permite manter o modelo... Começaremos retirando o _armadilha de ListaNegociacoes:

class ListaNegociacoes {

  constructor() {

        this._negociacoes = [];
  }
  adiciona(negociacao) {
      this._negociacoes.push(negociacao);
  }

  get negociacoes() {
      return [].concat(this._negociacoes);
  }

  esvazia() {
      this._negociacoes = [];
  }
}
Como removemos o _armadilha, o construtor de NegociacaoController deixará de funcionar e descobriremos uma forma de resolver problema da View. Temos ainda outro problema com a solução que usa o _armadilha: se quisermos monitorar os models Mensagem e Negociacoes, teremos que abrir a classe para alterar e colocar a armadilha - mas, não faremos isto.

Existe um famoso padrão de projeto chamado Proxy, que de forma resumida, é "um cara mentiroso". Vimos que não é bom inserirmos armadilhas na classe, porque estaremos perdendo a reutilização do modelo e teremos que repetir em todos os modelos do sistema. No entanto, o Proxy é idêntico ao objeto que queremos trabalhar, e teremos bastante dificuldade de diferenciá-los. Nós acessamos o Proxy como se ele fosse o objeto real, este último ficará escondido dentro do outro. Nós substituímos o objeto real, que só poderá ser acessado por meio do Proxy - que pode ou não ser executado em um código arbitrário se assim definirmos.

Observe que ListaNegociacoes tem o métodos adiciona() e negociacoes(), que também estarão presentes no Proxy.

class ListaNegociacoes {

  constructor(armadilha) {

        this._negociacoes = [];
        this._armadilha = armadilha;
  }
  adiciona(negociacao) {
      this._negociacoes.push(negociacao);
      this._armadilha(this);
  }

  get negociacoes() {
      return [].concat(this._negociacoes);
  }

  esvazia() {
      this._negociacoes = [];
      this._armadilha(this);
  }
A diferença está em que quando chamarmos o adiciona(), o Proxy delegará a chamada do método para o objeto encapsulado por ele. Mas ainda não temos benefícios com esta mudança. A vantagem está que colocaremos as armadilhas entre a chamada do Proxy e o objeto real. Toda vez que acessamos o Proxy, executaremos um código antes de chamarmos um método ou propriedade correspondente ao objeto real.

A boa notícia é que não precisamos implementar esse padrão de projeto.

A partir da versão 2015 do ECMAScript, a própria linguagem já possui um recurso de Proxy. Então, implementaremos o padrão de projeto Proxy usando o ES6.
*****************
03-Aprendendo a trabalhar com o Proxy
Vamos aprender a trabalhar com o Proxy. Começaremos comentando o código de NegociacaoController, porque ele não está válido devido a remoção da armadilha passada para o construtor.

class NegociacaoController {

    constructor() {

        let $ = document.querySelector.bind(document);
        this._inputData = $('#data');
        this._inputQuantidade = $('#quantidade');
        this._inputValor = $('#valor');

        /*
        this._listaNegociacoes = 
            new ListaNegociacoes(model => this._negociacoesView.update(model));
            */
//...
Depois, abriremos o Console no navegador. Veremos uma mensagem de erro, porque a negociação está com problema. Começaremos criando um negociacao:

let negociacao = new Negociacao(new Date(), 1, 100);
undefined
let negociacaoProxy = new Proxy(negociacao, {});
Criaremos um Proxy de negociacao. O segundo parâmetro é um objeto no formato literal {}, em que iremos configurar nossas armadilhas. Em seguida, digitaremos a seguinte linha:

negocicacaoProxy.valor
100
Ao acessarmos valor, o retorno será 100. Conseguimos ter acesso a quantidade e volume:

negocicacaoProxy.valor
100
negociacaoProxy.quantidade
1
negocicacaoProxy.volume
100
O Proxy terá exatamente o mesmo comportamento do objeto.

Proxy no console

No entanto, não queremos que ninguém tenha acesso ao objeto real (negociacao), caso contrário, ninguém cairá nas armadilhas. Para isto, executaremos a seguinte linha no Console:

let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {});
Neste caso, negociacao é o Proxy:

negociacao é o Proxy

Agora, a única maneira de lidar com a instância de negociação criada é por intermédio do Proxy. Precisamos aprender como passamos o handlers ({}) para colocarmos nossas armadilhas. Adicionaremos outra tag <script> no index.html e depois, colocaremos o código que executamos no Console.

<script>

    let negociacao = new Proxy(new Negociacao(new Date(), 2, 100), {

      });

</script>
Mais adiante, definiremos o handler.
*****************
04-Construindo armadilhas de leitura
Nós já criamos uma Proxy. Em seguida, adicionaremos o console.log:

<script>
    let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {});

    console.log(negociacao.quantidade);
    console.log(negociacao.valor);

</script>
Se executarmos o código, veremos os valores 1 e 100 impressos no Console.

valores no console

No entanto, queremos executar um código antes de exibirmos o valor de quantidade, queremos que seja visualizado um texto informando que a quantidade foi acessada. Faremos com que o texto também seja exibido antes da propriedade valor. A seguir, adicionaremos uma função que receberá três parâmetros: target, prop e receive.

<script>
    let negociacao = new Proxy(new Negociacao(new Date(), 2, 100), {

        get: function(target, prop, receiver) {

              console.log(`a propriedade "${prop}" foi interceptada`);
        }
    });

    console.log(negociacao.quantidade);
    console.log(negociacao.valor);

  </script>
O getserá chamado sempre que tentarmos ler uma das propriedades do objeto. Ao ser chamado, ele tem o target (uma referência ao objeto original que está encapsulado pelo Proxy), a propriedade (prop) que está sendo acessada, e uma referência (receiver) para o Proxy. Agora, antes de ser exibidos os valores das propriedades, os textos devem ser exibidos.

No navegador, vamos obter o resultado esperado:

a propriedade foi interceptada

Porém, os valores das propriedades resultaram em undefined. Isto ocorreu, porque quando executamos uma armadilha (trap, traduzido para o inglês), é necessário informar qual será o valor retornado após a interceptação da propriedade de leitura. Adicionaremos o return:

   <script>

       let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {

           get: function(target, prop, receiver) {

                 console.log(`a propriedade "${prop}" foi interceptada`);
                 return 'Flávio';
           }
       });
       console.log(negociacao.quantidade);
       console.log(negociacao.valor);
 </script>
Veja o que será exibido no Console:

return Flavio

Quando acessamos negociacao.valor, ele retorna Flávio. Mas não é o que queremos... Queremos o valor verdadeiramente guardado. Para isto, vamos pedir auxilio para a API de Reflect.get() e os três parâmetros. Nós queremos executar uma operação de leitura.

get: function(target, prop, receiver) {

     console.log(`a propriedade "${prop}" foi interceptada`);
     return Reflect.get(target, prop, receiver);
}
No navegador, ele imprimirá o texto e os valores das propriedades.

mensagens no console

Mas por que a mensagem foi impressa duas vezes, com um pequena diferença. Isto ocorre, porque no arquivo Negociacao.js, ele irá interceptar para quantidade e _quantidade.

get quantidade() {

    return this._quantidade;
}

get valor() {
  return this._valor;
}
O mesmo acontecerá com valor e _valor. Então nosso código funciona.

Nós vimos como executar um código, antes da leitura das propriedades do objeto. Mas para resolvermos o problema da atualização automática da View - lembrando que não queremos atualizá-la enquanto estivermos lendo um dado. Mas este não é o nosso foco. O objetivo é encontrar uma forma de executar o código quando uma propriedade é modificada. Veremos mais adiante.
*****************
05-Construindo armadilhas de escrita

*******Não estamos interessados em executar um código quando ocorrer a leitura, e sim, quando acontecer a modificação de alguma propriedade. Em seguida, faremos pequenas alterações no arquivo index.html. Atualmente, o get está assim:

<script>

    let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {
    get: function(target, prop, receiver) {

         console.log(`a propriedade "${prop}" foi interceptada`);
         return Reflect.get(target, prop, receiver);
    }
    });
    negociacao.quantidade = 10;
    negociacao.valor = 100;
</script>
Mas esse código ainda não funcionará, porque quantidade e valor em Negociacao.js são getters. Por isso, não podemos fazer uma atribuição, considerando que são apenas leitura e não podem ser alterados. De volta ao index.html, faremos uma "licença poética" e acessaremos diretamente as propriedades privates.

negociacao._quantidade = 10;
negociacao._valor = 100;
Vamos desrespeitar a convenção da nossa propriedade, mas com isso, poderemos disparar a nossa armadilha.

A primeira coisa que devemos fazer para executar uma armadilha quando estou atribuindo, é alterarmos de get para set. Também adicionaremos outro parâmetro: value.

<script>

    let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {
    set: function(target, prop, value, receiver) {

         console.log(`a propriedade "${prop}" foi interceptada`);
         return Reflect.set(target, prop, value, receiver);
    });
    negociacao._quantidade = 10;
    negociacao._valor = 100;
</script>
Quando atribuímos 10 para _quantidade, a função no set será chamada e retornará os quatro parâmetros. No console.log() queremos exibir o valor atual e o que será exibido depois.

<script>

    let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {
    set: function(target, prop, value, receiver) {

         console.log(`novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
}
    });
    negociacao._quantidade = 10;
    negociacao._valor = 100;
</script>
Com o value no console.log exibiremos o valor que queremos atribuir.

novo valor

A armadilha foi executada e os valores exibidos estão corretos. Mas também queremos mostrar o valor antigo, para isto, só teremos acesso ao target que é o objeto Negociacao. Vamos tentar usar o seguinte código no console.log:

console.log(`${target.quantidade} novo valor: ${value}`);
return Reflect.set(target, prop, value, receiver);
No Console. veremos os seguintes valores:

target no Console

Para quantidade, o valor antigo ficou igual a 1, e o mesmo para o valor. A explicação é que a linha do console.log está sendo executada também quando tentamos descobrir o negociacao._valor. Então, o valor de quantidade deve ser igual ao valor de prop. Mas como conseguiremos fazer a property dinâmica? Não temos a opção de usar ${target.prop}, mas podemos usar um recurso do JS, podemos passar ${target[prop]}. O trecho do código ficará assim:

<script>

  let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {
    set: function(target, prop, value, receiver) {

         console.log(`${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
}
    });
    negociacao._quantidade = 10;
    negociacao._valor = 100;
</script>
O prop junto com o target será o _quantidade e conseguirá ler o valor. Em seguida, adicionaremos valor anterior: à linha.

<script>

  let negociacao = new Proxy(new Negociacao(new Date(), 2, 100), {
    set: function(target, prop, value, receiver) {

         console.log(`valor anterior: ${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
}
    });
    negociacao._quantidade = 10;
    negociacao._valor = 200;
</script>
No Console, veremos os seguintes valores:

valor anterior no Console

Com isso, resolvemos o problema da execução de um código que só atualizará a View quando _quantidade e _valor forem alterados.
**********
06-Método que não altera propriedade
Agora que ensaiamos com o negociacao, vamos nos focar em criar a Proxy no modelo do ListaNegociacoes. No index.html, vamos substituir no código negociacao por ListaNegociacoes. Mudaremos também o console.log pelo lista.adiciona().

<script>

  let lista = new Proxy(new ListaNegociacoes(), {
    set: function(target, prop, value, receiver) {

         console.log(`valor anterior: ${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
    }
  });
  lista.adiciona(new Negociacao(new Date(), 1, 100));
</script>
Se tentarmos executar o código como está, nada acontecerá. Nós já entendemos que devemos usar o get quando estamos olhando uma propriedade e o set quando queremos modificar uma propriedade. No entanto, a armadilha não foi disparada no lista.adiciona(). Sabe por que isto aconteceu? O adiciona() é um método, que no arquivo ListaNegociacoes.js, pede internamente para negociacoes fazer o push().

adiciona(negociacao) {

    this._negociacoes.push(negociacao);

}
Porém, nós não atribuímos valores para uma propriedade, sendo assim, o set não será chamado. Teremos que encontrar uma solução, porque tanto o método adiciona() como o esvazia() terá este tipo de problema - ainda que o segundo, atribua um valor para negociacoes. Vamos fazer um teste, adicionando o esvazia(), no index.html:

<script>

  let lista = new Proxy(new ListaNegociacoes(), {
    set: function(target, prop, value, receiver) {

         console.log(`valor anterior: ${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
    }
  });
  lista.adiciona(new Negociacao(new Date(), 1, 100));
  lista.esvazia();
</script>
esvazia no Console

O esvazia() executou o código, porque o valor anterior: era um objeto e o novo valor: ficou vazio. Nós queremos que o interceptador dispare com o lista.adiciona. No entanto, por padrão, não conseguiremos fazer isto usando o Proxy do ES6.

Mas não vamos ignorar o que vimos até aqui.
*****************
07-Uma solução para método que não altera propriedade
Nós não vamos nos abdicar de utilizar o Proxy. Mas a primeira tentativa de solucionar o assunto será com uma "gambiarra". Em ListaNegociacoes, vamos forçar uma atribuição em this._negociacoes.

class ListaNegociacoes {

    constructor() {
        this._negociacoes = [];
    }

    adiciona(negociacao) {

        this._negociacoes = [].concat(this._negociacoes, negociacao);
        // this._negociacoes.push(negociacao);
    }
Com o concat(), podemos passar tanto o array quanto o elemento, além de outros parâmetros - e todos serão concatenados. Como forçamos uma atribuição, quando recarregamos a página, veremos no Console:


_negociacoes => valor anterior: , novo valor: [object Object]
_negociacoes => valor anterior: está saindo em branco, porque o valor anterior é um array vazio. O novo valor tem o object porque se trata do novo array.

É possível resolver com esta gambiarra, mas não será esta a solução que utilizaremos. Imagine que fazemos um loop de 100 negociações, se nosso código ficar assim, a cada negociação adicionada, teremos que criar um nova lista e reatribuir para ListaNegociacoes. Teríamos problema com a performance. Apesar de termos feito o mesmo no get:

get negociacoes() {

    return [].concat(this._negociacoes);
}
Mas neste caso, quem pede a lista de negociação não fará solicitação infinitas vezes seguidas. É possível varrer a lista diversas vezes, sem chamar get sempre. O mesmo não ocorre com adiciona(). Se queremos fazer uma operação em lote, usaremos o adiciona(). Precisamos descobrir uma outra estratégia - mais de "cangaceiro" do que de "ninja". Ao identificarmos o adiciona() como um método no index.html, queremos executar a armadilha.

<script>

  let lista = new Proxy(new ListaNegociacoes(), {
    set: function(target, prop, value, receiver) {

         console.log(`valor anterior: ${target[prop]} novo valor: ${value}`);
         return Reflect.set(target, prop, value, receiver);
    }});
    lista.adiciona(new Negociacao(new Negociacao(new Date(), 1, 100));
</script>
Não há uma maneira de interceptarmos o método com o Proxy. Quando chamamos um método no JavaScript, por exemplo o adiciona(), ele fará um get na função e depois, executará o Reflect.apply. Então, será passado o valor para a função dentro do parênteses. Mas o set não está incluso no método.

A seguir, resolveremos o assunto.

*****************
08-Construindo armadilhas para métodos
Vamos procurar a solução "cangaceira" para resolvermos o nosso problema. Lembra que anteriormente falamos que quando chamamos uma função, o JavaScript fará um getter e após a leitura, será enviada um apply. Teremos que substituir o set para o get:

<script>

  let lista = new Proxy(new ListaNegociacoes(), {
    get: function(target, prop, receiver) {

    }
  });
    lista.adiciona(new Negociacao(new Date(), 1, 100));
</script>
Observe que o get não receberá o value. A questão é: quando o getter for executado, queremos perguntar se ele está na lista de métodos que queremos interceptar. Para isto, adicionaremos um if para o get.

get: function(target, prop, receiver) {
    if(['adiciona', 'esvazia'].includes(prop) && typeof(target[prop]) == typeof(Function)) {

    }
}
Criaremos uma condição que testará se o método incluído é o adiciona() ou o esvazia(), que tem ou não props (uma novidade do ES6 é podermos fazer este tipo de pergunta para o array) e se é uma função. Para testarmos esta última parte, usamos o typeof[], que recebeu a propriedade do target. Se isso é uma função ou método, o typeof será o parâmetro. Vamos verificar se isso é o typeof de Function.

Se viermos no Console e digitarmos Function, veremos que existe uma função chamada function em JavaScript:

Function
function Function() { [native code] }
Se a propriedade corresponde a adiciona() ou esvazia() e é uma função, faremos algo a respeito. Caso contrário, faremos a leitura de um get padrão.

<script>

  let lista = new Proxy(new ListaNegociacoes(), {
    get: function(target, prop, receiver) {
        if(['adiciona', 'esvazia'].includes(prop) && typeof(target[prop]) == typeof(Function)) {

        }
        return Reflect.get(target, prop, receiver);
    }
    });
      lista.adiciona(new Negociacao(new Date(), 1, 100));
 </script>
Se está ou não na nossa lista, teremos o retorno do valor, considerando que estamos fazendo um get. Adicionaremos o lista._negociacoes:

lista.adiciona(new Negociacao(new Date(), 1, 100))
lista._negociacoes;
Com isso, já faremos um get. E o que iremos devolver? Se a propriedade está na lista (de adiciona() ou esvazia()) e é uma função, em vez de retornarmos um valor direto, retornaremos uma função.

Tem que ser function para ter o this dinâmico. Não pode ser arrow function que possui escopo léxico.

A função não pode ser arrow function, porque ela deve ter um contexto dinâmico, e dentro, substituiremos o método por outro que tem a armadilha - porém, a substituição será feita no Proxy. No entanto, este não nos permite colocar uma armadilha para método, encontraremos um forma de que ao cairmos no método substituiremos por outro do Proxy. Falamos do return.

<script>

  let lista = new Proxy(new ListaNegociacoes(), {

    get: function(target, prop, receiver) {
        if(['adiciona', 'esvazia'].includes(prop) && typeof(target[prop]) == typeof(Function)) {
        return function() {
console.log(`a propriedade "${prop}" foi interceptada`);
            }
        }
        return Reflect.get(target, prop, receiver);
    });
      lista.adiciona(new Negociacao(new Date(), 1, 100));
    lista._negociacoes
</script>
Agora, teremos que fazer o método receber os parâmetros que ele está recebendo aqui. Como estamos substituindo e retornando a função, substituiremos o adiciona(), quando este método for chamado estaremos chamando na verdade, o console.log. No entanto, precisamos fazer com que o adiciona() receba o parâmetro original dele:

lista.adiciona(new Negociacao(new Date(), 1, 100));
Como a função no if, substituirá o método adiciona(), existe um objeto implícito chamado arguments que dá acesso a todos os parâmetros passados para a função. A seguir, usaremos o Reflect.apply(), e chamaremos uma função.

if(['adiciona', 'esvazia'].includes(prop) && typeof(target[prop]) == typeof(Function)) {
   return function() {

        console.log(`a propriedade "${prop}" foi interceptada`);
        Reflect.apply(target[prop], target, arguments);
 }
Vamos entender o que foi feito até aqui... Ao fazemos métodos e funções o Proxy sempre entende que é um get, quando fazemos o lista.adiciona(). No get, perguntaremos "você está na lista de itens que quero interceptar? E você é uma função?" Caso a resposta seja positiva, iremos substituir o adiciona()ou o esvazia() no Proxy. A substituição será feita por uma nova função. Então, ao ser chamada, a função imprimirá o conteúdo do console.log, porque a função lembrará do contexto de execução e quem é prop. Com o Reflect.apply(), faremos a função receber os parâmetros dela. O arguments é uma variável implícita que dá acesso a todos os parâmetros da função quando esta é chamada. Foi uma maneira de via get ter acesso aos parâmetros da função.

Ao recarregarmos a página no navegador, veremos a confirmação de que foi interceptado adiciona.

interceptado adiciona

O mesmo ocorrerá se chamarmos o lista.esvazia():

lista.adiciona(new Negociacao(new Date(), 1, 100));
lista.esvazia();
No Console, veremos o interceptado esvazia.

interceptado esvazia

Desta forma, encontramos uma maneira de escolher qual método queremos interceptar e executar o código. Antes de continuarmos, faremos um pequeno ajuste no get:


get(target, prop, receiver) {
    if(['adiciona', 'esvazia'].includes(prop) && typeof(target[prop]) == typeof(Function)) {

        return function() {

          console.log(`a propriedade "${prop}" foi interceptada`);
          Reflect.apply(target[prop], target, arguments);
        }

    }
    return Reflect.get(target, prop, receiver);

  }
Agora, precisamos substituir o trecho de código no Controller. Vamos aplicar efetivamente no nosso sistema.

*****************
09-Aplicando a solução no NegociacaoController
Você pode estar pensando "será que existe uma maneira mais fácil de fazer o que queremos?". A resposta é sim. Conheceremos a forma mais simples, depois. Primeiramente, vamos levar a estratégia criada no index.html, para o NegociacoesController.

Abaixo dos inputs do constructor(), adicionaremos o seguinte trecho do código:

this._listaNegociacoes = new Proxy(new ListaNegociacoes(), {

    get(target, prop, receiver) {

        if(['adiciona', 'esvazia'].includes(prop) && typeof(target[prop]) == typeof(Function)) {

            return function(){

              console.log(`método '${prop}' interceptado`);

             Reflect.apply(target[prop], target, arguments);

              this._negociacoesView.update(target);

            }
     }

     return Reflect.get(target, prop, receiver);
  }
});
Passamos o model como parâmetro do update(), ao adicionarmos o target. No entanto, o nosso código terá problema porque o this não será o controller, nem se usássemos uma arrow function. Por isso, vamos inserir uma variável chamada self. que receberá this.

let self = this;

this._listaNegociacoes = new Proxy(new ListaNegociacoes(), {

    get(target, prop, receiver) {

        if(['adiciona', 'esvazia'].includes(prop) && typeof(target[prop]) == typeof(Function)) {

            return function(){

              console.log(`método '${prop}' interceptado`);

             Reflect.apply(target[prop], target, arguments);

              self._negociacoesView.update(target);

            }
     }

     return Reflect.get(target, prop, receiver);
  }
});
Faremos um teste a seguir, mas faltou um detalhe: só podemos chamar a atualização da View, depois de aplicar o valor depois do target. Vamos testar no navegador, e veremos que o método foi interceptado.

inteceptando o adiciona

Então, o código está funcionando. Nós tivemos que aprender a lidar com as particularidades do Proxy, e assim, não "sujamos" o nosso modelo. Mais adiante veremos como esconder a complexidade de criação do Proxy. O nosso código ficou muito verboso. Inclusive, não vamos inserir um Proxy para MensagemView, mas seria um erro repetir todo este código novamente.

Por enquanto, só brincaremos com o listaNegociacoes. A seguir, vamos aplicar um outro padrão de projeto que nos ajudará bastante na criação de um Proxy. Mas a forma de se trabalhar internamente já foi apresentada.
*****************
10-Truque com ES2015
Sabemos que podemos declarar um objeto JavaScript com propriedades que podem armazenar funções (uma função que pertence ao objeto podemos chamar de método). Por exemplo:

var objeto = {
    exibeMensagem : function(){
        console.log("Olá");
    }
};
Neste capítulo, aprendemos um modo de reescrever este mesmo código acima, só que de modo mais sucinto. Você consegue lembrar como era?

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Com o ES2015 , podemos reescrever aquele código da seguinte maneira:

var objeto = {
    exibeMensagem() {
        console.log("Olá");
    }
}
Assim conseguimos enxugar um pouco mais o código, aproveitando essa feature do ES2015.
*****************
11-Exercicio - Vantagens do Proxy
Sobre o padrão de projeto Proxy, podemos afirmar que:

1) Ele é útil quando queremos deixar os nossos modelos mais limpos, sem várias armadilhas penduradas nos seus métodos. Por exemplo, evitando pendurar um código de infraestrutura em nossos modelos.

2) Ele modifica o objeto original, enxertando nele todo aquele código que desejamos executar.

3) Ele serve como um placeholder de um objeto real, servindo como uma interface para o objeto que queremos interagir, nos permitindo controlar o acesso às suas propriedades e métodos.

Alternativa correta
Apenas as afirmativas 1 e 2 são corretas.


Quando usamos o Proxy, não modificamos o objeto real.

Alternativa correta
Apenas a afirmativa 1 é correta.


Alternativa correta
Apenas as afirmativas 2 e 3 são corretas.


Alternativa correta
Apenas as afirmativas 1 e 3 são corretas.


O padrão de projeto Proxy nada mais é do que um objeto "falso", "mentiroso", que envolve e encapsula o objeto real que queremos interagir. É como se fosse uma interface, entre o objeto real e o resto do código. Conseguimos assim controlar o acesso aos seus atributos e métodos. Nele também podemos pendurar códigos que não cabem de estar alocados nos nossos modelos, mas que necessitam ser executados no caso de uma alteração ou atualização do mesmo.
*****************
12-Exercicio - Target, prop ou receiver ?
Vejamos o seguinte exemplo:

let pessoa = {
    nome: 'Flávio'    
}

let pessoaProxy = new Proxy(pessoa, {
    get(target, prop, receiver) {
         //...
    }
});
Como segundo argumento de um proxy, passamos um handler, que é um objeto JavaScript que contém as armadilhas (traps) do nosso Proxy. Neste objeto, podemos criar uma propriedade get e passar para ela uma função com 3 parâmetros.

get(target, prop, receiver) {
    //...
}
Sobre estes 3 parâmetros, qual das afirmativas abaixo é completamente verdadeira?

Alternativa correta
O target é o objeto real, que é encapsulado pelo proxy.

O prop é a propriedade que está sendo lida.

O receiver é uma referência ao próprio proxy.


O target é o objeto real que é encapsulado pela proxy. É este objeto que não queremos "sujar" com armadilhas ou qualquer código que não diga respeito ao modelo.

O prop é a propriedade em si, que está sendo lida naquele momento.

O receiver é a referência ao próprio proxy. É na configuração do handler do Proxy que colocamos armadilhas.

Alternativa correta
O target é a propriedade alvo do proxy, que ele vai ler.

O prop é o objeto real encapsulado pelo proxy.

O receiver é uma referência ao próprio proxy.


Alternativa correta
O target é uma referência ao proxy.

O prop é a propriedade que está sendo lida.

O receiver é a referência ao objeto que está sendo encapsulado pelo proxy.
*****************
13-O Primeiro proxy a gente nunca esquece
Aprendemos neste capítulo a criar proxies, que nada mais são do que objetos mentirosos que encapsulam outros, mais notadamente objetos do nosso modelo. Pense em proxies como "cascas" que envolvem objetos. Dentro desse contexto, só podemos "tocar" os objetos encapsulados passando pelo proxy. É justamente essa característica que torna o uso desse padrão de projeto tão poderoso.

Temos o seguinte objeto literal (aquele criado com chaves):

let funcionario = {email: 'abc@abc.com'};
Crie um proxy para este objeto, exibindo no console a mensagem "Armadilha aqui", toda vez que a propriedade email for lida.

VER OPINIÃO DO INSTRUTOR
Opinião do instrutor

Uma implementação possível é:

let funcionario = {email: 'abc@abc.com'};
let funcionarioProxy = new Proxy(funcionario,  {

    get(target, prop, receiver) {
        console.log('Armadilha aqui!');
        return Reflect.get(target, prop, receiver);
    }

});
console.log(funcionarioProxy.email);
Veja que a instrução a seguir é muito importante: return Reflect.get(target, prop, receiver). É ela que efetivamente realiza a operação no objeto real. Aliás, poderíamos ter conseguido o mesmo resultado da seguinte maneira:

let funcionario = {email: 'abc@abc.com'};
let funcionarioProxy = new Proxy(funcionario,  {

    get(target, prop, receiver) {
        console.log('Armadilha aqui!');
        return target[prop];
    }

});
console.log(funcionarioProxy.email);
Há uma ligeira diferença entre as duas. Na primeira, get retorna uma função que é invocada para obter o valor da propriedade original, na segunda, o valor é retornado diretamente. Entenda que Reflect.get cria algo semelhante a uma getter. Você ainda lembra que um getter é uma espécie de função?
*****************
14-Proxy modificando retorno de método
Temos mais uma vez o seguinte objeto literal:

let funcionario = {email: 'abc@abc.com'};
Desta vez, imprima a mensagem "Armadilha aqui!", além disso, modifique o retorno do getter, fazendo-o retornar o email, começando e terminando com dois asteriscos. Por exemplo, se fizermos:

console.log(funcionario.email);
Queremos que saia no console:

**abc@abc.com**
VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Temos a seguinte implementação. Veja que ele concatena os asteriscos com o retorno de Reflect.get, aquele que efetivamente executa a operação de leitura no objeto real. Ou seja, nosso proxy executa a leitura no objeto original e devolve para quem chamou o próprio proxy o valor concatenado com asteriscos:

let funcionario = {email: 'abc@abc.com'};
let funcionarioProxy = new Proxy(funcionario,  {

    get(target, prop, receiver) {
        console.log('Armadilha aqui!');
        return '**' + Reflect.get(target, prop, receiver) + '**' ;        
    }

});
console.log(funcionarioProxy.email);
Agora, podemos evitar a declaração da variável funcionarioProxy desta forma:

funcionario = new Proxy({email: 'abc@abc.com'},  {

    get(target, prop, receiver) {
        console.log('Armadilha aqui!');
        return '**' + Reflect.get(target, prop, receiver) + '**' ;        
    }

});
console.log(funcionario.email);
*****************
15-Proxy e peculiaridade com getters
Temos a seguinte classe:

class Funcionario {

    constructor(email) {
        this._email = email;
    }

    get email() {
        return this._email;
    }

    set email(email) {
        this._email = email;
    }
}
Crie um proxy a partir dessa classe, que exiba no console "Armadilha aqui" toda vez que qualquer propriedade da classe for lida.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Segue uma implementação:

let funcionario = new Proxy(new Funcionario('abc@abc.com'), {

    get(target, prop, receiver) {
        console.log('Armadilha aqui!');

        return Reflect.get(target, prop, receiver);
    }

});

console.log(funcionario.email);
Veja que teremos três mensagens de log no console. As duas primeiras Armadilha aqui! e logo depois o email do usuário. Mas qual a razão dele escrever a primeira mensagem duas vezes?

É que email é um getter. Nosso proxy irá executar seu código quando o getter for chamado e também para a propriedade _email, que é acessada pelo getter. Inclusive podemos deixar isso ainda mais claro, exibindo em nosso proxy o nome da propriedade:

let funcionario = new Proxy(new Funcionario('abc@abc.com'), {

    get(target, prop, receiver) {
        console.log('Armadilha aqui!');
        console.log(prop);
        return Reflect.get(target, prop, receiver);
    }

});

console.log(funcionario.email);
*****************
16-Mais um proxy, agora para lidar escrita!
Olha o funcionário no formato literal novamente aí gente:

let funcionario = {email: 'abc@abc.com'};
Crie um proxy que exibe no console o valor da propriedade antes dela ser alterada e o valor novo.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Uma implementação possível:

let funcionario = {email: 'abc@abc.com'};
let funcionarioProxy = new Proxy(funcionario,  {

    set(target, prop, value, receiver) {
        console.log(`Valor antigo ${target[prop]}, valor atual: ${value}`);
        return Reflect.set(target, prop, value, receiver);
    }

});
funcionarioProxy.email = 'aaa@aaa.com';
Veja que usamos set no handler passado para o proxy. Além disso, muito cuidado que quando usamos set, a função deve receber quatro parâmetros e não três, como no caso do get.

Poderíamos conseguir o mesmo resultado desta forma:

let funcionario = {email: 'abc@abc.com'};
let funcionarioProxy = new Proxy(funcionario,  {

    set(target, prop, value, receiver) {
        console.log(`Valor antigo ${target[prop]}, valor atual: ${value}`);
        target[prop] = value;
    }

});
funcionarioProxy.email = 'aaa@aaa.com';
A diferença é que essa última solução altera diretamente o valor o objeto encapsulado. A primeira forma, com Reflect.set sempre deve retornar um valor, que é uma função que será chamada para realizar a operação de atribuição. Por enquanto, podemos usar uma ou outra forma que o resultado será o mesmo.
*****************
17-Um esclarecimento extra é sempre bom!
Durante o vídeo, para explicar como executar uma armadilha quando uma propriedade for modificada, eu usei como exemplo uma instância da classe Negociacao. Contudo, nossa classe era imutável porque usamos Object.freeze. Sendo assim, o seguinte código não teria efeito:

n1._quantidade = 10;
n1._valor = 10;
E realmente não tem, mas ainda sim a armadilha definida no proxy será executada! Resumindo a moral da história: armadilhas serão disparadas mesmo se tentarmos modificar uma propriedade congelada de um objeto, ainda que ele não seja modificado.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

São detalhes que fazem diferença no final!
*****************
18-Proxy e peculiaridade com setters
Mais uma vez, temos a nossa classe Funcionario:

class Funcionario {

    constructor(email) {
        this._email = email;
    }

    get email() {
        return this._email;
    }

    set email(email) {
        this._email = email;
    }
}
Crie um proxy que exiba no console o valor da propriedade antes de ela ser alterada e o valor novo. Inclusive, exiba também o nome da propriedade que está sendo modificada.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Uma implementação possível:

let funcionario= new Proxy(new Funcionario('abc@abc.com'),  {

    set(target, prop, value, receiver) {
        console.log(prop); // imprimindo a propriedade que está sendo alterada
        console.log(`Valor antigo ${target[prop]}, valor atual: ${value}`);
        return Reflect.set(target, prop, value, receiver);
    }
});

funcionario.email = 'aaa@aaa.com';
Veja que usamos set no handler passado para o proxy. Além disso, muito cuidado que quando usamos set, a função deve receber quatro parâmetros e não três, como no caso do get.

Reparou que a mensagem do proxy é exibida duas vezes? É que email é um setter. Nosso proxy irá executar seu código quando o setter for chamado e também para a propriedade _email, que é modificada pelo setter.
*****************
19-Arguments
Aprendemos lá no jardim de infância em JavaScript a passar parâmetros para funções e métodos. Vejamos um exemplo:

function exibeNomeCompleto(nome, sobrenome) {

  alert(`${nome} ${sobrenome}`);
}

exibeNomeCompleto('Flávio', 'Almeida');
Contudo, podemos conseguir o mesmo resultado sem passar parâmetros para a função:

function exibeNomeCompleto() {

  alert(`${arguments[0]} ${arguments[1]}`);
}

exibeNomeCompleto('Flávio', 'Almeida');
Por mais que nossa função não receba parâmetros, podemos ter acesso aos parâmetros passados com arguments. É uma variável implícita que nos dá acesso a todos os parâmetros passados para a função ou método. É claro que a primeira forma, nomear os parâmetros da função, é menos verbosa e mais legível. Mas há muitos hacks em JavaScript que podem fazer uso de arguments.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Inclusive em nossa solução de proxy para interceptar métodos tivemos que recorrer ao arguments!
*****************
20-Exercicio - Proxy Intercepta métodos?
Temos a seguinte declaração de classe:

class Pessoa {

    constructor(nome) {
        this._nome = nome;
    }

    get nome() {
        return this._nome;
    }

    set nome(nome) {
        this._nome = nome;
    }

    grita(frase) {
            return `${this._nome} grita ${frase}`;
    }
}
Criando uma instância e chamando o método grita:

let pessoa = new Pessoa('Barney');
pessoa.grita('Olá');
E se quisermos interceptar a chamada do método grita? A má notícia é que toda proxy criada, por padrão, não esta preparada para interceptar métodos (getters e setters são exceções a este problema). Essa limitação ocorre porque sempre que um método de um objeto (que não deixa de ser uma propriedade que armazena uma função) é chamado, primeiro é realizado uma operação de leitura (get, do nosso handler da proxy) e depois os parâmetros são passados através de Reflect.apply. O problema é que, como o método é interceptado pelo get do handler passado para a proxy, não temos acesso aos seus parâmetros. E agora?

Uma solução é implementar o seguinte código:

let pessoa = new Proxy(new Pessoa('Barney'), {

        get(target, prop, receiver) {
            if(prop == 'grita' && typeof(target[prop]) == typeof(Function)) {
         // essa função retornada irá substituir o método 'grita' no proxy!!! Ou seja, estamos usando o handler do proxy para modificar o próprio proxy, que loucura!
                return function() {
                    console.log(`Método chamado: ${prop}`);    
                    // Quando usarmos Reflect.apply, Reflect.get e Reflect.set precisamos retornar o resultado da operação com return
                    // arguments é uma variável implícita que dá acesso à todos os parâmetros recebidos pelo método/função
                    return Reflect.apply(target[prop], target, arguments);       
                }
            }
            // só executa se não for função
            return Reflect.get(target, prop, receiver);
        }
    });

   pessoa.grita('Olá');
No código acima, verificamos se a propriedade que está sendo acessada é uma função através de typeof(target[prop]) == typeof(Function)). Se for, trocaremos o valor da propriedade (nosso método) por outra função, e, essa sim, executa nosso código antes de o método ser executado.

Sobre o código anterior, qual o papel de arguments?

Alternativa correta
Não tem papel algum, ela não foi declarada no código e por isso teremos um erro.


Alternativa correta
A variável arguments é uma variável implícita que pode ser acessada em métodos ou funções. Ele se comporta como um array onde cada posição equivale ao parâmetro que foi passado para o método ou função. Existe desde o ES5!


Alternativa correta!

Alternativa correta
A variável arguments é uma variável implícita que pode ser acessada em métodos ou funções. Ele se comporta como um array em que cada posição equivale ao parâmetro que foi passado para o método ou função. Esse recurso foi adotado a partir do ES6.


Na verdade, esse recurso existe desde o ES5!

Vejamos um exemplo:

function geraNomeCompleto() {

    alert(`Nome completo: ${arguments[0]} ${arguments[1]}`);
}

geraNomeCompleto('Flávio', 'Almeida');
Apesar de a função não receber parâmetros e estarmos passando dois, não haverá qualquer erro. Inclusive, dentro da função usamos a variável implícita arguments para termos acesso ao primeiro e ao segundo parâmetros passado para a função.

Veja que no código do nosso proxy, como estamos substituindo o método grita por outra função e não sabemos se ela recebe ou não um parâmetro, usamos arguments na função substituta para chamarmos Reflect.apply, garantindo assim que a nova função, quando executada, receba corretamente seus parâmetros logo após executarmos o código que desejarmos (armadilha).
*****************
21-
*****************