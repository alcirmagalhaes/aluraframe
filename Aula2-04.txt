Aula2-04
01-Serviços disponíveis
Você pode fazer o download completo do projeto até aqui e continuar seus estudos.

Nós aplicamos diversos recursos da linguagem JavaScript, padrões de projetos e outros... Mas para a aplicação ficar completa, além de incluir negociações, queremos poder importar negociações de serviços na web. Alguns bancos oferecem a possibilidade de obter as negociações da semana atual e da anterior. Nós já disponibilizamos no projeto uma pasta chamada server. No primeiro exercício obrigatório do curso, você encontrará toda a infraestrutura que você precisa para subir o servidor.

Com a infraestrutura instalada, entraremos na pasta Desktop. Para isto, você deve ter um conhecimento básico sobre o uso do Terminal para entrar nesta pasta.

No curso, usaremos o Terminal do Mac. Mas se você é usuário de Windows e não domina o prompt de comando, nossa recomendação é que faça o curso Windows: Introdução ao Prompt. Neste ponto do curso, assumiremos que você já sabe interagir com seu Terminal.

Para levantar o servidor, abriremos nosso Terminal e depois, entraremos na pasta aluraframe/server. É a primeira vez que interagiremos com essa pasta, mas basicamente, você só precisa rodar o comando no seu terminal:

> npm start
Caso esse comando de erro use esse:

> node server.js
Isto fará com que um servidor rode e seja acessível por meio do endereço http://localhost:3000. Acesse esse endereço e automaticamente a página index.html será carregada. Se preferir, pode digitar http://localhost:3000/index.html.

A única mudança até agora é não acessar mais index.html do sistema de arquivos da plataforma, mas por intermédio do servidor. Certifique-se que o servidor esteja funcionando antes de continuar. O nosso servidor além de servir o index.html, possui também alguns serviços.

Geralmente, quem publica serviços na web disponibiliza uma URL de acesso. O nosso servidor publicará três:

negociacoes/semana
negociacoes/anterior
negociacoes/retrasada
Ao acessarmos o endereço http://localhost:3000/negociacoes/semana, sairemos da página index.html e, na tela, será exibida uma estrutura de dados no formato JSON (JavaScript Object Notation):

dados no formato texto

No entanto, não queremos exibir o arquivo JSON na tela e buscar os dados por meio de URL. Nosso objetivo é que ao clicarmos no botão Importar Negociações, seja feita a busca dos dados usando JavaScript e depois, os dados sejam inseridos na tabela de negociações. Desta forma, a tabela será automaticamente atualizada.

Nós temos todo mecanismo de Data binding, então, basta incluirmos os dados na tabela. A seguir, nós iremos relembrar como acessamos endereços na Web por meio do JavaSript, usando AJAX. Faremos uma revisão sobre o assunto e assim, entender o problema que desejamos resolver e qual recurso avançado pode nos ajudar em programação assíncrona .

O foco do curso é sobre como consumimos os dados publicados pelos servidores usando o JavaScript. Se você deseja aprender como servidores são criados e como eles disponibilizam esse tipo de dados, nossa sugestão é que você faça o curso de MEAN.
***********************
02-Requisições Ajax com o objeto XMLHttpRequest
Nosso objetivo é que ao clicarmos em "Importar Negociações", seja chamada uma ação na controller. Buscaremos o trecho referente no código do index.html.

<div class="text-center">
    <button class="btn btn-primary text-center" type="button">
        Importar Negociações
    </button>
    <button class="btn btn-primary text-center" type="button">
        Apagar
    </button>
</div>
Dentro da tag <button>, vamos adicionar o onclick.

<div class="text-center">
    <button onclick="negociacaoController.importaNegociacoes()" class="btn btn-primary text-center" type="button">
        Importar Negociações
    </button>
    <button class="btn btn-primary text-center" type="button">
        Apagar
    </button>
</div>
Nós chamamos o importaNegociacoes(), que será adicionado no NegociacaoController.js, logo abaixo do método adiciona().

importaNegociacoes() {

    alert('Importando negociações');
}
Desta forma, poderemos ver se tudo está funcionando bem. Se recarregarmos a página no navegador e depois, clicarmos em "Importar Negociações", o alert será exibido.

alert no navegador

Agora, realizaremos requisições assíncronas para o servidor usando o objeto especial existente no JavaScript. Substituiremos o alert pela variável xhr.

importaNegociacoes() {
    let xhr = new XMLHttpRequest();
}
A variável é uma instância de new XMLHttpRequest(). É comum vermos desenvolvedores realizarem o AJAX utilizando apenas jQuery, mas nós faremos manualmente. Pediremos para xhr abrir um endereço e especificaremos qual método será utilizado:

importaNegociacoes() {
    let xhr = new XMLHttpRequest();
    xhr.open('GET', 'negociacoes/semana');
}
O método open() recebeu dois parâmetros: o primeiro especifica o tipo de requisição a ser realizada(GET), o segundo é o endereço (negociacoes/semana). Se trabalhássemos com outro endereço do serviço na Web, seria necessário colocar o endereço completo. Como estamos trabalhando localmente, só adicionamos negociacoes/semana.

Mas até aqui, a requisição não será executada. Para que a ação seja executada, usaremos o método send().

importaNegociacoes() {
    let xhr = new XMLHttpRequest();

    /* configurações */
    xhr.open('GET', 'negociacoes/semana');

    /* executa */
    xhr.send();
}
A requisição ainda não está pronta. Será preciso fazer várias configuração antes de realizar o envio. É o que faremos a seguir: primeiramente, precisamos entender que toda requisição AJAX passa por estados - um deles nos dará os dados retornados do servidor. Por isso, precisamos interagir com esses estados e especificar que adicionaremos os dados de um deles no nosso model. O xhr tem a propriedade onreadystatechange, depois, passaremos uma arrow funtion que será chamada sempre que o estado do xhr for modificado.

Então, quais são os estados possíveis de um requisição AJAX? Listaremos abaixo os estados:

0: requisição ainda não iniciada

1: conexão com o servidor estabelecida

2: requisição recebida

3: processando requisição

4: requisição está concluída e a resposta está pronta

O estado 4 é o que mais nos interessa, porque é nele que temos acesso à resposta enviada pelo servidor. Precisamos encontrar um forma de descobrir em qual estado estamos quando o onreadystatechange é chamado. Para isto, adicionaremos um if:

importaNegociacoes() {

    let xhr = new XMLHttpRequest();
    xhr.open('GET', 'negociacoes/semana');
    xhr.onreadystatechange = () => {
        if(xhr.readyState == 4) {

        }
    };
    xhr.send();
}
Se o estado for igual a 4, buscaremos os dados do servidor. Este é o estado que a requisição está concluída e a resposta está pronta, mas não podemos confiar no mesmo, porque pode ocorrer algum erro no servidor e ainda assim, a resposta será válida. É comum o servidor lidar com estados da requisição. Então, só teremos certeza de que os dados chegaram se o xhr.status for igual a 200 (status code genérico).

if(xhr.status == 200) {
}
Se fosse um status de erro, poderíamos colocar 400 ou 500... Usaremos os dois ifs para nos blindarmos de qualquer tipo de problema.

Com as modificações, o nosso código ficará assim:

importaNegociacoes() {

    let xhr = new XMLHttpRequest();
    xhr.open('GET', 'negociacoes/semana');
    xhr.onreadystatechange = () => {
        if(xhr.readyState == 4) {
          if(xhr.status == 200) {
          }
        }
    };
    xhr.send();
}
A seguir, faremos um teste, adicionando o else e o console.log.

importaNegociacoes() {

    let xhr = new XMLHttpRequest();
    xhr.open('GET', 'negociacoes/semana');
    xhr.onreadystatechange = () => {
        if(xhr.readyState == 4) {
            if(xhr.status == 200) {
                console.log('Obtendo as negociações do servidor.')
            } else {
                console.log('Não foi possível obter as negociações do servidor.')
            }
        }
    }
    xhr.send();
}
Será exibida uma mensagem de erro quando o valor for diferente de 200. A questão é: como teremos acesso às requisições que vieram do servidor?
***********************
03-Realizando o parse da resposta
Para termos acesso às requisições que foram retornadas pelo servidor, vamos usar a propriedade xhr.responseText. Ela também vai capturar a mensagem de erro vinda do servidor:

//...

    if(xhr.readyState == 4) {

        if(xhr.status == 200) {

            console.log('Obtendo as negociações do servidor.');
            console.log(xhr.responseText);
        }else{
            console.log('Não foi possível obter as negociações do servidor.');
            console.log(xhr.responseText);
        }
    }
};
xhr.send();
}
Em seguida, recarregaremos a página e veremos o que será exibido no Console:

texto exibido no Console

Vemos um texto sendo exibido e, não, efetivamente um array. Isto acontece porque o JSON tem um formato textual para que os dados possam trafegar pela internet. Para transformarmos o JSON (texto) em um array de objetos, usaremos a função JSON.parse(), existente desde a versão anterior do JavaScript. Cada item do array é um objeto JavaScript. Mas nós poderíamos fazer como no exemplo abaixo?

if(xhr.readyState == 4) {
    if(xhr.status == 200) {

        this._listaNegociacoes.adiciona(JSON.parse(xhr.responseText));

    } else {

      console.log('Não foi possível obter as negociações do servidor.');
      console.log(xhr.responseText);
    }
}
Não poderíamos fazer isto, porque o adiciona() recebe uma negociação por vez. Na verdade, ela recebe uma instância de negociação. Se observarmos o array exibido no Console, não veremos uma instância de negociação, na verdade, cada item é um object. Primeiramente teremos que converter o JSON, fazendo o parse() e para cada item do array, teremos que criar uma negociação. Para realizarmos esta ação, usaremos a função map() - que varrerá o array e criará um novo com modificações. Usaremos uma arrow function:

if(xhr.readyState == 4) {
    if(xhr.status == 200) {

        JSON.parse(xhr.responseText)
         .map(objeto => new Negociacao(objeto.data, objeto.quantidade, objeto.valor));

    } else {

      console.log('Não foi possível obter as negociações do servidor.');
      console.log(xhr.responseText);
    }
}
Os itens serão chamados de objeto e para cada um deles, retornaremos uma Negociacao(). Como trabalhamos com uma arrow function, não precisaremos usar o return. Da lista que foi criada pelo map, vamos iterar com o forEach(), e para cada item teremos um negociação. A seguir, vamos incluir this._listaNegociacoes:

if(xhr.readyState == 4) {
    if(xhr.status == 200) {

        JSON.parse(xhr.responseText)
         .map(objeto => new Negociacao(objeto.data, objeto.quantidade, objeto.valor))
         .forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));

    } else {

      console.log(xhr.responseText);
      this._mensagem.texto = 'Não foi possível obter as negociações da semana'; 
    }
}
Vamos entender o que foi feito: xhr.responseText é um texto, o JSON() irá transforma-lo para o formato textual para objeto. Para cada um dos objetos listados, converteremos em uma instância de negociação, no fim, um novo array será gerado. Depois, com o forEach(), percorreremos cada item e adiciono na minha lista de negociações. Dentro do else alteramos as mensagens no caso de erro. No console, será exibido o xhr.responseText e para o usuário, será mostrada uma mensagem de alto nível.

Mas quando executarmos o código como está, teremos problemas.

Se acessarmos o endereço localhost:3000/negociacoes/semana, veremos que a data está no formato de uma string um pouco diferente.

data no formato estranho

Nós estamos tentando passar objeto.data (com formato de texto) diretamente para Negociacao. A seguir, vamos passar a string objeto data para um construtor de Date().

if(xhr.status == 200) {
        JSON.parse(xhr.responseText)
      .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor))
      .forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
}
string no console

Então, vamos instanciar uma nova data, baseada na string objeto.data. Recarregaremos a página do formulário e tudo funcionará corretamente. Para exibirmos uma mensagem de sucesso, adicionaremos o this._mensagem.texto. Faremos ajustes na mensagem de erro também.

if(xhr.status == 200) {
      JSON.parse(xhr.responseText)
        .map(objeto=> new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor))
        .forEach(negociacao => this._listaNegociacoes.adiciona(negociacao))
        this._mensagem.texto = 'Negociações importadas com sucesso.';
  } else {
      console.log(xhr.responseText);
      this._mensagem.texto = 'Não foi possível obter as negociações.';
  }
}
negociações importadas com sucesso

A mensagem será exibida corretamente e podemos considerar esta primeira parte finalizada. Depois, faremos uma pequena brincadeira para vermos o que acontece em um caso de erro. Mudaremos o endereço no importaNegociacoes() para negociacoes/xsemana:

importaNegociacoes() {

    let xhr = new XMLHttpRequest();
    xhr.open('GET', 'negociacoes/xsemana');

//...
Neste caso, quando tentarmos recarregar a página, o usuário verá a seguinte mensagem de erro:

mensagem de erro

No Console, veremos a mensagem de log:

mensagem de log

Conseguimos implementar a nossa solução com AJAX, usando JavaScript "puro" e sem utilizar bibliotecas como jQuery.
***********************
04-Separando as responsabilidades
Estamos conseguindo importar, mas a responsabilidade de buscar os dados do servidor não é da controller. Por isso, nós vamos isolar o código do importaNegociacoes(), numa classe que será especializada em obter as negociações do servidor e que será utilizada pela controller. Dentro da pasta services, vamos criar NegociacaoService.js.

importaNegociacoes() {

       let xhr = new XMLHttpRequest();

        xhr.open('GET', 'negociacoes/semana');

        xhr.onreadystatechange = () => {

            if(xhr.readyState == 4) {

                if(xhr.status == 200) {

                  JSON.parse(xhr.responseText)
                    .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)
                    .forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
                    this._mensagem.texto = 'Negociações importadas com sucesso.';

              } else {
                  console.log(xhr.responseText);
                  this._mensagem.texto = 'Não foi possível obter as negociações.';
              }
            }
      };

      xhr.send();
    }
}
A vantagem de isolarmos o código é que se tivermos outra parte do sistema que precisa obter a lista de negociações do servidor, não iremos cortar o código da controller. Nós reutilizaremos em uma nova classe NegociacaoService, que terá o método obterNegociacoesDaSemana() que retornará as negociações da semana:

class NegociacaoService { 
    obterNegociacoesDaSemana() {

        let xhr = new XMLHttpRequest();

        xhr.open('GET', 'negociacoes/semana');

        xhr.onreadystatechange = () => {

            if(xhr.readyState == 4) {

                if(xhr.status == 200) {

                JSON.parse(xhr.responseText)
                    .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)
                    .forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
                    this._mensagem.texto = 'Negociações importadas com sucesso.';

            } else {
                console.log(xhr.responseText);
                this._mensagem.texto = 'Não foi possível obter as negociações.';
            }
            }
    };

    xhr.send();
    }
}
O service não terá acesso a View, porque ele não tem referência para os elementos da controller. Logo, removemos this._mensagem.texto a mensagem de erro para o usuário. E importaremos o arquivo em index.html:

<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script>
    let negociacaoController = new NegociacaoController();          
</script>
Em seguida, no arquivo NegociacaoController.js, vamos adicionar a variável service no importaNegociacoes().

importaNegociacoes() {

    let service = new NegociacaoService();

    service.obterNegociacoesDaSemana();
}
No método obterNegociacoesDaSemana() temos que ter acesso ao retorno, porque será na controller que levantaremos os dados com os quais atualizaremos o model e a View ser renderizada. Para isto, o método receberá a função chamada cb (callback).

class NegociacaoService {

    obterNegociacoesDaSemana(cb) {

        let xhr = new XMLHttpRequest();
        xhr.open('GET', 'negociacoes/semana');
        xhr.onreadystatechange = () => {
            if(xhr.readyState == 4) {
                if(xhr.status == 200) {
                    JSON.parse(xhr.responseText)
                      .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor))
                      .forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
                } else {
                    console.log(xhr.responseText);
                }  
            }
        }

        xhr.send();
    }
}
Depois, em NegociacaoController.js, usaremos uma arrow function com dois valores:

importaNegociacoes() {

  let service = new NegociacaoService();

  service.obterNegociacoesDaSemana(() => {

  });
}
Quando o nosso servidor, via AJAX, buscar a negociação e estiver tudo pronto, ele chamará a função que adicionamos. Agora, vamos inserir um ifpara o caso em que ocorrer um erro.

importaNegociacoes() {

  let service = new NegociacaoService();

  service.obterNegociacoesDaSemana((err, negociacoes) => {
      if(err) {
          this._mensagem.texto = err;
          return;
      }

      negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
      this._mensagem.texto = 'Negociações importadas com sucesso';
  });
}
Se o erro não retornar preenchido, o if não será executado. Com o forEach(), para cada negociação, vamos incorrer em this._listaNegociacoes.adiciona().

Também vamos adotar um convenção: em casos de erro, ele será descoberto sempre no primeiro parâmetro e o resultado da operação virá no segundo. Estamos aplicando um padrão que vem do mundo NodeJS, e que recebe o nome de Error-First-Callback.

Então, se ocorrer um erro, exibiremos a mensagem e daremos o retorno. Desta forma, as linhas abaixo do return não serão executadas. Mas no caso em que venha uma negociação, faremos o forEach().

Agora, em NegociacaoService, vamos implementar o callback(cb):

class NegociacaoService {

    obterNegociacoesDaSemana(cb) {

        let xhr = new XMLHttpRequest();
        xhr.open('GET', 'negociacoes/semana');
        xhr.onreadystatechange = () => {
            if(xhr.readyState == 4) {
                if(xhr.status == 200) {

                  cb(null, JSON.parse(xhr.responseText)
                        .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));

                } else {
                    console.log(xhr.responseText);
                    cb('Não foi possível obter as negociações da semana', null);
                }  
            }
        }

        xhr.send();
    }
}
Se ocorrer um erro, executaremos o cb de alto nível, informando para o usuário que não foi possível obter as negociações.

Esta estratégia de Error-First significa que passaremos a função obterNegociacoesDaSemana(), se tiver sucesso receberá o primeiro parâmetro null, indicando que não teve o erro, e no segundo parâmetro, teremos o retorno. Em caso de erro, o primeiro parâmetro passarem será o erro, e o segundo, será o valor null. Temos a opção de deixar o segundo parâmetro em branco também.

Ao recarregar a página e importar as negociações, veremos a mensagem de sucesso.

negociações foram importadas com sucesso

Nós isolamos a URL no serviço.

xhr.open('GET', 'negociacoes/semana');
Se tivermos diversas controllers utilizando o serviço, só precisaremos alterar a URL uma única vez. Caso a URL esteja errada, veremos a mensagem de erro:

não foi possivel obter as negociações

O código de NegociacaoController ficou mais limpo. Faremos um pequeno ajuste substituindo o err por erro:

importaNegociacoes() {

  let service = new NegociacaoService();

  service.obterNegociacoesDaSemana((erro,negociacoes) => {
      if(erro) {
          this._mensagem.texto = erro;
          return;
      }

      negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
      this._mensagem.texto = 'Negociações importadas com sucesso';
  });
}
Fizemos uma pequena revisão de AJAX. Trabalhamos com requisições assíncronas, usando JavaScript puro. Aprendemos a isolar a lógica que geramos para realizar a requisição do servidor. Aprendemos a trabalhar com a ideia do callback e Error-First.
***********************
05-
***********************