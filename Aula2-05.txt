01-O problema da vida assíncrona
Você pode fazer o download completo do projeto até aqui e continuar seus estudos.

O nosso código está funcionando, conseguimos recarregar e importar as negociações ao clicar no botão correspondente. No entanto, precisamos encontrar uma forma de importar as negociações da semana atual, da passada e da retrasada para popularmos a lista.

Para isto, copiaremos a lógica do método obterNegociacoesDaSemana(), no NegociacaoService, e modificaremos o nome para obterNegociacaoDaSemanaAnterior:

obterNegociacoesDaSemanaAnterior(cb) {

      let xhr = new XMLHttpRequest();
      xhr.open('GET', 'negociacoes/anterior');
      xhr.onreadystatechange = () => {
          if(xhr.readyState == 4) {
              if(xhr.status == 200) {

                cb(null, JSON.parse(xhr.responseText)
                      .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));

              } else {
                  console.log(xhr.responseText);
                  cb('Não foi possível obter as negociações da semana', null);
              }  
          }
      }

      xhr.send();
  }
}  
Observe que alteramos o endereço para negociacoes/anterior. Faremos algo parecido com o trecho referente à semana retrasada:

obterNegociacoesDaSemanaRetrasada(cb) {

      let xhr = new XMLHttpRequest();
      xhr.open('GET', 'negociacoes/retrasada');
      xhr.onreadystatechange = () => {
          if(xhr.readyState == 4) {
              if(xhr.status == 200) {

                cb(null, JSON.parse(xhr.responseText)
                      .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));

              } else {
                  console.log(xhr.responseText);
                  cb('Não foi possível obter as negociações da semana', null);
              }  
          }
      }

      xhr.send();
  }
}  
Nós criamos três métodos que irão obter os dados da semana atual, passada e retrasada. Agora, no arquivo NegociacaoController.js, já temos o obterNegociacoesDaSemana em importaNegociacoes:

importaNegociacoes() {

  let service = new NegociacaoService();

  service.obterNegociacoesDaSemana((erro, negociacoes) => {
      if(erro) {
          this._mensagem.texto = erro;
          return;
      }

      negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
      this._mensagem.texto = 'Negociações importadas com sucesso';
  });
}
Agora, adicionaremos obterNegociacoesDaSemanaAnterior e obterNegociacoesDaSemanaRetrasada :

  service.obterNegociacoesDaSemanaAnterior((erro, negociacoes) => {
      if(erro) {
          this._mensagem.texto = erro;
          return;
      }

      negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
      this._mensagem.texto = 'Negociações importadas com sucesso';
  });

service.obterNegociacoesDaSemanaRetrasada((erro, negociacoes) => {
      if(erro) {
          this._mensagem.texto = erro;
          return;
      }

      negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
      this._mensagem.texto = 'Negociações importadas com sucesso';
  });
Vamos realizar as três chamadas do serviço. Depois, recarregaremos a página e conseguiremos que os dados sejam importados corretamente.

dados importados

Mas temos um pequeno problema... Como as requisições são assíncronas, elas não esperam a operação terminar para só então começarem a executar a próxima.. Segundo uma regra de negócios, essas importações devem estar em ordem: primeiramente, a negociações desta semana, depois, a da semana anterior. Por último, teremos na semana retrasada. Mas se analisarmos as datas da tabela, veremos que elas não estão em ordem. Nós não temos os controles das datas, e como são assíncronas, cada requisição poderá ser executada em diferentes momentos. O que é preciso fazer para que todas sejam executadas em ordem? Começaremos executando a requisição da semana.


importaNegociacoes() {

    let service = new NegociacaoService();

    service.obterNegociacoesDaSemana((erro, negociacoes) => {

        if(erro) {
            this._mensagem.texto = erro;
            return;
        }
        negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));

        service.obterNegociacoesDaSemanaAnterior((erro, negociacoes) => {

            if(erro) {
                this._mensagem.texto = erro;
                return;
            }
            negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));

            service.obterNegociacoesDaSemanaRetrasada((erro, negociacoes) => {

                if(erro) {
                    this._mensagem.texto = erro;
                    return;
                }
                negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
                this._mensagem.texto = 'Negociações importadas com sucesso';
            });
        });
    });
}
Quando a requisição de obterNegociacoesDaSemana terminar, as negociações serão adicionadas na lista. Então, teremos certeza de que a requisição está terminada e que podemos chamar a requisição, referente à semana anterior. E por último, virão as da semana retrasada. Vamos testar se as requisições são executadas na ordem correta.

requisições em ordem

Agora, as datas estão em ordem.

Quando você for fazer o teste na sua máquina, o servidor está gerando essas negociações aleatoriamente e podem aparecer outras datas.

Conseguimos resolver o nosso problema, mas se analisarmos o "desenho" do código, veremos que ele forma uma pirâmide. Costumamos dar o nome de Pyramid of Doom (traduzida para o português, significa pirâmide da desgraça) em situações que isto ocorre e temos uma função aninhada dentro de outra. A pirâmide é um forte indício de que temos problemas de legibilidade do código, na verdade, é o sintoma de um problema maior, o Callback Hell. Ocorre quando temos requisições assíncronas executadas em determinada ordem, que chama vários callbacks seguidos.

Se tivéssemos mais ações que precisassem ser executadas em ordem, teríamos um pirâmide com mais funções. Também vale ressaltar: em uma situação de erro - por exemplo, se a URL estivesse equivocada -, dentro do importaNegociacoes, executaríamos diversos trechos de código referentes ao erro. Testaríamos diversas vezes se ocorreu o erro, porque o código está repetido.

Agora, aplicaremos um padrão de projeto que nos ajudará a lidar com a complexidade da programação assíncrona, além de evitar que o erro seja tratado em diversos lugares.
****************************
02-O padrão de projeto Promise
Vamos melhorar a legibilidade do código, que está repetindo o tratamento de erro:


importaNegociacoes() {

    let service = new NegociacaoService();

    service.obterNegociacoesDaSemana((erro, negociacoes) => {

        if(erro) {
            this._mensagem.texto = erro;
            return;
        }
        negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));

        service.obterNegociacoesDaSemanaAnterior((erro, negociacoes) => {

            if(erro) {
                this._mensagem.texto = erro;
                return;
            }
            negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));

            service.obterNegociacoesDaSemanaRetrasada((erro, negociacoes) => {

                if(erro) {
                    this._mensagem.texto = erro;
                    return;
                }
                negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
                this._mensagem.texto = 'Negociações importadas com sucesso';
            });
        });
    });
}
Em NegociacaoService.js, faremos pequenos ajustes nas mensagens de erros dos métodos de obterNegociacoesDaSemana(), obterNegociacoesDaSemanaAnterior() e obterNegociacoesDaSemanaRetrasada, especificando qual semana está sendo trabalhada.

obterNegociacoesDaSemanaAnterior(cb) {

      let xhr = new XMLHttpRequest();
      xhr.open('GET', 'negociacoes/anterior');
      xhr.onreadystatechange = () => {
          if(xhr.readyState == 4) {
              if(xhr.status == 200) {

                cb(null, JSON.parse(xhr.responseText)
                      .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));

              } else {
                  console.log(xhr.responseText);
                  cb('Não foi possível obter as negociações da semana anterior', null);
              }
          }
      }

      xhr.send();
  }
}
Desta forma, se tivermos problemas, saberemos que será na semana anterior. Queremos reduzir a complexidade do código de programação assíncrona. Para isto, aplicaremos um padrão de projeto chamado Promessa (Promise, em inglês).

Vamos comentar o trecho que criamos até agora, porque faremos um antes e depois. Enquanto trabalhamos com o padrão Promise, não implementaremos ainda o NegociacaoService. Mas vamos considerar que ele usará o padrão de projeto Promise. Veremos a seguir, como usaremos o NegociacaoService(), no NegociacaoController.js:

importaNegociacoes() {

  let service = new NegociacaoService();

  let retorno = service.obterNegociacoesDaSemana();
}
Se observarmos o método obterNegociacoesDaSemana(), veremos que este não recebe mais o callback - apenas nos devolverá um valor. Parecerá ser um método síncrono. No entanto, ele não é... Porque ele não devolverá a lista de negociações, mas, sim, uma promise - que não poderá encontrar o que busca. A promessa é o resultado futuro de uma operação. Quando pensamos no conceito de uma promessa, nos vem a ideia de que "se você cumprir a promessa, então algo irá acontecer...". Seguindo está relação com então, chamaremos o método then() na promise.

importaNegociacoes() {

  let service = new NegociacaoService();

  let promise = service.obterNegociacoesDaSemana();
  promise
      .then(negociacoes => {
          negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao))
          this._mensagem.texto = 'Negociação da semana obtida com sucesso';
      });
Se a promessa for cumprida, receberemos a lista de negociação e, com esta, poderemos fazer o forEach(). O método obterNegociacoesDaSemana() devolve uma promessa de que tentará obter os dados. Caso a promessa seja cumprida, receberemos uma lista de negociações e exibiremos a mensagem para o usuário.

Para o caso de ocorrer um erro, vamos encadear uma função catch(), na promise.

.catch(erro => this.mensagem.texto = erro);
Com ela, iremos capturar o erro da promise e exibiremos para o usuário.

No entanto, se tentarmos executar o nosso código como está, receberemos várias mensagens de erro no Console.

mensagem de erro no Console

Ele nos informa que não recebe then(), porque obterNegociacoesDaSemana() não é uma promise. Precisamos fazer esta transformação. O ES6 suporta a promise nativamente, então, o método deverá retornar uma Promise(), que receberá dois parâmetros ( resolve e reject). Em que momento sabemos que os dados são retornados? É onde temos o cb, que não será mais necessário, por isso, vamos substitui-los por resolve:

class NegociacaoService {

  obterNegociacoesDaSemana() {

    return new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        xhr.open('GET', 'negociacoes/semana');
        xhr.onreadystatechange = () => {
            if(xhr.readyState == 4) {
                if(xhr.status == 200) {

                  resolve(JSON.parse(xhr.responseText)
                        .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));

                } else {
                    console.log(xhr.responseText);
                    reject('Não foi possível obter as negociações da semana');

                }
              }
          };
          xhr.send();

        });
O resolve passará diretamente o resultado de JSON.parse(). Observe que não precisaremos mais utilizar o parâmetro (null) do Error-First-Callback. Nós passamos direto para o resolve o resultado que será disponibilizado para a função then. E se tivermos algum tipo de erro, chamaremos a função reject(). O que está no resolve, pegaremos dentro do método then() do arquivo NegociacaoController.js e o erro passado para o reject, pegaremos no catch.

importaNegociacoes() {

    let service = new NegociacaoService();

    let promise = service.obterNegociacoesDaSemana();
    promise
        .then(negociacoes => {
        negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
        });
        this._mensagem.texto = 'Negociações importadas com sucesso'
    })
    .catch(erro => this._mensagem.texto = erro);
}
Se testarmos no navegador, veremos que tudo está funcionando e conseguiremos importar as negociações corretamente.

importar negociacoes com sucesso

Aplicaremos o padrão Promise nos outros métodos do NegociacaoService.js.

obterNegociacoesDaSemanaAnterior() {

        return new Promise((resolve, reject) => {

            let xhr = new XMLHttpRequest();

            xhr.open('GET', 'negociacoes/anterior');
            xhr.onreadystatechange = () => {
                if(xhr.readyState == 4) {
                    if(xhr.status == 200) {
                        resolve(JSON.parse(xhr.responseText)
                            .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));

                    } else {
                        console.log(xhr.responseText);
                        reject('Não foi possível obter as negociações da semana anterior');
                    }  
                }
            }
            xhr.send();
        });
    }

    obterNegociacoesDaSemanaRetrasada() {

        return new Promise((resolve, reject) => {

          let xhr = new XMLHttpRequest();

            xhr.open('GET', 'negociacoes/retrasada');
            xhr.onreadystatechange = () => {
                if(xhr.readyState == 4) {
                    if(xhr.status == 200) {
                      resolve(JSON.parse(xhr.responseText)
                          .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));

                    } else {
                        console.log(xhr.responseText);
                        reject('Não foi possível obter as negociações da semana retrasada');
                    }  
                }
            }
            xhr.send();
        });
    }
Em seguida, no NegociacoesController.js, não iremos mais declarar a variável Promise:

importaNegociacoes() {

    let service = new NegociacaoService();

    service.obterNegociacoesDaSemana()
      .then(negociacoes => {
        negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
        this._mensagem.texto = 'Negociações da semana obtidas com sucesso';
    })
    .catch(erro => this._mensagem.texto = erro);

    service.obterNegociacoesDaSemanaAnterior()
      .then(negociacoes => {
        negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
        this._mensagem.texto = 'Negociações da semana obtidas com sucesso';
    })
    .catch(erro => this._mensagem.texto = erro);

    service.obterNegociacoesDaSemanaRetrasada()
      .then(negociacoes => {
        negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
        this._mensagem.texto = 'Negociações da semana obtidas com sucesso';
    })
    .catch(erro => this._mensagem.texto = erro);

}
No navegador, dessa vez, teremos problemas com as negociações importadas. Novamente, as negociações estão fora da ordem.

negociações fora da ordem

A ordem de execução das Promises está incorreta. Mais adiante, entenderemos por que isso aconteceu e descobriremos a solução.
****************************
03-Pyramid of Doom novamente? Claro que não, Promise.all nela!
Caímos no mesmo problema enfrentado anteriormente: as negociações são exibidas fora da ordem das datas.

negociações fora da ordem

Isto ocorreu porque a Promise é assíncrona e as negociações são executadas de forma independente.

importaNegociacoes() {

    let service = new NegociacaoService();

    service.obterNegociacoesDaSemana()
      .then(negociacoes => {
        negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
        this._mensagem.texto = 'Negociações da semana obtidas com sucesso';
    })
    .catch(erro => this._mensagem.texto = erro);

    service.obterNegociacoesDaSemanaAnterior()
      .then(negociacoes => {
        negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
        this._mensagem.texto = 'Negociações da semana obtidas com sucesso';
    })
    .catch(erro => this._mensagem.texto = erro);

    service.obterNegociacoesDaSemanaRetrasada()
      .then(negociacoes => {
        negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
        this._mensagem.texto = 'Negociações da semana obtidas com sucesso';
    })
    .catch(erro => this._mensagem.texto = erro);

}
Outro problema é que estamos tratando a mensagem de erro em cada uma das promises. Como resolveremos isto? A promise possui um recurso com o qual temos uma sequência de operações assíncronas, que será executada em uma determinada ordem.

Uma maneira de executarmos todas as promises em ordem e obtermos todos os resultado de uma vez só é usar a função Promise.all, que receberá um array com as promises. Vamos fazer a segunda refatoração do nosso código:

importaNegociacoes() {

    let service = new NegociacaoService();

    Promise.all(
        service.obterNegociacoesDaSemana(),
        service.obterNegociacoesDaSemanaAnterior(),
        service.obterNegociacoesDaSemanaRetrasada()
    ).then(negociacoes => {
        console.log(negociacoes)
    })
    .catch(erro => this._mensagem.texto = erro);   
}
Pedimos para que o Promise.all() resolvesse todas as promises na ordem indicada. Mas iremos obter os dados da Promise com o then(). Caso ocorra um erro, trataremos com o catch(). E se der uma mensagem de erro específica de obterNegociacoesDaSemana(), o catch() será chamado - sem precisar ser chamado diversas vezes.

No entanto, se executarmos nosso código no navegador, teremos uma mensagem de erro, porque o Promise.all receberá a lista de promises dentro de um array, ou seja, elas deverão estar entre colchetes ([]). Com a pequena alteração, o trecho do código ficará assim:

importaNegociacoes() {

    let service = new NegociacaoService();

    Promise.all([
        service.obterNegociacoesDaSemana(),
        service.obterNegociacoesDaSemanaAnterior(),
        service.obterNegociacoesDaSemanaRetrasada()]
    ).then(negociacoes => {
        console.log(negociacoes)
    })
    .catch(erro => this._mensagem.texto = erro);   
}
Agora, faremos um teste para verificar se a página está funcionando. Após clicarmos em "Importar Negociações", o array será exibido no Console.

array no console

A grande vantagem da função Promise.all() é que todas as promises do array serão exibidos na sequência e o resultado estará em negociacoes, e em caso de erro, ele será capturado uma única vez. No entanto, a negociacao retornada não é equivalente à lista de negociações, mas sim, cada posição do array será uma lista de negociações. Para resolver a questão, usaremos o forEach(), mas teremos que pensar bem no que faremos.

importaNegociacoes() {

    let service = new NegociacaoService();

    Promise.all([
        service.obterNegociacoesDaSemana(),
        service.obterNegociacoesDaSemanaAnterior(),
        service.obterNegociacoesDaSemanaRetrasada()]
    ).then(negociacoes => {
        negociacoes.forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
        this._mensagem.texto = 'Negociações importadas com sucesso';
    })
    .catch(erro => this._mensagem.texto = erro);
Se usarmos esta opção, o negociacao dentro do forEach() será uma lista. Seguiremos por outro caminho... Antes de chegarmos até o forEach(), executaremos uma transformação do array que possui outros três dentro de si. Com o reduce(), criaremos um array que contem apenas um elemento, contendo todos as negociações. Nós faremos flatten - achatar - o array.

importaNegociacoes() {

    let service = new NegociacaoService();

    Promise.all([
        service.obterNegociacoesDaSemana(),
        service.obterNegociacoesDaSemanaAnterior(),
        service.obterNegociacoesDaSemanaRetrasada()]
    ).then(negociacoes => {
        negociacoes
          .reduce((arrayAchatado, array) => arrayAchatado.concat(array), [])
          .forEach(negociacao => this._listaNegociacoes.adiciona(negociacao));
        this._mensagem.texto = 'Negociações importadas com sucesso';
    })
    .catch(erro => this._mensagem.texto = erro);  

}
Observe que também usamos a função concat(), que concatenará o array da primeira posição de negociacoes. No fim, o reduce devolverá uma única lista cheia de negociações e o forEach() será executado sem problemas.

negociações na ordem correta

Primeiro ele resolveu as negociações da semana atual, depois da semana anterior e por último, da semana retrasada. E como só tratamos o erro em um único lugar, se provocarmos o erro modificando a URL da semana anterior, em NegociacaoService.js, por exemplo:

xhr.open('GET', 'negociacoes/anteriorx');
A mensagem de erro será exibida para o usuário.

não foi possivel obter as negociações

O mesmo ocorreria se o problema estivesse relacionado com as demais semanas.

Vimos como solucionar questões assíncronas com o padrão de projeto Promise. Mas ainda podemos extrair do NegociacaoService, a parte que lida com XMLHttpRequest.
****************************
04-Isolando a complexidade em HttpService
Se quisermos realizar um requisição do tipo GET, precisaremos repetir isso no código e preparar o onreadystatechange...

class NegociacaoService

  obterNegociacoesDaSemanaAnterior() {

          return new Promise((resolve, reject) => {

              let xhr = new XMLHttpRequest();

              xhr.open('GET', 'negociacoes/anterior');

              xhr.onreadystatechange = () => {

                  if(xhr.readyState == 4) {

                      if(xhr.status == 200) {

                          resolve(JSON.parse(xhr.responseText)
                              .map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor));

                      }

//...
Para facilitar o processo, criaremos um serviço que chamaremos de HttpService.js, que ficará na pasta Service. A nova classe não terá nenhum atributo ou método estático. Ele terá o método get(), com a URL que queremos conectar, e que retornará uma Promise.

class HttpService {

    get(url) {

        return new Promise((resolve, reject) => {

            let xhr = new XMLHttpRequest();
            xhr.open('GET', url);
            xhr.onreadystatechange = () => {
                if(xhr.readyState == 4) {
                    if(xhr.status == 200) {
                        resolve(JSON.parse(xhr.responseText));
                    } else {
                        console.log(xhr.responseText);
                        reject(xhr.responseText);
                    }
                }
            }

            xhr.send();
        });
    }
}
Observe que aproveitamos o padrão Promise e, em caso de erro, repassaremos o que veio do servidor. Também vamos passar o que veio do servidor em caso de sucesso, JSON.parse(xhr.responseText). Se quisermos usar o HttpService, faremos o seguinte:

service = new HttpService();

service.get('negociacoes/semana').then(negociacoes => ????);
Com then(), teremos acesso à lista de negociações e poderemos fazer as negociações que desejamos. Deixaremos desta forma genérica, e você poderá fazer melhorias... Nossa intenção era mostrar o conceito para isolarmos este código.

Agora, NegociacaoService é dependente de HttpService, vamos declarar isto no construtor da classe.

class NegociacaoService {

      constructor() {

          this.http = new HttpService();
      }
}
Em seguida, faremos grandes alterações no return do obterNegociacoesDaSemana():

class NegociacaoService {

    constructor() {
        this.http = new HttpService();      
    }

    obterNegociacoesDaSemana() {

        return new Promise((resolve, reject) => {

            this.http
                .get('negociacoes/semana')
                .then(negociacoes => {
                    resolve(negociacoes.map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));
                })
                .catch(erro => {
                    console.log(erro);
                    reject('Não foi possível obter as negociações da semana');
                })
        });
  }
O reject será responsável pela mensagem que será exibida para o usuário.

Vamos rever o que fizemos até aqui... Pedimos para o serviço _http buscar negociacoes/semana e, no retorno, já teremos objetos "parseados". Mas no caso do NegociacaoService que quando usamos este endereço, trata-se de uma lista de negociações com um objeto - que contem dado, quantidade e valor. Nós converteremos esta lista para outra em que teremos instâncias de negociações e passaremos para o resolve.

Agora, só falta importarmos o HttpService.js no index.html.


    <script src="js/app/models/Negociacao.js"></script>
    <script src="js/app/models/ListaNegociacoes.js"></script>
    <script src="js/app/models/Mensagem.js"></script>
    <script src="js/app/controllers/NegociacaoController.js"></script>
    <script src="js/app/helpers/DateHelper.js"></script>
    <script src="js/app/views/View.js"></script>
    <script src="js/app/views/NegociacoesView.js"></script>
    <script src="js/app/views/MensagemView.js"></script>
    <script src="js/app/services/ProxyFactory.js"></script>
    <script src="js/app/helpers/Bind.js"></script>
    <script src="js/app/services/NegociacaoService.js"></script>
    <script src="js/app/services/HttpService.js"></script>
    <script>
        let negociacaoController = new NegociacaoController();          
    </script>
Carregaremos novamente a página e clicaremos em "Importar Negociações".

negociações importadas com sucesso

Continuaremos o trabalho de conversão para usarmos o HttpService. As alterações serão feitas em obterNegociacoesDaSemanaAnterior e obterNegociacoesDaSemanaRetrasada:

obterNegociacoesDaSemanaAnterior() {

    return new Promise((resolve, reject) => {

        this.http
            .get('negociacoes/anterior')
            .then(negociacoes => {
                console.log(negociacoes);
                resolve(negociacoes.map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));

            })
            .catch(erro => {
                console.log(erro);
                reject('Não foi possível obter as negociações da semana anterior');
    })
});

obterNegociacoesDaSemanaRetrasada() {

    return new Promise((resolve, reject) => {

        this.http
            .get('negociacoes/retrasada')
            .then(negociacoes => {
                console.log(negociacoes);
                resolve(negociacoes.map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor)));

            })
            .catch(erro => {
                console.log(erro);
                reject('Não foi possível obter as negociações da semana retrasada');
    })
});
Depois de salvar as mudanças, podemos executar o código e a página funcionará corretamente.

Nós conseguimos desmembrar a parte de HttpService. Caso você queira criar um POST ou PUT ou DELETE, basta acrescentar estes métodos no HttpService, usando o padrão Promise.
****************************
05-Simplificando o código
Temos o seguinte código:

let dadosServidor = [
    [
        [new Date(), 1, 100],
        [new Date(), 2, 100]
    ],
    [
        [new Date(), 1, 150],
        [new Date(), 2, 300]
    ],
    [
        [new Date(), 3, 50],
        [new Date(), 1, 100]
    ]        
];
Se quisermos criar um array de uma única dimensão para depois criarmos uma lista de negociações a partir da classe Negociacao fazemos:

let listaDeNegociacoes = dadosServidor.reduce((novoArray, array) => {
    // novoArray receberá os itens de array, no final terá uma dimensão apenas
    return novoArray.concat(array)
}, [])
.map(dado => {
    // para cada dado, cria uma instância de negociação. No final, teremos uma nova lista só com instâncias de Negociacao

    return new Negociacao(new Date(dado.data), dado.quantidade, dado.valor )
});
O código acima funciona, contudo, podemos remover muitas chaves das declarações das arrow functions. Simplifique o código removendo as chaves quando isso fizer sentido.

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Veja que removemos as {} e o return das arrows functions. Só podemos fazer isso quando o que vem depois de => é uma instrução apenas, ou seja, não é um bloco de instruções. Aliás, repare também na maneira com que o código foi indentado.

let listaDeNegociacoes = dadosServidor
    .reduce((novoArray, array) => novoArray.concat(array), [])
    .map(dado => new Negociacao(new Date(dado.data), dado.quantidade, dado.valor ));
Há também quem goste de indentar assim:

let listaDeNegociacoes = dadosServidor
    .reduce((novoArray, array)  => novoArray.concat(array), [])
    .map(dado => 
        new Negociacao(new Date(dado.data), dado.quantidade, dado.valor ));
Ou assim:

let listaDeNegociacoes = 
    dadosServidor
        .reduce((novoArray, array) => novoArray.concat(array), [])
        .map(dado => new Negociacao(new Date(dado.data), dado.quantidade, dado.valor ));
E quem sabe assim?

let listaDeNegociacoes = 
    dadosServidor
        .reduce((novoArray, array) => 
            novoArray.concat(array), [])
        .map(dado => 
            new Negociacao(new Date(dado.data), dado.quantidade, dado.valor ));
O que estaria errado e por conseguinte não funcionaria é quebrar o código antes da flecha =>:

// Não funciona! Não pode quebrar antes da flecha! 

let listaDeNegociacoes = 
    dadosServidor
        .reduce((novoArray, array) 
            => novoArray.concat(array), [])
        .map(dado
             => new Negociacao(new Date(dado.data), dado.quantidade, dado.valor ));
****************************
06-Dissecando uma promise!
Revisão de Promise
Para ficarmos melhores do que já somos em promises, crie o arquivo dissecando-uma-promise.html e cole o código abaixo:

<!-- dissecando-uma-promise.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Dissecando uma promise</title>
</head>
<body>
    <script>

        let promise = new Promise((resolve, reject) => {
            setTimeout(() => resolve('PROMISE RESOLVIDA'), 5000);
        });

        promise.then(resultado => console.log(resultado));
    </script>
</body>
</html>
Agora, abra a página no Chrome e verifique no console do navegador. Depois de 5 segundos será exibida a mensagem PROMISE RESOLVIDA. Mas o que aconteceu durante todo esse processo?

Bom, veja que a variável promise recebeu uma instância de Promise. O construtor de Promise recebe uma função como parâmetro. É essa função passada como parâmetro que será chamada internamente pela Promise, quando for criada. Como é a própria Promise que chama essa função, ela passa sempre dois parâmetros para ela nesta ordem: a função na qual passamos o valor de sucesso e a função que passamos o valor de fracasso.

let promise = new Promise((resolve, reject) => {
    // é aqui dentro que definimos o que será passado para `resolve` e o que será passado para `reject`. 
});
Bom, criar uma Promise não é suficiente. Se olharmos o fragmento acima, em nenhum momento estamos dizendo o que acontecerá se a promessa for cumprida. Para efeito didático, colocarei um setTimeout de 5 segundos dentro do corpo da Promise. Só depois de 5 segundos passaremos o resultado da nossa operação para o resolve:

let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve('PROMISE RESOLVIDA'), 5000);
});
Obtendo o retorno da ação
Perfeito, temos a variável promise, que guarda uma instância de Promise, o resultado futuro de uma ação. Mas em que parte do código pegamos o resultado dessa ação quando concluída?

É por meio do método then, da instância de Promise que temos acesso ao resultado da ação. O método then recebe uma função e nela temos acesso sempre como primeiro parâmetro ao resultado da ação. Internamente em nossa Promise, é o valor passado para resolve que estará disponível para a função then. Sendo assim, em then, só depois de 5 segundos teremos acesso ao resultado a ação, que é uma string, mas poderia ser qualquer outro tipo de dado.

let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve('PROMISE RESOLVIDA'), 5000);
});

// imprime no console "PROMISE RESOLVIDA"
promise.then(resultado => console.log(resultado));
É interessante saber que, como nosso código é assíncrono, não sabemos quando nossa promessa será cumprida (sabemos que são 5 segundos, mas se fosse uma conexão de rede não teríamos tanta certeza assim, certo?).

Quero que vocês façam uma pequena alteração no código:

<!-- dissecando-uma-promise.html -->
<script>

    let promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve('PROMISSE RESOLVIDA'), 5000);
    });

    promise.then(resultado => console.log(resultado));
    console.log('FIM'); // novidade aqui!
</script>
Como a promise é assíncrona e não bloqueia a execução do nosso código, veremos impresso no console as mensagens nesta ordem:

FIM
PROMISE CONCLUÍDA
Lidando com erros
E se algo sair errado? Onde trataremos o erro? Quando há algum erro dentro do corpo da nossa Promise, cabe ao desenvolvedor capturar esse erro e passá-lo para a função reject:

<script>

    let promise = new Promise((resolve, reject) => {
        console.log(resolve);
        setTimeout(() => reject('HOUVE PROBLEMAS'), 5000);
    });

    promise
        .then(resultado => console.log(resultado));
</script>
Depois de 5 segundos, nossa promise será rejeitada, indicando que houve algum erro. Mas onde teremos acesso à causa da rejeição? Basta, depois de then, encadearmos uma chamada à função catch:

<script>

    let promise = new Promise((resolve, reject) => {
        console.log(resolve);
        setTimeout(() => reject('HOUVE PROBLEMAS'), 5000);
    });

    promise
        .then(resultado => console.log(resultado))
        .catch(erro => console.log(erro)); // exibe no console HOUVE PROBLEMAS
</script>
Mas é claro que queremos que nossa promise esteja preparada para resolver ou rejeitar. Para efeito didático, vamos colocar um variável booleana. Se for true, resolvemos, se for false, rejeitamos. Dessa forma, você pode brincar e simular quando a promise é resolvida ou não:

<script>

    let ok = false;
    let promise = new Promise((resolve, reject) => {

        // como temos mais de uma instrução, precisamos colocar um bloco em nossa arrow function! Lembrou?
        setTimeout(() => {
            if(ok) {
                resolve('PROMISE CONCLUÍDA');
            } else {
                reject('HOUVE PROBLEMAS');
            }
        }, 5000);
    });

    promise
        .then(resultado => console.log(resultado))
        .catch(erro => console.log(erro));
</script>
VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Promises (promessas) agora fazem parte da linguagem JavaScript a partir do ES6. Elas representam o resultado futuro de uma ação, que pode ser de sucesso ou fracasso. Elas visam tornar códigos assíncronos mais legíveis e fáceis de manter, evitando o Callback Hell. Uma ou outra chamada assíncrona não é problemática, o problema é quando temos uma sucessão de chamadas assíncronas e o modo tradicional de lidar com elas, aninhando callbacks, torna o código difícil de ler e manter, principalmente o tratamento de erros.
****************************
07-Exercicio - declarando uma promise
Veja o pedaço do código JavaScript que inicializa uma Promise:

let minhaPromessa = new Promise((resolve, reject) => {

    // aqui executamos algo demorado

    if (/* tudo deu certo */) {
        resolve("Funcionou!");
    }
    else {
        reject("Deu erro...");
    }
});
Ao inicializar a minhaPromessa, como podemos verificar o resultado da execução?

Alternativa correta
minhaPromessa
    .then(console.log(mensagem))
    .catch(console.log(erro));

Alternativa correta
minhaPromessa
    .success(mensagem => console.log(mensagem))
    .error(erro => console.log(erro);

Alternativa correta
minhaPromessa
    .then(mensagem => console.log(mensagem))
    .catch(erro => console.log(erro));

Parabéns, usamos os métodos then e catch para capturar o resolve e o reject oriundo da promisse e dentro deles é necessário passar uma function ou Arrow function com o comando desejado.
****************************
08-
****************************
