01-Uma conexão ou várias?
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto anterior e continuar seus estudos a partir daqui.

Anteriormente, aprendemos a interagir com o indexedDB, nós também incluímos e listamos negociações em uma Object Store. Mas temos que pensar na manutenção e legitimidade do nosso código, por isso, começaremos a organizá-lo. A seguir, atacaremos a criação da conexão, chamando duas vezes o ConnectionFactory:

ConnectionFactory
    .getConnection()
    .then(connection => {
    });

// faz outras coisas e pede novamente a conexão

ConnectionFactory
    .getConnection()
    .then(connection => {
    });
A) O método getConnection() será um método estático, ou seja, invocado diretamente na classe.

B) O retorno de getConnection será uma promise, pois a abertura de uma conexão é um processo assíncrono.

C) Não importa quantas vezes seja chamado o método getConnection(), a conexão retornada deve ser a mesma.

D) Toda conexão possui o método close(), mas o programador não pode chamá-lo, porque a conexão é a mesma para a aplicação inteira. Só o próprio ConnectionFactory pode fechar a conexão.

Para entender o que queremos dizer quando falamos que a conexão retornada pelo método getConnection() deve ser a mesma, usaremos um exemplo compreensível para aqueles que trabalham com aplicações Web ou Back end. Existe um pool de conexões, no qual várias conexões são compartilhadas com os usuários. Quando trabalhamos com o IndexedDB, é comum termos uma única conexão que será usada pela aplicação. Ao criarmos a chamada para o getConnection, ele nos dará a conexão e se fizermos a mesma solicitação novamente, o retorno deverá ser o mesmo. A conexão será compartilhada com toda a aplicação e, por isso, o método close() não poderá ser chamado novamente. Lembrando que só o ConnectionFactory terá o poder de fechar a conexão.

Levando em consideração estas regras, faremos o design da classe ConnectionFactory.
**************************************
02- A classe ConnectionFactory
Vamos criar a classe ConnectionFactory dentro da pasta services. Já importaremos a classe no arquivo index.html.

<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script>
    let negociacaoController = new NegociacaoController();          
</script>
Geraremos o método estático getConnection(), e para garantir que o desenvolvedor não crie uma instância da classe, lançaremos uma exceção em seu construtor:


class ConnectionFactory {

    constructor() {

        throw new Error('Não é possível criar instâncias de ConnectionFactory');
    }

    static getConnection() {

        return new Promise((resolve, reject) => {

        });
    }
}
O getConnection retornará uma Promise() - o que já foi visto na segunda parte do curso. Até aqui, já atendemos duas das regras para fazermos o design da classe ConnectionFactory. Criaremos a conexão com base no que vimos: adicionaremos a variável openRequest e faremos uma requisição de abertura.

static getConnection() {

     return new Promise((resolve, reject) => {

         let openRequest = window.indexedDB.open('aluraframe',4);    

     });
}
Observe que utilizamos o valor 4, porque foi a última versão do banco utilizada. Este é o código que fará com que o onupgradeneeded seja executado, caso o valor seja maior do que o banco criado. Trabalharemos com a tríade de eventos que são disparados toda vez que uma requisição de abertura de conexão é feita: onupgradeneeded, onsuccess e onerror.

static getConnection() {

      return new Promise((resolve, reject) => {

          let openRequest = window.indexedDB.open('aluraframe',4);

          openRequest.onupgradeneeded = e => {
          };

          openRequest.onsuccess = e => {    
          };

          openRequest.onerror = e => {    
          };
      });
}
As stores são criadas no onupgradeneeded, criaremos uma nova Object Store que receberá o nome de negociacoes. Mas não poderemos declarar a variável como propriedade do construtor da classe, porque ela só seria acessível por meio de uma instância de classe, por isso, iremos declará-la como uma variável global. Esta será uma saída momentânea. Vamos criar também as variáveis version e dbName para guardarem a versão do banco e o seu nome. Então, acima do ConnectionFactory, adicionaremos as três variáveis:

var stores = ['negociacoes'];
var version = 4;
var dbName = 'aluraframe';

//...
Nós usaremos essas variáveis no onupgradeneeded para criarmos as histórias.

**************************************
03- Criando stores
Criaremos as nossas stores, por enquanto, temos um array com apenas uma. Atualmente o nosso código está assim:

var stores = ['negociacoes'];
var version = 4;
var dbName = 'aluraframe';

class ConnectionFactory {


    constructor() {

        throw new Error('Não é possível criar instâncias de ConnectionFactory');
    }

    static getConnection() {

        return new Promise((resolve, reject) => {

            let openRequest = window.indexedDB.open('aluraframe',4);

            openRequest.onupgradeneeded = e => {

                stores.forEach(store => {

                });

            };
            openRequest.onsuccess = e => {
            };
            openRequest.onerror = e => {
            };
        });
    }
}
Começaremos adicionando e.target.result no stores.forEach():

static getConnection() {

        return new Promise((resolve, reject) => {

            let openRequest = window.indexedDB.open('aluraframe',4);

            openRequest.onupgradeneeded = e => {

                stores.forEach(store => {

                    if(e.target.result.objectStoreNames.contains(store)) e.target.result.deleteObjectStore(store);

                    e.target.result.createObjectStore(store, { autoIncrement: true });
                });
            };
Com o if recém adicionado, apagaremos as Objects Stores que já existem. Caso tudo esteja correto, criaremos uma nova store e o autoIncrement será true. Mas se você observar o nosso código, perceberá que temos parte repetidas no código. Para solucionarmos isto, adicionaremos um método estático privado _createStores(), e depois, moveremos o forEach() para ele:

static _createStores(connection) {

    // criando nossos stores!

    stores.forEach(store => {

        if(connection.objectStoreNames.contains(store)) connection.deleteObjectStore(store);
        connection.createObjectStore(store, { autoIncrement: true });
    });
}
Nos substituímos e.target.result pelo método _createStores() porque ele recebe uma connection. Depois, vamos inserir o método no onupgradeneeded:

static getConnection() {

        return new Promise((resolve, reject) => {

            let openRequest = window.indexedDB.open(dbName,version);

            openRequest.onupgradeneeded = e => {

                ConnectionFactory._createStores(e.target.result);
            };
  //...
Chamaremos o método auxiliar privado da classe - vimos anteriormente, que o método poderá ser chamado por qualquer um, mas quando utilizamos o prefixo _, significa que este só deverá ser chamado pela própria classe. Então, fechamos o onupgradeneeded. Vamos agora trabalhar com o onsuccess:

openRequest.onsuccess = e => {    

   resolve(e.target.result);
};
Para os casos de erro, teremos o onerror:

openRequest.onerror = e => {    

    console.log(e.target.error);

    reject(e.target.error.name);
};
No reject, em vez de passarmos o objeto error, retornaremos um string com a mensagem de erro. Nosso código ficou assim:

var stores = ['negociacoes'];
var version = 4;
var dbName = 'aluraframe';

class ConnectionFactory {

    constructor() {

        throw new Error('Não é possível criar instâncias de ConnectionFactory');
    }

    static getConnection() {

        return new Promise((resolve, reject) => {

            let openRequest = window.indexedDB.open(dbName,version);

            openRequest.onupgradeneeded = e => {

                ConnectionFactory._createStores(e.target.result);
            };

            openRequest.onsuccess = e => {    

                resolve(e.target.result);
            };

            openRequest.onerror = e => {    

                console.log(e.target.error);

                reject(e.target.error.name);
            };
        });
    }
    static _createStores(connection) {

        stores.forEach(store => {

            if(connection.objectStoreNames.contains(store)) connection.deleteObjectStore(store);
            connection.createObjectStore(store, { autoIncrement: true });
        });
    }
}
Vamos realizar um teste na página do navegador. No Console, chamaremos o método ConnectionFactory.getConnection:

ConnectionFactory.getConnection().then(connection => console.log(connection));
Ele irá nos retornar o IDBDatabase.

teste no Console

Está tudo funcionando corretamente. Mas se chamarmos o mesmo método novamente, veremos que uma nova conexão será criada.

nova conexão criada

Nós queremos ter apenas uma conexão, independentemente do número de vezes que o método getConnection for chamado. Veremos como solucionar isto.
**************************************
04- O padrão de projeto Module Pattern
Uma solução para garantirmos que teremos a mesma conexão sempre que o método getConnection() for chamado é declarar a variável connection fora da classe ConnectionFactory:

var stores = ['negociacoes'];
var version = 4;
var dbName = 'aluraframe';

var connection = null;
Depois, a variável será incluída no onsuccess:

openRequest.onsuccess = e => {

               if(!connection) connection = e.target.result;

               // recebe conexão já existente ou uma que acabou de ser criada

               resolve(connection);
 };
Se chamarmos o método getConnection() pela primeira vez, o valor de connection será nulo. Mas se chamarmos novamente, o if não será executado e o retorno será a mesma conexão. De volta a página no navegador, no Console, invocaremos o getConnection():

ConnectionFactory.getConnection().then(connection => console.log(connection));
Se repetirmos a ação diversas vezes e o retorno será sempre o mesmo:

mesma conexão

Resolvemos a questão. Mas ainda temos o problema de que temos quatro variáveis no escopo global. Se quisermos acessar pelo Console a variável connection, teremos que fazer isso:

variavel connection

No entanto, não queríamos que isto ocorresse - e também podemos acessar as outras variáveis. Resolveremos o problema, aplicando um padrão de projeto JavaScript chamado Module Pattern. Um módulo é uma unidade código confinada e que ninguém tem acesso ao conteúdo dentro dele. Uma maneira de criarmos um escopo privado no JavaScript é colocando o código em uma função. Criaremos a function tmp(), e moveremos para dentro as variáveis juntamente com a definição da classe ConnectionFactory.

function tmp() {

    var stores = ['negociacoes'];
    var version = 4;
    var dbName = 'aluraframe';

    var connection = null;

    class ConnectionFactory {

        constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
        }

//...
Logo depois do createStores(), chamaremos a tmp():

//...
  static _createStores(connection) {

      stores.forEach(store => {

          if(connection.objectStoreNames.contains(store)) connection.deleteObjectStore(store);
          connection.createObjectStore(store, { autoIncrement: true });
      });

  }
}
tmp();
Agora, conseguimos que ninguém tenha acesso ao conteúdo de tmp(), mas isto inclui o ConnectionFactory:

ConnectinFactory pelo Console

Se todo o código está dentro de tmp(), vamos adicionar um return na declaração da classe:

function tmp() {

    var stores = ['negociacoes'];
    var version = 4;
    var dbName = 'aluraframe';

    var connection = null;

    return class ConnectionFactory {

        constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
        }

//...
Após darmos o return, colocaremos o tmp() do fim, dentro da variável ConnectionFactory.

var ConnectionFactory = tmp();
Usamos o mesmo nome da classe para podermos acessá-la. Vamos invocar o ConnectionFactory no Console:

> ConnectionFactory
acessamos a classe no Console

Podemos utilizar a ConnectionFactory para obter uma conexão. Porém, o nosso código não ficou bom, primeiro declaramos a função e, depois, iremos chamá-la e dar o retorno. Para resolver a questão, não deixaremos mais que a função tmp() seja chamada, retirando o nome do código - e tornando a função anônima.

function () {

    var stores = ['negociacoes'];
    var version = 4;
    var dbName = 'aluraframe';

    var connection = null;

    return class ConnectionFactory {

        constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
        }

//...
Mas não podemos declarar funções anônimas desta forma - ainda que assim, a função tmp() não poderá ser chamada. Para resolvermos isto, envolveremos nossa função anônima por um parênteses. E para invocá-la, adicionaremos () no fim:

(function () {

    let stores = ['negociacoes'];
    let version = 4;
    let dbName = 'aluraframe';
    let connection = null;

    return class ConnectionFactory {


        constructor() {

            throw new Error('Não é possível criar instâncias de ConnectinFactory');
        }

        static getConnection() {

       }

        static _createStores() {

        }
    }
}) ();
Nós estamos criando uma função autoinvocada. Simultaneamente, ela será carregada e executada. Estamos enganando o compilador do JavaScript, porque o conteúdo do parênteses é uma função anônima... Em seguida, criaremos a variável ConnectionFactory no escopo global, mas o restante do código não estará.

var ConnectionFactory = (function () {

    var stores = ['negociacoes'];
    var version = 4;
    var dbName = 'aluraframe';

    var connection = null;

    return class ConnectionFactory {

        constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
        }

//...
Agora, se fizermos um teste e chamarmos a ConnectionFactory no Console, veremos que todo o escopo da classe será mostrada.

Aplicamos o Module Pattern, com o qual transformamos todo o script em um módulo - o código está todo confinado. E depois, definimos qual parte queremos exportar para o mundo externo usando o return. A ConnectionFactory é acessada, mas todo o restante não. Com isto, resolvemos o problema de utilizarmos uma única conexão.
**************************************
05-
**************************************
06-
**************************************
07-
**************************************
08-
**************************************
09-
**************************************
10-
**************************************
11-
**************************************
12-
**************************************
13-
**************************************