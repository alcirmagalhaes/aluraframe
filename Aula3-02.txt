01-Uma conexão ou várias?
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto anterior e continuar seus estudos a partir daqui.

Anteriormente, aprendemos a interagir com o indexedDB, nós também incluímos e listamos negociações em uma Object Store. Mas temos que pensar na manutenção e legitimidade do nosso código, por isso, começaremos a organizá-lo. A seguir, atacaremos a criação da conexão, chamando duas vezes o ConnectionFactory:

ConnectionFactory
    .getConnection()
    .then(connection => {
    });

// faz outras coisas e pede novamente a conexão

ConnectionFactory
    .getConnection()
    .then(connection => {
    });
A) O método getConnection() será um método estático, ou seja, invocado diretamente na classe.

B) O retorno de getConnection será uma promise, pois a abertura de uma conexão é um processo assíncrono.

C) Não importa quantas vezes seja chamado o método getConnection(), a conexão retornada deve ser a mesma.

D) Toda conexão possui o método close(), mas o programador não pode chamá-lo, porque a conexão é a mesma para a aplicação inteira. Só o próprio ConnectionFactory pode fechar a conexão.

Para entender o que queremos dizer quando falamos que a conexão retornada pelo método getConnection() deve ser a mesma, usaremos um exemplo compreensível para aqueles que trabalham com aplicações Web ou Back end. Existe um pool de conexões, no qual várias conexões são compartilhadas com os usuários. Quando trabalhamos com o IndexedDB, é comum termos uma única conexão que será usada pela aplicação. Ao criarmos a chamada para o getConnection, ele nos dará a conexão e se fizermos a mesma solicitação novamente, o retorno deverá ser o mesmo. A conexão será compartilhada com toda a aplicação e, por isso, o método close() não poderá ser chamado novamente. Lembrando que só o ConnectionFactory terá o poder de fechar a conexão.

Levando em consideração estas regras, faremos o design da classe ConnectionFactory.
**************************************
02- A classe ConnectionFactory
Vamos criar a classe ConnectionFactory dentro da pasta services. Já importaremos a classe no arquivo index.html.

<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script>
    let negociacaoController = new NegociacaoController();          
</script>
Geraremos o método estático getConnection(), e para garantir que o desenvolvedor não crie uma instância da classe, lançaremos uma exceção em seu construtor:


class ConnectionFactory {

    constructor() {

        throw new Error('Não é possível criar instâncias de ConnectionFactory');
    }

    static getConnection() {

        return new Promise((resolve, reject) => {

        });
    }
}
O getConnection retornará uma Promise() - o que já foi visto na segunda parte do curso. Até aqui, já atendemos duas das regras para fazermos o design da classe ConnectionFactory. Criaremos a conexão com base no que vimos: adicionaremos a variável openRequest e faremos uma requisição de abertura.

static getConnection() {

     return new Promise((resolve, reject) => {

         let openRequest = window.indexedDB.open('aluraframe',4);    

     });
}
Observe que utilizamos o valor 4, porque foi a última versão do banco utilizada. Este é o código que fará com que o onupgradeneeded seja executado, caso o valor seja maior do que o banco criado. Trabalharemos com a tríade de eventos que são disparados toda vez que uma requisição de abertura de conexão é feita: onupgradeneeded, onsuccess e onerror.

static getConnection() {

      return new Promise((resolve, reject) => {

          let openRequest = window.indexedDB.open('aluraframe',4);

          openRequest.onupgradeneeded = e => {
          };

          openRequest.onsuccess = e => {    
          };

          openRequest.onerror = e => {    
          };
      });
}
As stores são criadas no onupgradeneeded, criaremos uma nova Object Store que receberá o nome de negociacoes. Mas não poderemos declarar a variável como propriedade do construtor da classe, porque ela só seria acessível por meio de uma instância de classe, por isso, iremos declará-la como uma variável global. Esta será uma saída momentânea. Vamos criar também as variáveis version e dbName para guardarem a versão do banco e o seu nome. Então, acima do ConnectionFactory, adicionaremos as três variáveis:

var stores = ['negociacoes'];
var version = 4;
var dbName = 'aluraframe';

//...
Nós usaremos essas variáveis no onupgradeneeded para criarmos as histórias.

**************************************
03- Criando stores
Criaremos as nossas stores, por enquanto, temos um array com apenas uma. Atualmente o nosso código está assim:

var stores = ['negociacoes'];
var version = 4;
var dbName = 'aluraframe';

class ConnectionFactory {


    constructor() {

        throw new Error('Não é possível criar instâncias de ConnectionFactory');
    }

    static getConnection() {

        return new Promise((resolve, reject) => {

            let openRequest = window.indexedDB.open('aluraframe',4);

            openRequest.onupgradeneeded = e => {

                stores.forEach(store => {

                });

            };
            openRequest.onsuccess = e => {
            };
            openRequest.onerror = e => {
            };
        });
    }
}
Começaremos adicionando e.target.result no stores.forEach():

static getConnection() {

        return new Promise((resolve, reject) => {

            let openRequest = window.indexedDB.open('aluraframe',4);

            openRequest.onupgradeneeded = e => {

                stores.forEach(store => {

                    if(e.target.result.objectStoreNames.contains(store)) e.target.result.deleteObjectStore(store);

                    e.target.result.createObjectStore(store, { autoIncrement: true });
                });
            };
Com o if recém adicionado, apagaremos as Objects Stores que já existem. Caso tudo esteja correto, criaremos uma nova store e o autoIncrement será true. Mas se você observar o nosso código, perceberá que temos parte repetidas no código. Para solucionarmos isto, adicionaremos um método estático privado _createStores(), e depois, moveremos o forEach() para ele:

static _createStores(connection) {

    // criando nossos stores!

    stores.forEach(store => {

        if(connection.objectStoreNames.contains(store)) connection.deleteObjectStore(store);
        connection.createObjectStore(store, { autoIncrement: true });
    });
}
Nos substituímos e.target.result pelo método _createStores() porque ele recebe uma connection. Depois, vamos inserir o método no onupgradeneeded:

static getConnection() {

        return new Promise((resolve, reject) => {

            let openRequest = window.indexedDB.open(dbName,version);

            openRequest.onupgradeneeded = e => {

                ConnectionFactory._createStores(e.target.result);
            };
  //...
Chamaremos o método auxiliar privado da classe - vimos anteriormente, que o método poderá ser chamado por qualquer um, mas quando utilizamos o prefixo _, significa que este só deverá ser chamado pela própria classe. Então, fechamos o onupgradeneeded. Vamos agora trabalhar com o onsuccess:

openRequest.onsuccess = e => {    

   resolve(e.target.result);
};
Para os casos de erro, teremos o onerror:

openRequest.onerror = e => {    

    console.log(e.target.error);

    reject(e.target.error.name);
};
No reject, em vez de passarmos o objeto error, retornaremos um string com a mensagem de erro. Nosso código ficou assim:

var stores = ['negociacoes'];
var version = 4;
var dbName = 'aluraframe';

class ConnectionFactory {

    constructor() {

        throw new Error('Não é possível criar instâncias de ConnectionFactory');
    }

    static getConnection() {

        return new Promise((resolve, reject) => {

            let openRequest = window.indexedDB.open(dbName,version);

            openRequest.onupgradeneeded = e => {

                ConnectionFactory._createStores(e.target.result);
            };

            openRequest.onsuccess = e => {    

                resolve(e.target.result);
            };

            openRequest.onerror = e => {    

                console.log(e.target.error);

                reject(e.target.error.name);
            };
        });
    }
    static _createStores(connection) {

        stores.forEach(store => {

            if(connection.objectStoreNames.contains(store)) connection.deleteObjectStore(store);
            connection.createObjectStore(store, { autoIncrement: true });
        });
    }
}
Vamos realizar um teste na página do navegador. No Console, chamaremos o método ConnectionFactory.getConnection:

ConnectionFactory.getConnection().then(connection => console.log(connection));
Ele irá nos retornar o IDBDatabase.

teste no Console

Está tudo funcionando corretamente. Mas se chamarmos o mesmo método novamente, veremos que uma nova conexão será criada.

nova conexão criada

Nós queremos ter apenas uma conexão, independentemente do número de vezes que o método getConnection for chamado. Veremos como solucionar isto.
**************************************
04- O padrão de projeto Module Pattern
Uma solução para garantirmos que teremos a mesma conexão sempre que o método getConnection() for chamado é declarar a variável connection fora da classe ConnectionFactory:

var stores = ['negociacoes'];
var version = 4;
var dbName = 'aluraframe';

var connection = null;
Depois, a variável será incluída no onsuccess:

openRequest.onsuccess = e => {

               if(!connection) connection = e.target.result;

               // recebe conexão já existente ou uma que acabou de ser criada

               resolve(connection);
 };
Se chamarmos o método getConnection() pela primeira vez, o valor de connection será nulo. Mas se chamarmos novamente, o if não será executado e o retorno será a mesma conexão. De volta a página no navegador, no Console, invocaremos o getConnection():

ConnectionFactory.getConnection().then(connection => console.log(connection));
Se repetirmos a ação diversas vezes e o retorno será sempre o mesmo:

mesma conexão

Resolvemos a questão. Mas ainda temos o problema de que temos quatro variáveis no escopo global. Se quisermos acessar pelo Console a variável connection, teremos que fazer isso:

variavel connection

No entanto, não queríamos que isto ocorresse - e também podemos acessar as outras variáveis. Resolveremos o problema, aplicando um padrão de projeto JavaScript chamado Module Pattern. Um módulo é uma unidade código confinada e que ninguém tem acesso ao conteúdo dentro dele. Uma maneira de criarmos um escopo privado no JavaScript é colocando o código em uma função. Criaremos a function tmp(), e moveremos para dentro as variáveis juntamente com a definição da classe ConnectionFactory.

function tmp() {

    var stores = ['negociacoes'];
    var version = 4;
    var dbName = 'aluraframe';

    var connection = null;

    class ConnectionFactory {

        constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
        }

//...
Logo depois do createStores(), chamaremos a tmp():

//...
  static _createStores(connection) {

      stores.forEach(store => {

          if(connection.objectStoreNames.contains(store)) connection.deleteObjectStore(store);
          connection.createObjectStore(store, { autoIncrement: true });
      });

  }
}
tmp();
Agora, conseguimos que ninguém tenha acesso ao conteúdo de tmp(), mas isto inclui o ConnectionFactory:

ConnectinFactory pelo Console

Se todo o código está dentro de tmp(), vamos adicionar um return na declaração da classe:

function tmp() {

    var stores = ['negociacoes'];
    var version = 4;
    var dbName = 'aluraframe';

    var connection = null;

    return class ConnectionFactory {

        constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
        }

//...
Após darmos o return, colocaremos o tmp() do fim, dentro da variável ConnectionFactory.

var ConnectionFactory = tmp();
Usamos o mesmo nome da classe para podermos acessá-la. Vamos invocar o ConnectionFactory no Console:

> ConnectionFactory
acessamos a classe no Console

Podemos utilizar a ConnectionFactory para obter uma conexão. Porém, o nosso código não ficou bom, primeiro declaramos a função e, depois, iremos chamá-la e dar o retorno. Para resolver a questão, não deixaremos mais que a função tmp() seja chamada, retirando o nome do código - e tornando a função anônima.

function () {

    var stores = ['negociacoes'];
    var version = 4;
    var dbName = 'aluraframe';

    var connection = null;

    return class ConnectionFactory {

        constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
        }

//...
Mas não podemos declarar funções anônimas desta forma - ainda que assim, a função tmp() não poderá ser chamada. Para resolvermos isto, envolveremos nossa função anônima por um parênteses. E para invocá-la, adicionaremos () no fim:

(function () {

    let stores = ['negociacoes'];
    let version = 4;
    let dbName = 'aluraframe';
    let connection = null;

    return class ConnectionFactory {


        constructor() {

            throw new Error('Não é possível criar instâncias de ConnectinFactory');
        }

        static getConnection() {

       }

        static _createStores() {

        }
    }
}) ();
Nós estamos criando uma função autoinvocada. Simultaneamente, ela será carregada e executada. Estamos enganando o compilador do JavaScript, porque o conteúdo do parênteses é uma função anônima... Em seguida, criaremos a variável ConnectionFactory no escopo global, mas o restante do código não estará.

var ConnectionFactory = (function () {

    var stores = ['negociacoes'];
    var version = 4;
    var dbName = 'aluraframe';

    var connection = null;

    return class ConnectionFactory {

        constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
        }

//...
Agora, se fizermos um teste e chamarmos a ConnectionFactory no Console, veremos que todo o escopo da classe será mostrada.

Aplicamos o Module Pattern, com o qual transformamos todo o script em um módulo - o código está todo confinado. E depois, definimos qual parte queremos exportar para o mundo externo usando o return. A ConnectionFactory é acessada, mas todo o restante não. Com isto, resolvemos o problema de utilizarmos uma única conexão.
**************************************
05-Monkey Patch: grandes poderes trazem grandes responsabilidades
O design da ConnectionFactory está quase pronto. Eu não posso permitir que o desenvolvedor feche a conexão, como especificamos em uma das regras:

D) Toda conexão possui o método close, mas o programador não pode chamá-lo, porque a conexão é a mesma para a aplicação inteira.

Se a conexão é a mesma na aplicação inteira, caso o desenvolvedor chame o connection.close(), ela será fechada em todas as partes solicitadas.

> ConnectionFactory.getConnection().then(connection => connection.close()));
A única forma aceitável para que o desenvolvedor faça isso será da seguinte maneira:

> ConnectionFactory.closeConnection();
O desenvolvedor não poderá obter uma conexão e a partir desta, fechar, porque assim pode ocorrer um problema geral na aplicação. Para isto, vamos utilizar o Monkey Patch, que consiste forçarmos a modificação de uma API. No caso, nós iremos alterar o método close().

openRequest.onsuccess = e => {

    if(!connection) {
        connection = e.target.result;
        connection.close = function() {
              throw new Error('Você não pode fechar diretamente a conexão');
        };
    }
    resolve(connection);
}
Se o desenvolvedor tentar chamar o connection.close, ele receberá essa mensagem de erro. Vamos ver se o código está funcionando. Primeiramente, executaremos o console.log da connection:

> ConnectionFactory.getConnection().then(connection => console.log(connection));
E depois, testaremos o connection.close():

> ConnectionFactory.getConnection().then(connection => console.log(connection.close()));
mensagem de erro

Veremos um mensagem de erro. Funcionou! Nós fizemos um Monkey Patch do método close(), substituindo-o por um novo código que ignora o anterior e impede que o desenvolvedor feche a nossa conexão. Em seguida, adicionaremos o método closeConnection() para testar se existe uma connection. Caso exista, ele chamará o close e informará que connection é igual a null:

static closeConnection(){

    if(connection){
        connection.close();
        connection = null;

    }
}
Se alguém chamar o getConnection novamente, verá que a conexão é nula e obterá uma nova. No navegador, pediremos que ele faça a conexão e, depois, chamaremos o closeConnection:

> ConnectionFactory.closeConnection();
não conseguimos fechar a conexão

Mas não conseguimos fechar a conexão. Isto está ocorrendo porque nós destruímos método close() no onsuccess, logo, não conseguiremos chamá-lo no closeConnection. Como podemos resolver o problema? Começaremos adicionando uma variável close abaixo da connection:

var ConnectionFactory = (function() {

    var stores = ['negociacoes'];
    var version = 4;
    var dbName = 'aluraframe';

    var connection = null;
    var close = null;

    return  class ConnectionFactory {

        constructor() {

            throw new Error("ConnectionFactory não pode ser instanciada");
        }
//...
E adicionaremos o close no onsuccess:

openRequest.onsuccess = e => {

    if(!connection) {
        connection = e.target.result;
        close = connection.close;
        connection.close = function() {
              throw new Error('Você não pode fechar diretamente a conexão');
        };
    }
    resolve(connection);
}
Nós informamos que a variável close receberá a função close - que será sobrescrita a seguir. Chamaremos o método close() em closeConnection():

static closeConnection() {

    if(connection) {
        close();
        connection = null;
    }
}
A variável close guardou a função antes que esta fosse modificada. Vamos ver se funcionou no navegador, chamando o closeConnection:

ConnectionFactory.closeConnection();
illegal invocation

Recebemos uma mensagem de erro. Como o close pertence ao objeto connection, isto significa que o this do close será o connection. Mas quando pegamos o método e colocamos na variável close, ele perdeu o link com o connection e ao ser chamado, não conseguirá operar. Vimos anteriormente, que temos formas de contornarmos esta limitação. Quando estivermos copiando o close no onsuccess, faremos já associado com o connection utilizando o bind.

openRequest.onsuccess = e => {

    if(!connection) {
        connection = e.target.result;
        close = connection.close.bind(connection);
        connection.close = function() {
              throw new Error('Você não pode fechar diretamente a conexão');
        };
    }
    resolve(connection);
}
Agora, o this será a própria connection. Nós já fizemos algo parecido anteriormente nos cursos de JavaScript. Mas se não fizermos o Bind, será que temos outra opção? Sim, mas será um pouco mais trabalhosa. Removeremos o Bind do onsuccess:

openRequest.onsuccess = e => {

    if(!connection) {
        connection = e.target.result;
        close = connection.close;
        connection.close = function() {
              throw new Error('Você não pode fechar diretamente a conexão');
        };
    }
    resolve(connection);
}
E iremos chamar o método close(), usando o Reflect.apply. Teremos como contexto o connection e não receberá parâmetros.

static closeConnection() {

    if(connection) {
        Reflect.apply(close, connection, [])
        connection = null;
    }
}
Vamos testar no navegador.

reflect apply

Vimos que funciona a adoção do Reflect.apply. No entanto, continuaremos a usar o Bind, por ser uma solução mais simples.

Existe uma última melhoria que podemos fazer: observe que faz sentido reatribuirmos os valores das variáveis connection e close, pois dependendo da situação seus valores podem ser null. Contudo, não faz sentido em tempo de execução reatribuirmos os valores das variáveis dbName, version e stores. Podemos declará-las como constantes trocando var por const:

var ConnectionFactory = (function() {

    const stores = ['negociacoes'];
    const version = 4;
    const dbName = 'aluraframe';

    var connection = null;
    var close = null;
Com uma constante, não podemos reatribuir seu valor. Por exemplo, se tentarmos alterar o valor de dbName para calopsita, veja o que acontecerá ser recarregarmos o código:

mensagem de erro

Receberemos uma mensagem de erro... Não podemos reatribuir.

Isto não significa que os campos sejam imutáveis. Você poderá se aprofundar no assunto nos exercícios. Mas sempre que tivermos uma variável cujo valor não queremos que seja reatribuido, usaremos o const. Pratique o conteúdo fazendo os exercícios e mais adiante, implementaremos um novo padrão de projeto.
**************************************
06-exercícios - Esboço mínimo
Aprendemos a lidar com o IndexedDB no capítulo anterior. Contudo, precisamos organizar todo aquele código que escrevemos em algo mais legível e fácil de manter. O primeiro passo é quebrar o problema em dois, ou seja, termos uma classe especializada na criação da conexão e outra especializada nas operações de persistência (inclusão, remoção, etc.). Vamos atacar o primeiro problema, o da conexão.

Qual das opções abaixo possui o esboço da classe ConnectionFactory, que não nos permite criar instâncias a partir dela e que possui o método estático getConnection, cujo retorno é uma promise? Ah, e não esqueça que precisamos usar o operador new quando formos criar uma promise!

Alternativa correta
class ConnectionFactory {

    constructor() {

        throw new Error("ConnectionFactory não pode ser instanciada");
    }

    static getConnection() {

        return Promise((resolve, reject) => {

        });
    }
}

Aqui está faltando dar um new na criação da promise Promisse

Alternativa correta
class ConnectionFactory {

    constructor() {

        throw new Error("ConnectionFactory não pode ser instanciada");
    }

    static getConnection() {

        return new Promise((resolve, reject) => {

        });
    }
}

Está é a alternativa correta, veja a explicaçãod detalhada abaixo.

Alternativa correta
class ConnectionFactory {

    static getConnection() {

        return new Promise((resolve, reject) => {

        });
    }
}

Aqui falta o construtor que lança um erro ao tentar instanciar esta classe.

Alternativa correta
class ConnectionFactory {

    constructor() {

        throw new Error("ConnectionFactory não pode ser instanciada");
    }

    getConnection() {

        return new Promise((resolve, reject) => {

        });
    }
}

Veja que este método getConnection não está como static!

Para não permitir que sejam criadas instâncias de uma classe, podemos lançar uma exceção em seu constructor. Lembre-se que só queremos fazer isso porque estipulamos que a única maneira de obter a conexão é chamando um método estático da classe ConnectionFactory. Aliás, para que um método seja chamado diretamente da classe e não de uma instância, usamos o modificador static antes do nome do método.

A obtenção de uma conexão é um processo assíncrono, sendo assim, nada mais justo do que nosso método getConnection retornar uma promise para nos ajudar com a complexidade de códigos assíncronos.
**************************************
07-
**************************************
08-
**************************************
09-
**************************************
10-
**************************************
11-
**************************************
12-
**************************************
13-
**************************************