01-O padrão de projeto DAO
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui e continuar seus estudos.

Vamos continuar... Nós já temos a nossa ConnectionFactory, e sempre que quisermos usá-la, iremos chamá-la da seguinte forma:

ConnectionFactory
    .getConnection()
    .then(connection => {
    });
Pelo fato de termos uma conexão, abstraímos muita coisa. Nós já conseguimos organizar muita coisa do código de aprendendo_indexddb.html, um arquivo de difícil manutenção. Mas ainda temos as partes referentes à adição e à listagem...Vamos aplicar outro padrão de projeto para organizarmos a parte de persistência: usaremos o padrão DAO (Data Access Object). Normalmente, quando este é utilizado, ele abstrairá os detalhes de lidar com o banco.

ConnectionFactory
    .getConnection()
    .then(connection => {

        let dao = new NegociacaoDAO(connection);
        let negociacao = new Negociacao(new Date(), 1, 100);
        dao
            .adiciona(negociacao);
            .then() =>
          //*
});
Utilizamos uma convenção do padrão DAO na qual, se estamos fazendo uma persistência de Negociacao, usaremos NegociacaoDAO. Por sua vez, ele dependerá de uma connection para funcionar. Então, se observarmos o código, perceberemos que NegociacaoDAO foi criado para criar conexão e fazer a persistência da negociação. Isto significa que conseguimos resumir os métodos adiciona() e ListaTodos() neste trecho. Porém, o dao.adiciona também é uma Promise e podemos aproveitar o o resultado do then(), exibindo alguma mensagem para o usuário.

Esta será a lógica do padrão DAO que utilizaremos. Vamos começar a aplicá-la, criando a pasta dao e um novo arquivo: NegociacaoDao.js. A classe irá receber uma conexão no construtor.

class NegociacaoDao {

    constructor(connection) {

        this._connection = connection;
        this._store = 'negociacoes';
    }
}
Teremos duas propriedades privadas: _connection e _store. Elas só poderão ser utilizadas pelo DAO, que irá operar sobre a store negociacoes. A seguir, implementaremos o método adiciona().

adiciona() {

    return new Promise((resolve, reject) => {

    });
}
O método retornará uma Promise. Depois, começaremos a elaborar o processo de inclusão aproveitando o código de adiciona() gerando no aprendendo_indexddb.html no NegociacaoDAO.js:

adiciona(negociacao) {

      return new Promise((resolve, reject) => {

          let transaction = this._connection.transaction([this._store], 'readwrite');

          let store = transaction.objectStore(this._store);

          let request = store.add(negociacao);

      });
  }
Quando adicionarmos uma negociação, ela será passada para o DAO, a _connection abrirá uma transação para a _store: readwrite. No fim, pediremos para dar add. No entanto, temos a opção de encadear as chamadas das funções. Com as alterações, o trecho ficará da seguinte forma:


adiciona(negociacao) {

    return new Promise((resolve, reject) => {

        let request = this._connection
            .transaction([this._store],'readwrite')
            .objectStore(this._store)
            .add(negociacao);

    });
}
Ao chamarmos o add(), ele nos retornará o request. Em seguida, o request lidará com dois eventos : onsuccess e onerror. Quando tivermos sucesso, passaremos o resolve(), nos casos de erro, teremos o console.log:

class NegociacaoDao {

    constructor(connection) {

        this._connection = connection;
        this._store = 'negociacoes';
    }

    adiciona(negociacao) {

        return new Promise((resolve, reject) => {

            let request = this
                ._connection
                .transaction([this._store],"readwrite")
                .objectStore(this._store)
                .add(negociacao);

            request.onsuccess = (e) => {

                resolve();
            };

            request.onerror = e => {

                console.log(e.target.error);
                reject('Não foi possível adicionar a negociação');
            };                
        });
    }
}
Depois, importaremos o NegociacaoDAO.

<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script src="js/app/dao/NegociacaoDao.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>   
Agora, vamos fazer um teste no navegador. No Console, digitaremos:

ConnectionFactory.getConnection().then(connection => new NegociacaoDao(connection).adiciona(new Negociacao(new Date(), 7, 100)));
Veremos que ele gravou perfeitamente as negociações.

sucesso nas gravações

O Chrome tem um bug que não exibe a data da negociação, mas ela foi gravada corretamente.

Após criarmos o NegociacaoDao, iremos integrá-lo com a aplicação. É o que faremos mais adiante.
*****************************
02- Combinando padrões de projeto
Vamos integrar o NegociacaoDao com o NegociacaoController. Primeiramente, trabalharemos com o método adiciona(). Obteremos a conexão, adicionando o ConnectionFactory:

adiciona(event) {

    event.preventDefault();

    ConnectionFactory
        .getConnection()
        .then(conexao => {
          let negociacao = this._criaNegociacao();
          new NegociacaoDao(conexao)
              .adiciona(negociacao)

        });
Chamamos o _criaNegociacao(), responsável por criar os dados do formulário. Além de adicionarmos no IndexedDB, precisaremos também adicionar a negociação na _listaNegociacoes para refletir o que é visto pelo usuário. Porém, tal ação só será possível se gravarmos a negociação no banco. Para termos a confirmação sobre a gravação do dado, usaremos o then() do adiciona().

  ConnectionFactory
      .getConnection()
      .then(conexao => {
        let negociacao = this._criaNegociacao();
        new NegociacaoDao(conexao)
            .adiciona(negociacao)
            .then(() => {
            })
      });
No DAO, nós chamamos o resolve() que será o responsável por executar o then().

  return new Promise((resolve, reject) => {

      let request = this
          ._connection
          .transaction([this._store],"readwrite")
          .objectStore(this._store)
          .add(negociacao);
      request.onsuccess = (e) => {
          resolve();
      };
//...
Se tivéssemos passado um parâmetro para resolve(), seu valor seria repassado para o then(). Mas nós não queremos passar valores como parâmetros para nenhum dos dois, queremos apenas resolver a nossa Promise. Se tudo der certo, o código no then() será executado. Vamos reaproveitar partes do código do antigo try do NegociacaoController.

.then(() => {
    this._listaNegociacoes.adiciona(negociacao());
    this._mensagem.texto = 'Negociação adicionada com sucesso';
    this._limpaFormulario();
  })
Após alterarmos o texto, limparemos o formulário. Também aproveitaremos o event.preventDefault().

adiciona(event) {

        event.preventDefault();

        ConnectionFactory
            .getConnection()
            .then(conexao => {

                let negociacao = this._criaNegociacao();

                new NegociacaoDao(conexao)
                    .adiciona(negociacao)
                    .then(() => {
                        this._listaNegociacoes.adiciona(negociacao);
                        this._mensagem.texto = 'Negociação adicionada com sucesso';
                        this._limpaFormulario();   
                    });
        })
        .catch(erro => this._mensagem.texto = erro);
Nós não teremos um try/catch. Para o tratamento de erro usaremos o catch e o erro capturado será exibido para o usuário. Como só trabalhamos com uma instrução, não precisamos adicionar o bloco. Mas se conseguirmos obter a conexão, e dela instanciaremos um DAO, por meio dele vamos instanciar a negociacao. Logo, poderemos adicionar a negociação no modelo. Mas o fato de gravarmos no banco, não significa que os dados serão exibidos na tela, teremos que gravar também na _listaNegociacoes. Com o data binding criado por nós, depois de adicionarmos a negociação na lista, ela será automaticamente refletida para o usuário.

Vamos recarregar a página e preencher os dados nos campos do formulário.

negociacao adicionada com sucesso

Podemos visualizar a mensagem e os dados sendo exibidos na tabela. Isto significa que conseguimos gravar as informações no banco. Se acessarmos a aba "Application", veremos que os dados da nova negociação também foram adicionados.

dados da negociacao

Observe que ele salvou os dados como String, o ideal seria salvá-los como números. Para resolvermos isto, no _criaNegociacao, vamos garantir que o valor de "quantidade" será inteiro, adicionando o parseInt(). E com o parseFloat no value, podemos trabalhar um número decimal:

_criaNegociacao() {

   return new Negociacao(
       DateHelper.textoParaData(this._inputData.value),
       parseInt(this._inputQuantidade.value),
       parseFloat(this._inputValor.value));
}
Se testarmos no navegador, veremos que os dados serão salvos no banco já usando as novas configurações.

dados numericos

Se cadastrarmos valores decimais no campo de "Valor", veremos que ele será gravado inclusive com os valores decimais.

Agora, vamos resolver o problema das inclusões. Queremos que ao recarregarmos a página no navegador, as negociações salvas no banco sejam reexibidas. Ou seja, traremos as negociações do banco e, depois, estas serão exibidas para o usuário.
*****************************
03-
*****************************
04-
*****************************
05-
*****************************
06-
*****************************
07-
*****************************
08-
*****************************
09-
*****************************
10-
*****************************