01-Ops! Não podemos importar negociações duplicadas.
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto do capítulo anterior e continuar seus estudos a partir deste capítulo.

Atualmente, precisamos clicar no botão Importar Negociações para obtermos as negociações das semanas. Contudo, em nenhum momento verificamos se as negociações trazidas do servidor já existem em nossa lista. Com certeza não queremos importar as mesmas negociações mais de uma vez, inclusive aquelas incluídas através da página post.html que criamos no curso anterior.

Vamos relembrar o método importaNegociacoes() de NegociacaoController:

// aluraframe/client/js/app/controllers/NegociacaoController.js

// código anterior omitido

importaNegociacoes() {


    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'   
        }))
        .catch(erro => this._mensagem.texto = erro);               
}

//...
O método service.obterNegociacoes() retorna uma promise, cujo o método then nos retorna as negociações da semana, semana anterior e semana retrasada. Iteramos nas negociações adicionando cada uma delas em nosso modelo. Devido ao mecanismo caseiro de data binding que criamos, toda vez que a lista for modificada, automaticamente a view que a apresenta será atualizada automaticamente, sem termos que manipular o DOM diretamente.

A pegadinha do Array.indexOf e a poderosa função filter
O primeiro passo é garantirmos que a lista de negociações iterada tenha apenas aquelas que ainda não existem em this._listaNegociacoes.negociacoes. A ideia é filtrarmos essa lista usando a função filter, que já vimos nos cursos anteriores.

Lembre-se que a função filter precisa receber um critério que será aplicado para cada elemento individualmente. Cada elemento só fará parte da nova lista filtrada se o critério aplicado sobre ele retornar true.

// aluraframe/client/js/app/controllers/NegociacaoController.js

// código anterior omitido

importaNegociacoes() {


    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes => 
            negociacoes.filter(negociacao => true)
         )     
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'   
        }))
        .catch(erro => this._mensagem.texto = erro);               
}
//...
E se usarmos o método indexOf() que todo array possui para sabermos se o elemento existe ou não? Só queremos considerar aqueles que não existem, ou seja, cujo valor de indexOf é -1.

// aluraframe/client/js/app/controllers/NegociacaoController.js

// código anterior omitido

importaNegociacoes() {


    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes => 
            negociacoes.filter(negociacao =>  
                      this._listaNegociacoes.negociacoes.indexOf(negociacao) == -1)
       )
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'   
        }))
        .catch(erro => this._mensagem.texto = erro);               
}
// ...
Veja que usamos a forma simplificada da arrow function, aquela que não usa bloco. Quando usamos essa forma, não precisamos usar a instrução return, pois ela fica implícita.

Vamos testar, clicando mais de uma vez no botão Importar Negociações? O que acontece? Um problema! Veja que nosso código não funcionou como esperado, pois importamos mais de uma vez as mesmas negociações. O problema está no entendimento do indexOf, que funciona de um jeito um pouco diferente do que imaginamos. Ele não resolverá o nosso problema de procurar um objeto dentro do array.
*****************************
02-Comparação entre objetos
Vamos entender o porquê do indexOf() nos deixar na mão... No console, executaremos as seguintes instruções:

var hoje = new Date();

var n1 = new Negociacao(hoje, 1, 100);
var n2 = new Negociacao(hoje, 1, 100);

n1 == n2 // o resultado é false
Usamos var, porque não estamos dentro de um bloco. Outros browsers podem reclamar se usarmos a palavra let.

O retorno será false, porém, n1 e n2 são iguais. Ambos tem a mesma data, mesma quantidade e mesmo valor. Nós criamos a variável n1, e esta apontará para algo que está na memória. Quando executamos o new Negociacao, o JavaScript criará o objeto Negociacao, em que teremos a data, a quantidade e o valor. A variável n1 apontará para o objeto recém criado na memória. N1 é uma variável de referência que o programa tem para acessar o objeto que está na memória, que criamos com o new. Quando criamos o N2 e damos new Negociacao, criaremos um novo objeto em memória do tipo Negociacao, que terá a data de hoje, a quantidade e o valor. O N1 apontará para o objeto na memória. Ou seja, N1 e N2 apontará para objetos diferentes. Então, quando digitamos o n1 == n2, o que o JavaScript faz é verificar se a variável em 1 está apontando para outra. Como ele não está, o retorno será falso. Por isso, o indexOf não funcionou, porque ele também utilizou o == por "debaixo dos panos".

Nós temos a lista de negociações que está no nosso modelo, quando o trazemos do Back-end, nós criamos o objeto de novo na memória. Nós recebemos um JSON, e transformamos isto em objetos da memória. Logo, o indexOf não está comparando o conteúdo - o valor do objeto - mas sim, se as variáveis estão apontando para outra. Se digitarmos n1 = n2, veremos o seguinte retorno:

retorno de n1 igual a n2

Agora, N1 apontará para a mesma negociação de N2, ou seja, o mesmo objeto na memória. Ao testarmos, o retorno será true, veremos que os dois são iguais.

E o objeto que não é mais acessado, e não tem mais nenhuma variável de referência, será destruído pelo Garbage Colector do JS, liberando memória. A grande questão é que o operador == não pode ser usado para comparar objetos.

Mas existe uma peculiaridade... Em JavaScript, sempre trabalhamos com objetos. Veremos isso no exemplo abaixo:

var nome1 = 'Flávio';
var nome2 = 'Flávio';

nome1 == nome2 // o resultado é true
Ao compararmos nome1 com o nome2, o retorno será true. O mesmo ocorrerá com números...

var x = 10;
var y = 10;

x == y // o resultado é true
Ele dirá que x e y são igual. Por que isto ocorreu? Quando usamos o == com tipos literais (ou tipos primitivos, em Java), como string, number e boolean, ele não verificará se as variáveis apontam para o mesmo objeto da memória, ele compara se os valores são iguais. Então, nos casos acima, não há problemas... Mas o mesmo não acontecerá com outros tipos de objeto, por exemplo, um date. Nós temos dois objetos de memória:

var n1 = new Negociacao(hoje, 1, 100);
var n2 = new Negociacao(hoje, 1, 100);
Agora, se digitarmos n1.data == n2.data, fique atento! Observe que n1 e n2 está recebendo o mesmo objeto hoje, o retorno deveria ser true... Porém, não será assim.

retorno false

Isto ocorreu porque o construtor da nossa classe recebeu a data e cria um novo date a partir do getTime(). Com isso, um novo objeto será criado na memória e por isso, a comparação não terá o resultado "true". Como vimos anteriormente, com tipos literais, podemos usar ==. Uma solução é, em vez de compararmos uma variável de referência com outra, podemos comparar as propriedades dos objetos. Faremos o seguinte teste:

n1.data == n2.data // o resultado é false
Mas o resultado será false. No entanto, se fizermos apenas n1.data.getDate(), o retorno será um número:

retorno será numero

Agora, se fizermos a seguinte comparação:

n1.data.getDate() == n2.data.getDate() // o resultado é true
O retorno será "verdadeiro". Como getDate é um number, conseguimos fazer a comparação com o operador ==.

Em seguida, passaremos a seguinte instrução:

n1.data.getDate() == n2.data.getDate() && n1.quantidade == n2.quantidade && n1.valor == n2.valor // o resultado é true
O retorno será verdadeiro. A nossa comparação não foi feita entre as variáveis, mas sim, entre as duas propriedades diretamente. Como estas eram do tipo literal, a comparação deu certo. No entanto, e se o objeto tivesse 100 propriedades? Fazer a comparação dessa forma seria muito trabalhoso e inviável. Uma estratégia que podemos utilizar é transformar o objeto em uma string. Já vimos que com JSON.parse transformamos uma string em um objeto. Usaremos o JSON.stringify():

JSON.stringify(n1) == JSON.stringify(n2) // o resultado é true
O retorno será verdadeiro. É interessante usar o stringify() quando queremos comparar um objeto com outro, no entanto, não será útil se quisermos descobrir se as variáveis apontam para um mesmo objeto. Nós serializamos o objeto, transformando-o em uma string.
*****************************
03-Usando o método some
Agora que aprendemos a fazer a comparação, temos um outro problema. Quando voltamos ao nosso código, a função filter() receberá "verdadeiro" ou "falso", porque ela vai varrer cada item da lista. Caso o retorno seja true, o item será adicionado a lista. Se for false, o item será excluído. Antes, poderíamos colocar a instrução dentro do filter, considerando que o indexOf varria o listaNegociacoes procurando a negociação. Porém, não poderemos mais fazer desta forma. Se adicionássemos o JSON.stringify(), o código ficaria assim:

importaNegociacoes() {

    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes =>
            negociacoes.filter(negociacao =>
              JSON.stringify(negociacao) ==

            )
        )
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'
        }))
        .catch(erro => this._mensagem.texto = erro);
Desta forma, teremos que verificar se a negociação serializada existe dentro de _listaNegociacoes, por isso, vamos ter que varrer a lista também. Nosso código começa a ficar mais complicado. Para facilitar, usaremos uma função do ECMAScript 5 pouco usada: a some()... Vamos ver um exemplo:

var letras = ['a', 'b', 'c', 'd']
letras.some()
Todo array possui a função some(), com ela identificamos se o item buscado faz parte da lista, varrendo cada um deles de forma semelhante a um forEach().

função some

Vamos fazer um teste e buscar pela letra b.

letras.some(letra => letra == 'b');
A função some() vai varrer cada item da lista verificando se os elementos são iguais ao critério estabelecido. Enquanto o item for diferente, ele seguirá para o próximo. Quando o elemento for equivalente ao critério b,letras retornará true e não seguirá iterando no array até o fim. Basta encontrar um item que seja correspondente ao critério para que o retorno de some() seja "verdadeiro".

No entanto, quando buscamos uma letra que não existe, por exemplo, a letra e, o retorno será "falso".

retorno falso

Veremos como podemos usar o some() no código.

importaNegociacoes() {

    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes =>
            negociacoes.filter(negociacao =>
                !this._listaNegociacoes.negociacoes.some(negociacaoExistente =>
                    JSON.stringify(negociacao) == JSON.stringify(negociacaoExistente)))
        )
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'
        }))
        .catch(erro => this._mensagem.texto = erro);
Estamos fazendo o filtro que varrerá todos os elementos. O primeiro array que será testado (this._listaNegociacoes) verificará se cada item já existente é igual a negociação filtrada. Caso seja equivalente, o some() retornará "verdadeiro" e o item entrará no filtro de negociações. Como nosso objetivo é que o some() retorne "verdadeiro", caso ele siga até o final do array sem encontrar um elemento igual ao filtro, usaremos o sinal de exclamação (!). Com isto, no próximo encadeamento da função then(), teremos as negociações que não existem dentro de _listaNegociacoes.negociacoes.

Se executarmos o código, veremos que quando clicarmos no botão "Importar Negociações", nenhuma negociação será adicionada, porque não foram cadastrados novos dados no formulário. Para fazermos um teste, adicionaremos uma nova negociação e, desta vez, a tabela será alterada.

nova negociacao adicionada

Apenas a nova negociação foi importada, enquanto as demais foram ignoradas.

Nós conseguimos, misturando os conceitos de Promise, misturando funções do ECMAScript5 ( filter, some...) e usando o artifício de serializar um objeto para saber se ele existe ou não, nós conseguimos filtrar a nossa lista e passando para o próximo encadeamento de then() apenas as negociações que não existem de _listaNegociacoes. Com essas melhorias, vimos vários conteúdos novos.
*****************************
04-Importando negociações automaticamente
Vamos melhorar outro ponto da experiência do usuário para não dependermos do clique no botão "Importar Negociações" e evitarmos perder alguma atualização recente. Por isso, removeremos o botão do arquivo index.html. E agora, como faremos para importar? Queremos que o JavaScript chame o método importaNegociacoes()do controller a cada determinado período de tempo.

Faremos isto na inicialização do NegociacaoController.js, adicionando no construtor da classe o setInterval no importaNegociacoes(). Definiremos uma período a cada 3 segundos (3000).

setInterval(() => {
    this.importaNegociacoes();
}, 3000);
Agora, o método não será mais chamado pelo botão, ele será chamado a cada 3 segundos e as negociações serão trazidas do servidor. Podemos até incluir novas negociações acessando o http://localhost:3000/post.html. Logo, em seguida ela será adicionada na tabela.

negociacoes do periodo importadas

Conseguimos melhorar a experiência do usuário.

Você tem a opção de remover a mensagem que confirma a importação das negociações do período. Aqui no curso, optamos por manter.

Mas tem algo que pode nos trazer problema. A boa prática diz que no constructor, só devemos utilizar os atributos da classe. Porém, no caso, nós temos o ConnectionFactory, o setInterval. Para facilitar a manutenção, vamos mover essas duas lógicas para dentro do método privado que criaremos a seguir: o _init(). Depois, iremos chamar o método no fim do constructor. Com as alterações o código ficou assim:

constructor() {

    // propriedades da classe omitidas

    this._init();
}
_init() {

    ConnectionFactory
        .getConnection()
        .then(connection => new NegociacaoDao(connection))
        .then(dao => dao.listaTodos())
        .then(negociacoes =>
            negociacoes.forEach(negociacao =>
              this._listaNegociacoes.adiciona(negociacao)))
        .catch(erro => {
            console.log(erro);
            this._mensagem.texto = erro;
        });

        setInterval(() => {
            this.importaNegociacoes();
        }, 3000);
}
O _init só poderá ser chamado pela própria classe. Se testarmos o formulário no navegador, veremos novamente a mensagem que confirma a importação das negociações e são atualizadas automaticamente. Mas ainda tem mais coisas que podemos melhorar.
*****************************
05-
*****************************
06-
*****************************
07-
*****************************
08-
*****************************
09-
*****************************
10-
*****************************
11-
*****************************
12-
*****************************
13-
*****************************
14-
*****************************
