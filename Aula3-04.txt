01-Ops! Não podemos importar negociações duplicadas.
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto do capítulo anterior e continuar seus estudos a partir deste capítulo.

Atualmente, precisamos clicar no botão Importar Negociações para obtermos as negociações das semanas. Contudo, em nenhum momento verificamos se as negociações trazidas do servidor já existem em nossa lista. Com certeza não queremos importar as mesmas negociações mais de uma vez, inclusive aquelas incluídas através da página post.html que criamos no curso anterior.

Vamos relembrar o método importaNegociacoes() de NegociacaoController:

// aluraframe/client/js/app/controllers/NegociacaoController.js

// código anterior omitido

importaNegociacoes() {


    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'   
        }))
        .catch(erro => this._mensagem.texto = erro);               
}

//...
O método service.obterNegociacoes() retorna uma promise, cujo o método then nos retorna as negociações da semana, semana anterior e semana retrasada. Iteramos nas negociações adicionando cada uma delas em nosso modelo. Devido ao mecanismo caseiro de data binding que criamos, toda vez que a lista for modificada, automaticamente a view que a apresenta será atualizada automaticamente, sem termos que manipular o DOM diretamente.

A pegadinha do Array.indexOf e a poderosa função filter
O primeiro passo é garantirmos que a lista de negociações iterada tenha apenas aquelas que ainda não existem em this._listaNegociacoes.negociacoes. A ideia é filtrarmos essa lista usando a função filter, que já vimos nos cursos anteriores.

Lembre-se que a função filter precisa receber um critério que será aplicado para cada elemento individualmente. Cada elemento só fará parte da nova lista filtrada se o critério aplicado sobre ele retornar true.

// aluraframe/client/js/app/controllers/NegociacaoController.js

// código anterior omitido

importaNegociacoes() {


    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes => 
            negociacoes.filter(negociacao => true)
         )     
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'   
        }))
        .catch(erro => this._mensagem.texto = erro);               
}
//...
E se usarmos o método indexOf() que todo array possui para sabermos se o elemento existe ou não? Só queremos considerar aqueles que não existem, ou seja, cujo valor de indexOf é -1.

// aluraframe/client/js/app/controllers/NegociacaoController.js

// código anterior omitido

importaNegociacoes() {


    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes => 
            negociacoes.filter(negociacao =>  
                      this._listaNegociacoes.negociacoes.indexOf(negociacao) == -1)
       )
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'   
        }))
        .catch(erro => this._mensagem.texto = erro);               
}
// ...
Veja que usamos a forma simplificada da arrow function, aquela que não usa bloco. Quando usamos essa forma, não precisamos usar a instrução return, pois ela fica implícita.

Vamos testar, clicando mais de uma vez no botão Importar Negociações? O que acontece? Um problema! Veja que nosso código não funcionou como esperado, pois importamos mais de uma vez as mesmas negociações. O problema está no entendimento do indexOf, que funciona de um jeito um pouco diferente do que imaginamos. Ele não resolverá o nosso problema de procurar um objeto dentro do array.
*****************************
02-Comparação entre objetos
Vamos entender o porquê do indexOf() nos deixar na mão... No console, executaremos as seguintes instruções:

var hoje = new Date();

var n1 = new Negociacao(hoje, 1, 100);
var n2 = new Negociacao(hoje, 1, 100);

n1 == n2 // o resultado é false
Usamos var, porque não estamos dentro de um bloco. Outros browsers podem reclamar se usarmos a palavra let.

O retorno será false, porém, n1 e n2 são iguais. Ambos tem a mesma data, mesma quantidade e mesmo valor. Nós criamos a variável n1, e esta apontará para algo que está na memória. Quando executamos o new Negociacao, o JavaScript criará o objeto Negociacao, em que teremos a data, a quantidade e o valor. A variável n1 apontará para o objeto recém criado na memória. N1 é uma variável de referência que o programa tem para acessar o objeto que está na memória, que criamos com o new. Quando criamos o N2 e damos new Negociacao, criaremos um novo objeto em memória do tipo Negociacao, que terá a data de hoje, a quantidade e o valor. O N1 apontará para o objeto na memória. Ou seja, N1 e N2 apontará para objetos diferentes. Então, quando digitamos o n1 == n2, o que o JavaScript faz é verificar se a variável em 1 está apontando para outra. Como ele não está, o retorno será falso. Por isso, o indexOf não funcionou, porque ele também utilizou o == por "debaixo dos panos".

Nós temos a lista de negociações que está no nosso modelo, quando o trazemos do Back-end, nós criamos o objeto de novo na memória. Nós recebemos um JSON, e transformamos isto em objetos da memória. Logo, o indexOf não está comparando o conteúdo - o valor do objeto - mas sim, se as variáveis estão apontando para outra. Se digitarmos n1 = n2, veremos o seguinte retorno:

retorno de n1 igual a n2

Agora, N1 apontará para a mesma negociação de N2, ou seja, o mesmo objeto na memória. Ao testarmos, o retorno será true, veremos que os dois são iguais.

E o objeto que não é mais acessado, e não tem mais nenhuma variável de referência, será destruído pelo Garbage Colector do JS, liberando memória. A grande questão é que o operador == não pode ser usado para comparar objetos.

Mas existe uma peculiaridade... Em JavaScript, sempre trabalhamos com objetos. Veremos isso no exemplo abaixo:

var nome1 = 'Flávio';
var nome2 = 'Flávio';

nome1 == nome2 // o resultado é true
Ao compararmos nome1 com o nome2, o retorno será true. O mesmo ocorrerá com números...

var x = 10;
var y = 10;

x == y // o resultado é true
Ele dirá que x e y são igual. Por que isto ocorreu? Quando usamos o == com tipos literais (ou tipos primitivos, em Java), como string, number e boolean, ele não verificará se as variáveis apontam para o mesmo objeto da memória, ele compara se os valores são iguais. Então, nos casos acima, não há problemas... Mas o mesmo não acontecerá com outros tipos de objeto, por exemplo, um date. Nós temos dois objetos de memória:

var n1 = new Negociacao(hoje, 1, 100);
var n2 = new Negociacao(hoje, 1, 100);
Agora, se digitarmos n1.data == n2.data, fique atento! Observe que n1 e n2 está recebendo o mesmo objeto hoje, o retorno deveria ser true... Porém, não será assim.

retorno false

Isto ocorreu porque o construtor da nossa classe recebeu a data e cria um novo date a partir do getTime(). Com isso, um novo objeto será criado na memória e por isso, a comparação não terá o resultado "true". Como vimos anteriormente, com tipos literais, podemos usar ==. Uma solução é, em vez de compararmos uma variável de referência com outra, podemos comparar as propriedades dos objetos. Faremos o seguinte teste:

n1.data == n2.data // o resultado é false
Mas o resultado será false. No entanto, se fizermos apenas n1.data.getDate(), o retorno será um número:

retorno será numero

Agora, se fizermos a seguinte comparação:

n1.data.getDate() == n2.data.getDate() // o resultado é true
O retorno será "verdadeiro". Como getDate é um number, conseguimos fazer a comparação com o operador ==.

Em seguida, passaremos a seguinte instrução:

n1.data.getDate() == n2.data.getDate() && n1.quantidade == n2.quantidade && n1.valor == n2.valor // o resultado é true
O retorno será verdadeiro. A nossa comparação não foi feita entre as variáveis, mas sim, entre as duas propriedades diretamente. Como estas eram do tipo literal, a comparação deu certo. No entanto, e se o objeto tivesse 100 propriedades? Fazer a comparação dessa forma seria muito trabalhoso e inviável. Uma estratégia que podemos utilizar é transformar o objeto em uma string. Já vimos que com JSON.parse transformamos uma string em um objeto. Usaremos o JSON.stringify():

JSON.stringify(n1) == JSON.stringify(n2) // o resultado é true
O retorno será verdadeiro. É interessante usar o stringify() quando queremos comparar um objeto com outro, no entanto, não será útil se quisermos descobrir se as variáveis apontam para um mesmo objeto. Nós serializamos o objeto, transformando-o em uma string.
*****************************
03-Usando o método some
Agora que aprendemos a fazer a comparação, temos um outro problema. Quando voltamos ao nosso código, a função filter() receberá "verdadeiro" ou "falso", porque ela vai varrer cada item da lista. Caso o retorno seja true, o item será adicionado a lista. Se for false, o item será excluído. Antes, poderíamos colocar a instrução dentro do filter, considerando que o indexOf varria o listaNegociacoes procurando a negociação. Porém, não poderemos mais fazer desta forma. Se adicionássemos o JSON.stringify(), o código ficaria assim:

importaNegociacoes() {

    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes =>
            negociacoes.filter(negociacao =>
              JSON.stringify(negociacao) ==

            )
        )
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'
        }))
        .catch(erro => this._mensagem.texto = erro);
Desta forma, teremos que verificar se a negociação serializada existe dentro de _listaNegociacoes, por isso, vamos ter que varrer a lista também. Nosso código começa a ficar mais complicado. Para facilitar, usaremos uma função do ECMAScript 5 pouco usada: a some()... Vamos ver um exemplo:

var letras = ['a', 'b', 'c', 'd']
letras.some()
Todo array possui a função some(), com ela identificamos se o item buscado faz parte da lista, varrendo cada um deles de forma semelhante a um forEach().

função some

Vamos fazer um teste e buscar pela letra b.

letras.some(letra => letra == 'b');
A função some() vai varrer cada item da lista verificando se os elementos são iguais ao critério estabelecido. Enquanto o item for diferente, ele seguirá para o próximo. Quando o elemento for equivalente ao critério b,letras retornará true e não seguirá iterando no array até o fim. Basta encontrar um item que seja correspondente ao critério para que o retorno de some() seja "verdadeiro".

No entanto, quando buscamos uma letra que não existe, por exemplo, a letra e, o retorno será "falso".

retorno falso

Veremos como podemos usar o some() no código.

importaNegociacoes() {

    let service = new NegociacaoService();
    service
        .obterNegociacoes()
        .then(negociacoes =>
            negociacoes.filter(negociacao =>
                !this._listaNegociacoes.negociacoes.some(negociacaoExistente =>
                    JSON.stringify(negociacao) == JSON.stringify(negociacaoExistente)))
        )
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'
        }))
        .catch(erro => this._mensagem.texto = erro);
Estamos fazendo o filtro que varrerá todos os elementos. O primeiro array que será testado (this._listaNegociacoes) verificará se cada item já existente é igual a negociação filtrada. Caso seja equivalente, o some() retornará "verdadeiro" e o item entrará no filtro de negociações. Como nosso objetivo é que o some() retorne "verdadeiro", caso ele siga até o final do array sem encontrar um elemento igual ao filtro, usaremos o sinal de exclamação (!). Com isto, no próximo encadeamento da função then(), teremos as negociações que não existem dentro de _listaNegociacoes.negociacoes.

Se executarmos o código, veremos que quando clicarmos no botão "Importar Negociações", nenhuma negociação será adicionada, porque não foram cadastrados novos dados no formulário. Para fazermos um teste, adicionaremos uma nova negociação e, desta vez, a tabela será alterada.

nova negociacao adicionada

Apenas a nova negociação foi importada, enquanto as demais foram ignoradas.

Nós conseguimos, misturando os conceitos de Promise, misturando funções do ECMAScript5 ( filter, some...) e usando o artifício de serializar um objeto para saber se ele existe ou não, nós conseguimos filtrar a nossa lista e passando para o próximo encadeamento de then() apenas as negociações que não existem de _listaNegociacoes. Com essas melhorias, vimos vários conteúdos novos.
*****************************
04-Importando negociações automaticamente
Vamos melhorar outro ponto da experiência do usuário para não dependermos do clique no botão "Importar Negociações" e evitarmos perder alguma atualização recente. Por isso, removeremos o botão do arquivo index.html. E agora, como faremos para importar? Queremos que o JavaScript chame o método importaNegociacoes()do controller a cada determinado período de tempo.

Faremos isto na inicialização do NegociacaoController.js, adicionando no construtor da classe o setInterval no importaNegociacoes(). Definiremos uma período a cada 3 segundos (3000).

setInterval(() => {
    this.importaNegociacoes();
}, 3000);
Agora, o método não será mais chamado pelo botão, ele será chamado a cada 3 segundos e as negociações serão trazidas do servidor. Podemos até incluir novas negociações acessando o http://localhost:3000/post.html. Logo, em seguida ela será adicionada na tabela.

negociacoes do periodo importadas

Conseguimos melhorar a experiência do usuário.

Você tem a opção de remover a mensagem que confirma a importação das negociações do período. Aqui no curso, optamos por manter.

Mas tem algo que pode nos trazer problema. A boa prática diz que no constructor, só devemos utilizar os atributos da classe. Porém, no caso, nós temos o ConnectionFactory, o setInterval. Para facilitar a manutenção, vamos mover essas duas lógicas para dentro do método privado que criaremos a seguir: o _init(). Depois, iremos chamar o método no fim do constructor. Com as alterações o código ficou assim:

constructor() {

    // propriedades da classe omitidas

    this._init();
}
_init() {

    ConnectionFactory
        .getConnection()
        .then(connection => new NegociacaoDao(connection))
        .then(dao => dao.listaTodos())
        .then(negociacoes =>
            negociacoes.forEach(negociacao =>
              this._listaNegociacoes.adiciona(negociacao)))
        .catch(erro => {
            console.log(erro);
            this._mensagem.texto = erro;
        });

        setInterval(() => {
            this.importaNegociacoes();
        }, 3000);
}
O _init só poderá ser chamado pela própria classe. Se testarmos o formulário no navegador, veremos novamente a mensagem que confirma a importação das negociações e são atualizadas automaticamente. Mas ainda tem mais coisas que podemos melhorar.
*****************************
05-Melhorando a legibilidade e manutenção do nosso código

Será que podemos melhorar o nosso código ainda mais? Com certeza! Observe que em todas as partes em que é preciso interagir com o IndexedDB, tivemos que criar uma conexão e passa-la para o construtor do DAO. Então realizarmos uma série de operações com o resultado. Veja que repetimos isso em vários trechos de código:

ConnectionFactory
    .getConnection()
    .then(connection => new NegociacaoDao(connection))
O desenvolvedor precisa ficar atento a muitos detalhes para trabalhar com o código, por exemplo, vamos analisar o NegociacaoController.js, que adiciona uma negociação no banco local:

// js/app/controllers/NegociacaoController.js

// código anterior omitido

    adiciona(event) {

        event.preventDefault();

        ConnectionFactory
            .getConnection()
            .then(conexao => {

                let negociacao = this._criaNegociacao();

                new NegociacaoDao(conexao)
                    .adiciona(negociacao)
                    .then(() => {
                        this._listaNegociacoes.adiciona(negociacao);
                        this._mensagem.texto = 'Negociação adicionada com sucesso'; 
                        this._limpaFormulario();   
                    });

        })
        .catch(erro => this._mensagem.texto = erro);

    }

//...
Queremos algo assim:

    adiciona(event) {

        event.preventDefault();

        let negociacao = this._criaNegociacao();

        new NegociacaoService.cadastra(negociacao)
            .then(mensagem => {
                this._listaNegociacoes.adiciona(negociacao);
                this._mensagem.texto = mensagem; 
                this._limpaFormulario();  
            }).catch(erro => this._mensagem.texto = erro);
    }
O exemplo de código anterior esconde a complexidade de se lidar com a conexão, inclusive com a criação do DAO. Preparado para melhorar nosso código?

Vamos editar aluframe/client/js/app/services/NegociacaoService.js e adicionar o método cadastra(), que receberá uma negociação:

class NegociacaoService {

    constructor() {

        this._http = new HttpService();
    }
    // código anterior omitido 

    cadastra(negociacao) {        
    }

}
Agora, vamos mover o código que está no método adiciona() de NegociacaoController, para dentro do método cadastra() de NegociacaoService, exceto a instrução event.preventDefault():

class NegociacaoService {

    constructor() {
        this._http = new HttpService();
    }

    // código anterior omitido 

    cadastra(negociacao) {

         ConnectionFactory
            .getConnection()
            .then(conexao => {

                // VEJA QUE ISSO NÃO FAZ MAIS SENTIDO!
                let negociacao = this._criaNegociacao();

                new NegociacaoDao(conexao)
                    .adiciona(negociacao)
                    .then(() => {
                        this._listaNegociacoes.adiciona(negociacao);
                        this._mensagem.texto = 'Negociação adicionada com sucesso'; 
                        this._limpaFormulario();   
                  });
        })
        .catch(erro => this._mensagem.texto = erro);
    }
}
Observe que o método cadastra recebe como parâmetro a negociação que será incluída, é por isso que podemos remover a instrução que constrói uma negociação usando this._criaNegociacao() e as instruções que interagem com propriedades de NegociacaoController. Podemos até remover alguns blocos da nossa promise, para tornar o código mais enxuto:

class NegociacaoService {
    constructor() {
        this._http = new HttpService();
    }
    // código anterior omitido 

    cadastra(negociacao) {
         return ConnectionFactory
            .getConnection()
            .then(conexao => new NegociacaoDao(conexao))
            .then(dao => dao.adiciona(negociacao))
            .then(() => 'Negociação cadastrada com sucesso')
            .catch(erro => {
                throw new Error("Não foi possível adicionar a negociação")
            });
    }
}
Vamos analisar e relembrar o que aprendemos nos cursos anteriores. Realizamos uma série de operações encadeadas a partir de .getConnection(). Como este método retorna uma promise, temos acesso ao seu resultado, a conexão, na próxima chamada de then. Não queremos trabalhar com uma conexão, mas com um DAO, por isso, fizemos:

.then(conexao => new NegociacaoDao(conexao)) 
Como não usamos bloco, o retorno é automático e será uma instância de NegociacaoDao, que teremos acesso na próxima chamada ao método then. Agora que temos o DAO, podemos adicionar uma negociação. Como o método adiciona() do nosso DAO também retorna uma promise, quando a operação for concluída, o código da próxima chamada do then será executado.

Como dao.adiciona não retorna nenhum valor, ele simplesmente insere no banco, passamos nossa próxima chamada do then, ficando then(() =>). Veja que retornamos a string "Negociação cadastrada com sucesso". Esse valor será disponibilizado para quem chamar método cadastra(), quando for executado com sucesso. Em catch, logamos o erro e lançamos uma exceção que fará o catch() de quem está usando o cadastra ser executado.

Agora, vamos alterar o método adiciona de NegociacaoController para que faça uso do novo método de NegociacaoService:

// aluraframe/client/js/app/controller/NegociacaoController.js

    adiciona(event) {

        event.preventDefault();

        let negociacao = this._criaNegociacao();

        new NegociacaoService()
            .cadastra(negociacao)
            .then(mensagem => {
                this._listaNegociacoes.adiciona(negociacao);
                this._mensagem.texto = mensagem; 
                this._limpaFormulario();  
            }).catch(erro => this._mensagem.texto = erro);
    }
Veja que agora o desenvolvedor não precisa conhecer os detalhes de criação de um DAO para adicionar uma nova negociação. Ele pode, simplesmente, chamar um método.
*****************************
06-Adicionando o método lista em NegociacaoService
Vamos fazer mais melhorias no NegociacaoController, adicionando o novo método ao _init(). Atualmente ele está assim:

_init() {

    ConnectionFactory
        .getConnection()
        .then(connection => new NegociacaoDao(connection))
        .then(dao => dao.listaTodos())
        .then(negociacoes =>
            negociacoes.forEach(negociacao =>
                this._listaNegociacoes.adiciona(negociacao)))
        .catch(erro => {
            console.log(erro);
            this._mensagem.texto = erro;
        });
}
Em seguida, adicionaremos o método lista():

_init() {

    new NegociacaoService()
        .lista()
        .then(negociacoes =>
            negociacoes.forEach(negociacao =>
                this._listaNegociacoes.adiciona(negociacao)))
        .catch(erro => {
            console.log(erro);
            this._mensagem.texto = erro;
        });
//...
Pedimos para o NegociacaoService dar todas as negociações, depois, varreremos cada uma das negociações e adicionaremos à lista.

Agora, no arquivo NegociacaoService.js, abaixo do cadastra() adicionaremos o lista().

lista() {

  return ConnectionFactory
          .getConnection()
          .then(connection => new NegociacaoDao(connection))
          .then(dao => dao.listaTodos())
}
O dao.listaTodos listará todos os dados do indexDb.

Estamos retornando uma Promise que terá um DAO que será o retorno do dao.listaTodos(). Se todos os elementos foram listados com sucesso, será exibida uma mensagem. No entanto, se ocorrer um erro, será exibido Não foi possível obter as negociações.

lista() {

  return ConnectionFactory
          .getConnection()
          .then(connection => new NegociacaoDao(connection))
          .then(dao => dao.listaTodos())
          .catch(erro => {
              console.log(erro);
              throw new Error('Não foi possível obter as negociações')
            })
}
Em seguida, faremos alguns ajustes em NegociacaoController.js. O erro do _init é de alto nível e será exibido diretamente.

_init() {

    new NegociacaoService()
        .lista()
        .then(negociacoes =>
            negociacoes.forEach(negociacao =>
                this._listaNegociacoes.adiciona(negociacao)))
        .catch(erro => this._mensagem.texto = erro);


        setInterval(() => {
            this.importaNegociacoes();
        }, 3000);
}
Se recarregarmos a página no navegador, todas as negociações serão exibidas na tabela. Iremos melhorar ainda o método apaga(), que atualmente está assim:

apaga() {

  ConnectionFactory
      .getConnection()
      .then(connection => new NegociacaoDao(connection))
      .then(dao => dao.apagaTodos())
      .then(mensagem => {
          this._mensagem.texto = mensagem;
          this._listaNegociacoes.esvazia();
      });
}
Este bloco de código será substituído por outro. Começaremos adicionando o new NegociacaoService().

apaga() {

    new NegociacaoService()
        .apaga()
        .then(mensagem => {
            this._mensagem.texto = mensagem;
            this._listaNegociacoes.esvazia();
        })
        .catch(erro => this._mensagem.texto = erro);
}
Depois, criaremos o apaga() no NegociacaoService.js.

apaga() {

    return ConnectionFactory
        .getConnection()
        .then(connection => new NegociacaoDao(connection))
        .then(dao => dao.apagaTodos())
        .then(() => 'Negociações apagadas com sucesso')
        .catch(erro => {
              console.log(erro);
              throw new Error('Não foi possível apagar as negociações')
        });
}
Se tudo funcionar corretamente, a mensagem exibida será Negociações apagadas com sucesso. É uma boa prática logar o erro, por isso, faremos o mesmo com o método cadastra().

cadastra(negociacao) {

      return ConnectionFactory
         .getConnection()
         .then(connection => new NegociacaoDao(connection))
         .then(dao => dao.adiciona(negociacao))
         .then(() => 'Negociação cadastrada com sucesso')
         .catch(erro => {
            console.log(erro);
            throw new Error('Não foi possível adicionar a negociação')
         });
 }
Nós logamos o erro do DAO - que pode ser uma mensagem de baixo nível - e exibiremos para o usuário uma mensagem de alto nível. Vamos voltar para o navegador e testar o que fizemos até agora.

negociações apagadas

Ao clicarmos no botão "Apagar", os dados serão apagados. Depois, se analisarmos o nosso código, veremos que o new NegociacaoService se repete diversas vezes. No entanto, podemos transformá-lo em um atributo de NegociacaoController.js, localizado antes this._init().

this._service = new NegociacaoService();
E em todos os lugares em que new NegociacaoService era necessário, iremos substitui-lo por this._service. Veremos isto com o método _init():

_init() {

      this._service
          .lista()
          .then(negociacoes =>
              negociacoes.forEach(negociacao =>
                  this._listaNegociacoes.adiciona(negociacao)))
          .catch(erro => this._mensagem.texto = erro);

          setInterval(() => {
              this.importaNegociacoes();
          }, 3000);
}
No navegador, veremos que as negociações são importadas automaticamente. Se cadastrarmos novas informações no formulário, elas serão incluídas. Só um detalhe: as negociações importadas não estão sendo salvas no indexDb. Apenas as que são inclusas pelo formulário. Mas você tem a opção de gravar todas elas.
*****************************
07-Isolando a complexidade do importaNegociacoes em NegociacaoService
Para finalizar, faremos alterações no importaNegociacoes(). O método atualmente está assim:

importaNegociacoes() {

    this._service
        .obterNegociacoes()
        .then(negociacoes any
            negociacoes.filter(negociacao =>
                !this._litsaNegociacoes.negociacoes.some(negociacaoExistente =>
                    JSON.stringify(negociacao) == JSON.stringify(negociacaoExistente)))
        )
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'
          }))
          .catch(erro => this._mensagem.texto = erro);
}
Observe que o trecho possui muito detalhes para conseguirmos importar uma negociação. Temos que aplicar um filtro... Para solucionar isto, em NegociacaoService.js, criaremos o método importa(). Com ele, queremos obter as negociações, por isso, usaremos o this.obterNegociacoes():

importa(listaAtual) {

       return this.obterNegociacoes()
           .then(negociacoes =>
               negociacoes.filter(negociacao =>
                   !listaAtual.some(negociacaoExistente =>
                       JSON.stringify(negociacao) == JSON.stringify(negociacaoExistente)))
           )
   }
No obterNegociacoes, recebemos a lista de negociações, mas devemos ter a lista atual que é exibida para o usuário. Quando chamamos o importa() precisamos receber a listaAtual, que devolverá somente as negociações ainda não importadas. No fim, teremos uma lista de negociação que será importada. Agora adicionaremos o catch para os casos de erro.

importa(listaAtual) {

       return this.obterNegociacoes()
           .then(negociacoes =>
               negociacoes.filter(negociacao =>
                   !listaAtual.some(negociacaoExistente =>
                       JSON.stringify(negociacao) == JSON.stringify(negociacaoExistente)))
           )
           .catch(erro => {
               console.log(erro);
               throw new Error("Não foi possível importar as negociações");
           });
   }
Simplificaremos o método importaNegociacoes() do arquivo NegociacaoController.js.

importaNegociacoes() {

    this._service
        .importa(this._listaNegociacoes.negociacoes)
        .then(negociacoes => negociacoes.forEach(negociacao => {
            this._listaNegociacoes.adiciona(negociacao);
            this._mensagem.texto = 'Negociações do período importadas'
          }))
        .catch(erro => this._mensagem.texto = erro);
}
Porém, o parâmetro que passamos para o importa() é a lista atual. Internamente, ele irá comparar a lista trazida do Back-end com a atual para decidir quais serão as negociações que vão passar para o then(), ou seja, as que ainda não foram importadas.

Adicionaremos o return no método apaga() . Sem o retorno, o método não funcionará corretamente. Com a alteração, o trecho do código ficará assim:

apaga() {

    return ConnectionFactory
        .getConnection()
        .then(connection => new NegociacaoController(connection))
        .then(dao => dao.apagaTodos())
        .then(() => 'Negociações apagadas com sucesso')
        .catch(erro => {
            console.log(erro);
            throw new Error('Não foi possível apagar as negociações')
          })
}
negociações importadas corretamente

Agora, as importações funcionam corretamente. Nós refatoramos o nosso código e com isto, facilitamos a leitura e o entendimento.
*****************************
08-exercícios - Comparação entre objetos
Temos a seguinte classe que define o retângulo:

class Retangulo {

    constructor(base, altura) {

        this.base = base;
        this.altura = altura;
    }

    areaCalculada() {
        return this.base * this.altura;
    }
}
Em seguida, temos duas instâncias com valores iguais de base e altura:

let r1 = new Retangulo(10,5);
let r2 = new Retangulo(10,5);
Quais das opções abaixo retorna true ao compararmos um objeto com outro?

Alternativa correta
console.log(r1.base == r2.base && r1.altura == r2.altura);

Existem tipos primitivos em JavaScript chamado de literais que podem ser acessados como objetos quanto invocamos algum método. O encapsulamento de um primitivo por um objeto automaticamente pelo interpretador é chamado de autoboxing. Por mais que tenhamos um objeto representando um número, a comparação será pelo valor literal (primitivo) e não pela referência. Números são encapsulados pela função construtora Number.

Alternativa correta
console.log(r1 == r2);

Quando usamos o operador ==, não estamos comparando os valores dos objetos, mas se as variáveis apontam para o mesmo objeto em memória. Para que desse verdadeira, poderíamos fazer:

r1 = r2;
Com essa atribuição, r1 passa a apontar para o mesmo objeto de r2 e por conseguinte a comparação r1 == r2 será true, verdadeira.

Alternativa correta
console.log(JSON.stringify(r1) == JSON.stringify(r2));

Uma maneira de comparamos um objeto com outro é converter ambos os objetos envolvidos na comparação para String, com o auxílio de JSON.stringify, que está preparado para converter um objeto JavaScript para uma string. Essa solução é interessante quando o objeto possui muitas propriedades.
*****************************
09-exercícios - "Some"body help me!
Gisele está desenvolvendo um sistema de controle de passageiros. Ela criou a simples classe que representa um passageiro, que pode ser de avião, ônibus, não importa:

class Passageiro {

    constructor(nome, profissao) {

        this.nome = nome;
        this.profissao = profissao;
    }
}
Em seguida, ela criou uma lista de passageiros:

let passageiros = []

passageiros.push(new Passageiro('Orlando', 'Dentista'));
passageiros.push(new Passageiro('Suzada', 'Advogada'));
passageiros.push(new Passageiro('Hélio', 'Médico'));
passageiros.push(new Passageiro('Salen', 'Programador'));
passageiros.push(new Passageiro('Francisca', 'Médica'));
A ideia de Gisele é poder acelerar a busca por médicos ou profissionais que sejam necessários em casos de emergência.

Qual das opções abaixo utiliza corretamente a função some para encontrar um médico ou uma médica?

Alternativa correta
let achou = passageiros.some(() => /médic/i.test(passageiro.profissao));

alert(achou);

Veja que some não recebeu uma parâmetro para dar acesso aos elementos do array.

Alternativa correta
let achou = passageiros.some(passageiro => /médic/i.test(passageiro));
alert(achou);

Veja que a função test está recebendo o objeto passageiro e não a profissão.

Alternativa correta
let achou = passageiros.some(passageiro => /médic/i.test(passageiro.profissao));

alert(achou);
A função some itera sobre o array, assim como forEach, filter e map. No entanto, seu retorno é true ou false. Ela retorna true logo assim que encontrar o primeiro elemento que for condizente com o critério de comparação utilizado. Quando dizemos, "logo assim", significa que a função parará de iterar nos elementos da lista, porque já encontrou pelo menos algum (some) que atenda ao critério.

Veja que o critério de comparação usa a expressão regular criada literalmente com //. Nela, procuramos pela parte médic, sem levar em consideração se o caractere é maiúsculo ou minúsculo, com o modificador i.
*****************************
10-exercícios - Promise mais elegante
Wittgenstein implementou as classes ConnectionFactory e NegociacaoDao como ensinado neste capítulo. Inclusive, ele teve certeza que seu código funcionava a partir do seguinte teste:

ConnectionFactory
    .getConnection()
    .then(conexao => {

        let dao = new NegociacaoDao(conexao);
        dao.adiciona(new Negociacao(new Date(), 1, 100))
            .then(() => {
                alert('Negociação adicionada com sucesso');            
            });

    })
    .catch(erro => console.log(erro));
Apesar de funcional, veja que se tivéssemos mais chamadas à then, cairíamos em algo parecido com o Callback Hell, assunto que tocamos no primeiro módulo de uma sequência de treinamentos avançados.

Qual das opções abaixo reescreve elegantemente o código de Wittgenstein, evitando assim o aninhamento de chamadas à then?

Alternativa correta
ConnectionFactory
    .getConnection()
    .then(conexao => new NegociacaoDao(conexao))
    .then(dao => dao(new Negociacao(new Date(), 1, 100)))
    .then(() => alert('Negociação adicionada com sucesso'))
    .catch(erro => console.log(erro));

A linha .then(dao => dao) não invoca o método adiciona do dao.

Alternativa correta
ConnectionFactory
    .getConnection()
    .then(new NegociacaoDao())
    .then(dao => dao.adiciona(new Negociacao(new Date(), 1, 100)))
    .then(() => alert('Negociação adicionada com sucesso'))
    .catch(erro => console.log(erro));

A classe NegociacaoDao não está recebendo como parâmetro a conexão.

Alternativa correta
ConnectionFactory
    .getConnection()
    .then(conexao => new NegociacaoDao(conexao))
    .then(dao => dao.adiciona(new Negociacao(new Date(), 1, 100)))
    .then(() => alert('Negociação adicionada com sucesso'))
    .catch(erro => console.log(erro));
Podemos escrever um código mais elegante com promises.
*****************************
11-exercícios - Experimento com promise
Clóvis, desejando compreender melhor o efeito do encadeamento de promises (promise chainning) e o tratamento de erro, criou três funções que retornam promises. Ele simulou um processamento assíncrono usando setTimeout, ou seja, a chamada de resolve de cada promise será chamada depois de alguns segundos. Veja que cada função tem um tempo de espera diferente da outra:

<!-- teste promise -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>

    <script>

        function a(falhar) {

            return new Promise((resolve, reject) => {

                setTimeout(() => {

                    if(falhar) {

                        reject('PROMISE A FALHOU');
                    } else {

                        console.log('PROMISE A RESOLVIDA');
                        resolve('DADO A');
                    }

                }, 2000);
            });
        }

        function b(falhar) {

            return new Promise((resolve, reject) => {

                setTimeout(() => {

                    if(falhar) {

                        reject('PROMISE B FALHOU');
                    } else {

                        console.log('PROMISE B RESOLVIDA')
                        resolve('DADO B');
                    }

                }, 1000);
            });
        }

        function c(falhar) {

            return new Promise((resolve, reject) => {

                setTimeout(() => {

                    if(falhar) {

                        reject('PROMISE C FALHOU');
                    } else {

                        console.log('PROMISE C RESOLVIDA')
                        resolve('DADO C');
                    }

                }, 500);
            });
        }

    </script>
</body>
Clóvis, espertamente, fez com que cada função recebesse um parâmetro. Se o valor passado for true, a promise será rejeitada. Uma maneira de simular um erro durante seu processamento.

Ele fez o seguinte teste:

<!-- teste promise -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>

    <script>

        // código das funções omitido 

        // teste, fazendo a promise c ser rejeitada

            a()
            .then(dado => {
                console.log(dado);
                // O RETORNO DA PROMISE B ESTARÁ DISPONÍVEL NO PRÓXIMO THEN
                return b(); 
            })
            .then(dado => {
                console.log(dado);

                /* FORÇANDO A REJEIÇÃO DA PROMISE. TEM QUE IR DIRETO PARA O CATCH. 
                SE NÃO TIVESSE REJEITADO, O RETORNO DE C ESTARIA DISPONÍVEL NO PRÓXIMO THEN */
                return c(true);  
            })
            .then(dado => {
                console.log(dado);
            })
            .catch(erro => console.log(erro));

    </script>
</body>
O objetivo de Clóvis é saber se a função catch será chamada se a promise retornada por c for rejeitada, inclusive mostrando no console a mensagem de erro * PROMISE C FALHOU **. Dessa forma, ele terá certeza que durante o encadeamento das *promises, qualquer erro será capturado em um único lugar, no caso em .catch.

Sobre o código acima, marque as alternativas que julgar verdadeira:

Alternativa correta
A promise C demorará mais de 1 segundo para ser chamada, apesar do valor de setTimeout ser meio segundo (500ms).


Cada promise só é executada depois que a anterior é resolvida. Sendo assim, por mais que a função c esteja com um valor de setTimeout de 500 ela só será executada depois da função a e b serem concluídas.

Alternativa correta
É exibida no console a mensagem "PROMISE C FALHOU".


Sim, porque como passamos true para a função c, ela chamará reject. Isso fará com que a promise rejeitada passe sua mensagem de erro para a função .catch, local centralizado para tratar qualquer erro disparado por uma das promises encadeadas.

Alternativa correta
Nenhuma mensagem será exibida no console.


Será exibida no console a mensagem PROMISE C FALHOU.

Você deve estar se perguntando qual a diferença dessa estratégia para o uso de Promise.all, que usamos no módulo anterior. Promise.all resolve as promises em paralelo, ou seja, uma promise não aguarda a outra terminar para ser executada. Promise.all é interessante quando uma promise não depende do resultado da promise anterior. Nos casos onde há dependência, o encadeamento de promises é o caminho mais indicado.

Faça um teste usando Promise.all. Você verá que as promises serão resolvidas fora da ordem em que foram passadas para Promise.all:

Promise
    .all([a(), b(), c()])
    .then(arrayComResultadoDasPromises => console.log(arrayComResultadoDasPromises))
    .catch(erroDeAlgumaDasPromises => console.log(erroDeAlgumaDasPromises));
*****************************
12-Consolidando seu conhecimento
Para que você consiga acompanhar os vídeos seguintes, implemente o que foi apresentado no vídeo. Caso já tenha feito, a ideia é que revise todo o conteúdo antes de continuar. Como diz o ditado, "recordar é viver".

VER OPINIÃO DO INSTRUTOR
----
Opinião do instrutor

Dúvidas? Você pode recorrer ao vídeo e às explicações do capítulo. Se ainda assim as dúvidas continuarem, procure imediatamente ajuda em nosso fórum.
*****************************
13-
*****************************
14-
*****************************
