01-Escopo global e carregamento de scripts = dor de cabeça
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui e continuar seus estudos.

Atenção: o projeto não possui a pasta aluraframe/client/node_modules e você precisará baixar as dependências abrindo o Terminal na pasta aluraframe/client para em seguida executar o comando npm install. Este comando lerá seu arquivo package.json e baixará todas dependências listadas nele.

Fizemos coisas fantásticas usando o JavaScript, mas não atacamos uma das grandes fraquezas da linguagem: o escopo global e o carregamento de script. Nos aprofundaremos sobre tais assuntos.

Dentro da pasta app-es6, criaremos uma outra pasta que receberá o nome lib. Nesta, criaremos um arquivo chamado datex.js, na qual terá uma biblioteca baixada da internet com alguns métodos de data que o nosso DateHelper não tem: dateToString() e stringToDate().

class DateHelper {

    dateToString(date) {
        /* faz algo */
    }

    stringToDate(string) {
        /* faz algo */
    }
}
Temos os métodos dateToString() e stringToDate(). Podemos adicionar ainda outras que nos auxiliaram a trabalhar com datas. Em seguida, importaremos este script como o último da lista index.html.

<div id="negociacoesView"></div>
<script src="js/app/polyfill/fetch.js"></script>
<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script src="js/app/dao/NegociacaoDao.js"></script>
<script src="js/app/lib/datex.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
O Babel está rodando e depois, compilará o arquivo, jogando-o dentro de app. Mas quando a página carregar no navegador, teremos uma mensagem de erro.

mensagem de erro

Por que tivemos um erro e a aplicação parou de funcionar? Na lib que baixamos, temos uma classe chamada DateHelper - e nós já tínhamos um arquivo com mesmo nome em helpers:

Class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instanciada');
    }

//...
Como esta definição de classe está no escopo global, quando o script datex é carregado, o DateHelper deste irá sobrescrever o anterior. Isto é das grandes limitações do JS - o mesmo ocorre com variáveis e funções que estão no escopo global. É impossível usar as duas classes DateHelpers simultaneamente. Outro problema é que quando importamos os scripts da nossa página, eles são colocados em determinada ordem. Lembre-se que o carregamento de View deve vir antes de NegociacaoView e MensagemView, porque NegociacaoView estende View. Então, se ocasionalmente carregarmos os scripts numa ordem contrária, teremos um erro de execução e a aplicação irá parar de funcionar. O desenvolvedor precisará ficar atendo sobre a ordem de dependência.

A plataforma Node.js resolveu este problema adotando padrão CommonJS para criação de módulos, ainda há bibliotecas como RequireJS que usam o padrão AMD (Assincronous Module Definition). Contudo, o ES2015 especificou seu próprio sistema de módulos que resolve tanto o problema do escopo global quanto o de carregamento de scripts.

Nesta aula, nós usaremos o sistema de módulos do ECMAScript 2015, que nos ajudará a resolver os dois problemas.
***********************************************************
02-ES2015 e módulos
Vamos precisar seguir uma série de etapas para usar o sistema de módulos do ECMAScript 2015. Mas a primeira coisa que faremos - e ainda será insuficiente - será converter todos os scripts feitos para o sistema.

Começaremos pela classe View.js, que é dependência da classe MensagemView. O que faremos? No módulo do ES6, todos os scripts também serão. Isto significa que todo o conteúdo dentro do arquivo JS não será acessível para outros e não estará no escopo global. Se tivéssemos ativado o sistema de módulo do ES 6, nenhuma definição de classe estaria no escopo global e a aplicação não funcionaria. Por exemplo, se MensagemView quiser utilizar a View, teremos que importar a classe View para o módulo View.js:

export class View{

    constructor(elemento) {

      this._elemento = elemento;

    }

    template() {

        throw new Error('O método template deve ser implementado');

    }

    update(model) {

        this._elemento.innerHTML = this.template(model);
    }
}
Se incluirmos a palavra export na classe, quando o MensagemView.js tentar utilizar a View, ele não conseguirá fazer a importação. Faremos isto a seguir:

import {View} from './View';

export class MensagemView extends View {

    constructor(elemento) {

        super(elemento);
    }

    template(model) {

        return model.texto ? `<p class="alert alert-info">${model.texto}</p>` : `<p></p>`;
    }
}
Nós explicitamos que queremos importar algo do módulo View. Relembrando, cada script é considerado um módulo por padrão e todo conteúdo não cairá no escopo global. Como View está na mesma pasta que MensagemView, usamos apenas o ./, sem precisar especificar a extensão no fim. Também, especificamos dentro das chaves o que queremos importar (View). Observe que também exportamos o MensagemView, porque ela será importada pelo NegociacaoController.js.

Repetiremos o processo de importação e exportação em NegociacaoView.js:

import {View} from './View';
export class NegocicaoView extends View {

    constructor(elemento) {

        super(elemento);
    }
//...
E depois, adicionaremos o export em DateHelper.js:

export class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instaciada');
    }
//...
Outros arquivos precisam da classe HttpService, iremos exportá-la:

export class HttpService {

    _handleErrors(res) {
        if(!res.ok) throw new Error(res.statusText);
        return res;
    }
//...
Faremos o mesmo em NegociacaoService.js. Observe que também importaremos o HttpService:

import {HttpService} from './HttpService';
 export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
NegociacaoService depende da definição de classe de HttpService que estamos importando. A próxima alteração será em ProxyFactory.js:

 export class ProxyFactory {

      static create(objeto, props, acao) {
          return new Proxy(objeto, {

              get(target, prop, receiver) {

                  if(props.includes(prop) && ProxyFactory._ehFuncao(target[prop])) {

                    console.log(`interceptando ${prop}`);
                    let retorno = Reflect.apply(target[prop], target, arguments);
                    acao(target);
                    return retorno;
                  }
              }
            }
//...
***********************************************************
03-Refatorando nosso código com import e export
Temos um caso atípico com a classe ConnectionFactory. Nela, criamos o Model Pattern para exportá-la no escopo global. Mas escondemos algumas variáveis:

var ConnectionFactory = (function () {

      const stores = ['negociacoes'];
      const version = 4;
      const dbName = 'aluraframe';

      var connection = null;

      var close = null;

      return class ConnectionFactory {

          constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
          }
//...
Como todo arquivo JS é um módulo, o conteúdo não será mais acessível. Apenas o que é exportável será acessível para outros módulos. Em vez do return, vamos usar o export para a classe:

const stores = ['negociacoes'];
const version = 4;
const dbName = 'aluraframe';

let connection = null;

let close = null;

export class ConnectionFactory {

    constructor() {

        throw new Error('Não é possível criar instâncias de ConnectionFactory');
    }
//...
Observe que também substituímos o var pelo let, porque as variáveis não vão mais cair no escopo global. Em seguida, faremos alterações no arquivo NegociacaoDao:

import {Negociacao} from '../models/Negociacao';

export class NegociacaoDao {

    constructor(connection) {

        this._connection = connection;
        this._store - 'negociacoes';
    }
//...
Adicionaremos o export e import em Bind.js:

import {ProxyFactory} from '../services/ProxyFactory';

export class Bind {

    constructor(model, view, ...props) {

        let proxy = ProxyFactory.create(model, props, model =>
            view.update(model));

            view.update(model);
    }
}
Voltaremos em NegociacaoService para fazer uma modificação que deixamos escapar. Adicionaremos mais duas importações:

import {HttpService} from './HttpService';
import {ConnectionFactory} from './ConnectionFactory';
import {NegociacaoDao} from '../dao/NegociacaoDao';

export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
Depois, iremos inserir o export em ListaNegociacoes.js:

export class ListaNegociacoes {

    constructor() {

        this._negociacoes = [];
 }
//...
Faremos o mesmo em Mensagem.js:

export class Mensagem {

    constructor(texto) {

        this._texto = texto || '';
    }
//...
Temos que exportar também em Negociacao.js:

export class Negociacao {

    constructor(data, quantidade, valor) {

      this._data = new Date(data.getTime());
      this._quantidade = quantidade;
      this._valor = valor;
      Object.freeze(this);
    }
//...
As próximas alterações serão em NegociacaoController:

import {ListaNegociacoes} from '../models/ListaNegociacoes';
import {Mensagem} from '../models/Mensagem';
import {NegociacoesView} from '../views/NegociacoesView';
import {MensagemView} from '../views/MensagemView';
import {NegociacaoService} from '../services/NegociacaoService';
import {DateHelper} from '../helpers/DateHelper';
import {Bind} from '../helpers/Bind';
import {Negociacao} from '../models/Negociacao';

class NegociacaoController {

    constructor() {

       let $ = document.querySelector.bind(document);
//...
Observe que a Controller tem várias dependências.

Nós fizemos diversas modificações nos arquivos, no entanto, se executarmos o código, ele ainda não funcionará. Usamos a sintaxe do ES6 (de importação e exportação de módulos), mas entenderemos por que isso ainda não é o suficiente.
***********************************************************
04-SystemJs
Faltou adicionarmos uma importação ao arquivo NegociacaoService.js:

import {HttpService} from './HttpService';
import {ConnectionFactory} from './ConnectionFactory';
import {NegociacaoDao} from '../dao/NegociacaoDao';
import {Negociacao} from '../models/Negociacao';

export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
Agora, fizemos todas as importações necessárias. Mas por que o código não funciona como está? Porque a especificação ES2015 define o import e export, além de que cada script é um módulo independente. No entanto, não definimos como estes módulos devem ser carregados no navegador. Não existe um consenso... Precisamos que os scripts sejam carregados em uma determinada ordem no seu sistema, definindo apenas o primeiro. A partir deste, serão carregados os demais. O responsável pelo processo é loader, porém, não existe um padrão nos navegadores. Para resolver a questão, teremos que escolher uma biblioteca de terceiro que atue como um loader de script. Uma biblioteca muito famosa é System JS. Nós iremos baixá-lo pelo NPM do Node.JS, e iremos colocá-lo na pasta node_modules.

Em seguida, vamos parar o Terminal. Dentro da pasta client, instalaremos o System JS.

npm install systemjs@0.19.31 --save
O SystemJS é um script que precisa ser carregado com a aplicação. O processo de instalação é bem rápido. Então, dentro da pasta node_modules encontraremos o systemjs. Depois, importaremos o script no index.html, o arquivo ficará logo no início:

<div id="negociacoesView"></div>
<script src="node_modules/systemjs/dist/system.js"></script>
<script src="js/app/polyfill/fetch.js"></script>
<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script src="js/app/dao/NegociacaoDao.js"></script>
<script src="js/app/dao/datex.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
Importamos o loader. Porém, ao adicionarmos o responsável pela importação dos scripts, não precisaremos mais importar todos os demais:

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
Nós vamos especificar para o systemjs qual será o primeiro módulo carregado, e automaticamente, ele baixará os demais scripts na ordem de dependência. Ou seja, o desenvolvedor não precisará mais se preocupar com a ordem. Porém, falta indicar o primeiro módulo. Faremos a seguinte configuração:

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    System.defaultJSExtensions = true;
    System.import('js/app/boot').catch(function(err){
        console.error(err);
    });
</script>
<script>
    var negociacaoController = new NegociacaoController();  
</script>
O systemjs tem a variável global System. Quando definimos true para defaultJSExtensions, isto nos permite omitir as extensões JS dos imports. Como em NegociacaoController.js, que fizemos as importações sem adicionar a extensão js:

import {ListaNegociacoes} from '../modelo/ListaNegociacoes';
import {Mensagem} from '../modelo/Mensagem';
import {NegociacaoView} from '../view/NegociacaoView';
import {MensagemView} from '../view/MensagemView';
import {NegociacaoService} from '../services/NegociacaoService';
import {DateHelper} from '../helpers/DateHelper';
import {Bind} from '../helpers/Bind';
import {Negociacao} from '../models/Negociacao';
De volta ao index.html, especificamos com System qual será o primeiro módulo carregado: no caso, será o boot.js que criaremos a seguir. Dentro da pasta app-es6:

arquivo boot

Este será o primeiro arquivo a ser carregado. Também não fará mais sentido termos o NegociacaoController no escopo global, por isso, iremos removê-lo.

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    System.defaultJSExtensions = true;
    System.import('js/app/boot').catch(function(err){
        console.error(err);
    });
</script>
Conseguimos apagar diversos scripts que precisam ser carregados manualmente.
***********************************************************
05-O módulo boot.js
Conseguimos remover inúmeros scripts do index.html:

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    System.defaultJSExtensions = true;
    System.import('js/app/boot').catch(function(err){
        console.error(err);
    });
</script>
Se você analisar a lib, perceberá que ela não segue o sistema de módulos do ES6. Resolveremos isto mais adiante. Vamos adicionar a variável negociacaoController, no entanto, ela está em um escopo privado. Não temos mais o negociacaoController no escopo global... Para resolver a questão, não associaremos mais os eventos na View.

Importamos a lib do system.js e fizemos a configuração mínima, especificando que omitiremos as extensões dos arquivos e qual será o primeiro módulo a ser carregado. Agora, começaremos a escrever o arquivo boot.js:

import {NegociacaoController} from './controllers/NegociacaoController';
import {} from './polyfill/fetch';

let negociacaoController = new NegociacaoController();
Primeiramente, importamos o NegociacaoController e carregamos o polyfill, para que ele seja executado. No entanto, o negociacaoController está em um escopo privado. No arquivo index.html, por exemplo, chamamos negociacaoController e depois o método apaga():

<div class="text-center">
    <button onclick="negociacaoController.apaga()" class="btn btn-primary text-center" type="button">
        Apagar
    </button>
</div>
Como não temos mais negociacaoController no escopo global, deixaremos de associar o evento de onde ele era utilizado diretamente na View. No caso, o trecho referente ao botão "Apagar" ficará assim:

<div class="text-center">
    <button class="btn btn-primary text-center" type="button">
        Apagar
    </button>
</div>
Em seguida, vamos inserir as classes do index no boot.js. Usaremos o querySelector():

import {NegociacaoController} from './controllers/NegociacaoController';
import {} from './polyfill/fetch';

let negociacaoController = new NegociacaoController();

document.querySelector('.form').onsubmit = negociacaoController.adiciona.bind(negociacaoController);
document.querySelector('[type=button]').onclick = negociacaoController.apaga.bind(negociacaoController);
O porquê do uso do bind já foi visto anteriormente. Se não o incluíssemos, o this do adiciona não seria mais o negociacaoController. Escolhemos uma solução tradicional.
***********************************************************
06-Babel e transcompilação de módulos
O arquivo boot.js instanciará a controller, sendo responsável por associar os métodos do NegociacaoController com os eventos da View. Porém, o nosso código ainda não vai funcionar. Isto porque estamos usando como loader o system.js, por isso, os módulos que o Babel transcompila realizarão a ação usando a sintaxe do mesmo arquivo para auxiliar a importação.

O transpiler é importante neste processo porque ele mudará o código dos módulos para adequá-los ao loader. De volta ao Terminal, na pasta client, instalaremos o novo módulo - um plugin do Babel.

npm install babel-plugin-transform-es2015-modules-systemjs@6.9.0 --save-dev
O plugin transforma o código do ES2015 para usar o SystemJS. É fundamental instalá-lo no Babel para que tudo funcione corretamente.

Talvez, você tenha achado "burocrático" usar o módulo do ES6. Eu concordo...

Após fazermos a gravação do plugin, vamos configurar para que o Babel utilize o recurso recém instalado, no arquivo .babelrc .

{
   "presets" : ["es2015"],
   "plugins" : ["transform-es2015-modules-systemjs"]
}
Sem a configuração, o Babel não compilará os módulos adequadamente para a importação no System.js. Em seguida, no Terminal, vamos fazer a compilação com o comando build:

npm run build
O processo de compilação funcionará corretamente:

compilação completa

Se analisarmos os arquivos gerados pelo transpiler, localizados na pasta app, veremos que aparecerá uma sintaxe nova. Por exemplo, no arquivo NegociacaoDao, encontraremos o System.register aparecendo no seguinte trecho:

System.register([], function(_export, _context) {
    "use strict";

    var _createClass, NegociacaoDao;

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
//...
Conseguimos importar o loader. Depois, no Terminal, deixaremos o watch ligado.

npm run watch
Ao recarregarmos a página, ela não funcionará. No Console, veremos diversas mensagens de erro.

Mensagens de erro

Não foi encontrado o ListaNegociacoes, Mensagem, além de outros arquivos. Teremos que fazer algumas correções nos caminhos das importações do NegociacaoController.js. Onde escrevemos modelo, substituiremos por models. Também modificaremos de view para views e NegociacaoView para NegociacoesView:

import {ListaNegociacoes} from '../models/ListaNegociacoes';
import {Mensagem} from '../models/Mensagem';
import {NegociacoesView} from '../views/NegociacoesView';
import {MensagemView} from '../views/MensagemView';
import {NegociacaoService} from '../services/NegociacaoService';
import {DateHelper} from '../helpers/DateHelper';
import {Bind} from '../helpers/Bind';
import {Negociacao} from '../models/Negociacao';

export class NegociacaoController {

    constructor() {}

//...
Observe que faltou também adicionar o export no NegociacaoController para que este possa ser importado pelo boot.js. Depois, em NegociacoesView.js, importaremos o DateHelper:

import {View} from './View';
import {DateHelper} from '../helpers/DateHelper';

export class NegociacoesView extends View {

  constructor(elemento) {

      super(elemento);
  }
//...
Apesar do erro, não nós que importamos o scripts. Foi o System.JS quem realizou as importações. Com as alterações, no Console já não veremos nenhuma mensagem de erro.

negociações importadas

Se cadastrarmos uma nova negociação, ela será importada corretamente. Agora a nossa aplicação inteira está usando o sistema de módulos do ES2015.
***********************************************************
07-Delegação de eventos
Nossa aplicação parece estar funcionando, migramos para o sistema de módulos do ECMAScript 2015. No entanto, quando tentamos ordenar os dados das colunas, já não somos bem-sucedidos na tarefa. Se abrimos o Console, veremos diversas mensagens de que NegociacaoController não está definido.

negociacaoController is not defined

Se analisarmos o NegociacaoView, veremos que adicionamos o evento onclick chamando o negociacaoController.

<thead>
    <tr>
        <th onclick="negociacaoController.ordena('data')">DATA</th>
        <th onclick="negociacaoController.ordena('quantidade')">QUANTIDADE</th>
        <th onclick="negociacaoController.ordena('valor')">VALOR</th>
        <th onclick="negociacaoController.ordena('volume')">VOLUME</th>
    </tr>
</thead>
Como ocorreu anteriormente, tivemos problemas porque o NegociacaoController não faz mais parte do escopo global. Para que a aplicação possa funcionar, teremos que encontrar alguma forma de importar o arquivo. No entanto, não podemos simplesmente importar o NegociacaoController.

import {View} from './View';
import {DateHelper} from '../helpers/DateHelper';
import {NegociacaoController} from '../controllers/NegociacaoController'

export class NegociacoesView extends View {

  constructor(elemento) {

      super(elemento);
  }
//...
Se fizermos isto, teremos um nova instância de negociação e isso nos trará problemas. Ao tentarmos ordenar as negociações, elas não terão os dados incluídos ou alterados. Isto significa que a solução é ter acesso a mesma instância. Como faremos isto? No arquivo NegociacaoController.js, não exportaremos mais a classe NegociacaoController. Iremos remover a palavra export:

class NegociacaoController {

    constructor() `{

        let $ = document.querySelector.bind(document);

        this._inputData = $('#data');
        this._inputQuantidade = $('#quantidade');
        this._inputValor = $('#valor');
//...
No entanto, se não exportamos, ninguém poderá usar seu conteúdo. A solução será exportar uma função que criaremos a seguir: currentInstance():

let negociacaoController = new NegociacaoController();

export function currentInstance() {

    return negociacaoController;

}
Dentro do módulo, teremos a variável negociacaoController e que só existirá na nele. Quando a função for chamada, retornaremos a instância negociacaoController. Agora importaremos uma única instância. Faremos alterações em boots.js, adicionando o currentInstance:


import {currentInstance} from './controllers/NegociacaoController';
import {} from '/polyfill/fetch';

let negociacaoController = currentInstance();

document.querySelector('.form').onsubmit = negociacaoController.adiciona.bind(negociacaoController);
document.querySelector('[type=button]').onclick = negociacaoController.apaga.bind(negociacaoController);
A função nos retornará a instância de negociacaoController do módulo. Também importaremos o currentInstance em NegociacaoView.js.

import {View} from './View';
import {DateHelper} from '../helpers/DateHelper';
import {currentInstance} from '../controlers/NegociacaoController';

export class NegociacaoView extends View{

    constructor(elemento) {

        super(elemento);
    }
//...
Depois, trabalharemos com a delegação de eventos. Começaremos removendo o onclick do arquivo.

<thead>
    <tr>

      <th>DATA</th>
      <th>QUANTIDADE</th>
      <th>VALOR</th>
      <th>VOLUME</th>

    </tr>
</thead>
Quando clicarmos na coluna (na tag <th>), o JavaScript possui um sistema de eventos chamado event bubbling. Com ele, ao clicarmos, o evento "subirá" até a tag <tr> - que é o pai - e seguirá subindo até o

, perguntando se todos respondem pelo evento do clique. Nós vamos especificar que, se o evento de clique chegar até onegociacoesView, ele responderá ao evento da`:
<div id="negociacoesView"></div>
Se não fizermos isto, cada <th> terá que responder pelo evento. Em NegociacoesView, vamos adicionar o event.target dentro do if:

export class NegociacoesView extends View {

    constructor(elemento) {

        super(elemento);

        elemento.addEventListener('click', function(event) {

            if(event.target.nodeName == 'TH') {

                currentInstance().ordena(event.target.textContent.toLowerCase());
            }
          })
    }
}
Nós adicionaremos o nome de cada <th> e vamos converter para cada caso (toLowerCase()). Se clicamos na TH, ela não estará preparada para o esforço... O evento subirá de hierarquia até chegar em elemento, então, perguntará se o alvo (target) era uma TH. Como a resposta será sim, pegaremos a instância atual da Controller, e chamaremos o ordena() passando o nome da th - indicado pelo event.target.textContent.

Se executarmos a página, veremos que o código funciona. Os dados também serão ordenados quando clicarmos em um coluna da tabela.

dados ordenados

O sistema de módulos do ECMAScript 2015 também nos permite exportar instâncias, por meio da chamada da função currentInstance. Com isto, não temos mais nada quebrando na aplicação e terminamos o projeto com o código totalmente convertido.


***********************************************************
08-Trabalhando com módulos do ES2015!
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto do capítulo anterior e continuar seus estudos a partir deste capítulo.

ATENÇÃO: o projeto não possui a pasta aluraframe/client/node_modules e você precisará baixar as dependências abrindo o terminal na pasta aluraframe/client para em seguida executar o comando npm install. Este comando lerá seu arquivo package.json e baixará todas dependências listadas nele.

Escopo global e carregamento de scripts = dor de cabeça
Nossa aplicação vem se tornando cada vez mais sofisticada: persistimos dados localmente com IndexedDB, aplicamos padrões de projeto e utilizamos transpiler entre outras coisas. Contudo, desde o primeiro módulo do curso não atacamos dois pontos fracos da linguagem JavaScript: o escopo global e o carregamento de scripts. Primeiro, vamos filosofar sobre o escopo global.

Todas as nossas classes, inclusive a instância de NegociacaoController estão no escopo global. Agora, vamos simular o seguinte: baixamos uma lib de terceiros para usar em nossa aplicação. Vamos criar o arquivo aluraframe/client/js/app/lib/datex.js com o seguinte código:

// aluraframe/client/js/app/lib/datex.js

class DateHelper {

    dateToString(date) {
        /* faz algo */
    }

    stringToDate(string) {
        /* faz algo */
    }
}
Vamos importá-lo em aluraframe/client/index.html como último script. Quando ele for carregado,por possuir o mesmo nome da nossa classe DateHelper que esta no escopo global, haverá colisão de nomes e a nova classe substituirá a já existente. Como a classe agora não possui os método textoParaData() e nem dataParaTexto() nossa aplicação não funcionará. Faça um teste.

Outro problema, além de colisões no escopo global é a ordem de carregamento de scripts. Você deve lembrar que no primeiro módulo, éramos obrigados a carregar View.js antes de ListaNegociacoesView e MensagemView porque elas herdam de View e esta classe obrigatoriamente deve vir primeiro. Veja que esse problema acaba jogando nas costas do desenvolvedor a responsabilidade de verificar em que posição um novo script deve ser incluído.

A plataforma Node.js resolveu este problema adotando padrão CommonJS para criação de módulos, ainda há bibliotecas como RequireJS que usam o padrão AMD (Assincronous Module Definition). Contudo, o ES2015 especificou seu próprio sistema de módulos que resolve tanto o problema do escopo global quanto o de carregamento de scripts.

ES2015 e módulos
Apesar de fazer parte da especificação, ainda não há consenso a respeito de como os scripts devem ser carregados pelo navegador. É por isso que para usarmos o sistema de módulos oficial do JavaScript precisamos utilizar loaders de terceiros, que nada mais são do que scripts especiais que farão o carregamento dos nossos módulos. Neste treinamento, utilizaremos o SystemJs, um carregador de módulos universal que suporta módulos do ES2015.

Além do loader, ajustes em nosso código devem ser feitos para adequá-lo ao loader utilizado. Resumindo: para que possamos utilizar os módulos do ES2015, precisamos utilizar um loader e transcompilar nosso código.

Antes de baixarmos nosso loader, vamos primeiro configuração Babel para que adeque nosso código ao Systemjs.

Babel e transcompilação de módulos
Hoje, temos apenas configurado o preset es2015 no arquivo .babelrc. Ele garante a compilação do nosso código para ES5. Contudo, este preset não esta preparado para transcompilar módulos para o Systemjs.

No terminal e dentro da pasta aluraframe/client vamos instalar o plugin transform-es2015-modules-systemjs:

npm install babel-plugin-transform-es2015-modules-systemjs@6.9.0 --save-dev
Com o módulo baixado, vamos alterar nosso arquivo aluraframe/client/.babelrc e adicioná-lo como plugin. Nosso arquivo ficará assim:

{
  "presets": ["es2015"],
   "plugins": ["transform-es2015-modules-systemjs"]
}
A ideia de um plugin é a seguinte, depois de um preset ser aplicado, plugins são aplicados em seguida realizamos demais transformações.

Refatorando nosso código com import e export
Agora, precisamos alterar todos os scripts que criamos até o momento para fazerem uso da sintaxe de módulo do ES2015. Precisamos escolher um para começar. Vamos começar por aluraframe/client/js/app-es6/views/MensagemView.js.

A classe MensagemView depende da classe View, tanto isso é verdade que usamos a sintaxe extends para herdá-la. Do jeito que esta, não funcionará com o sistema de módulos do ES2015, pois cada script é um módulo que confina o código declarado nele, evitando assim que caia no escopo global.

Precisamos explicitar que queremos usar a classe View por meio da instrução import.

import {View} from './View';

class MensagemView extends View {

   // código omitido
}
Veja que usamos import seguido de {View}. Colocamos o nome da classe que desejamos importar de um módulo entre chaves. Em seguida, usamos a instrução from apontando para o local do módulo. Encare cada script nosso agora como um módulo, ou seja, View.js é um módulo. Contudo, do jeito que esta, não funcionará. Porque tudo que estiver entre {} deve ser exportado pelo módulo. Se abrirmos View.js em nenhum momento deixamos claro que a classe View pode ser importada. Corrigimos isso facilmente adicionando a instrução export antes da definição da classe:

export class View {

   // código omitido
}
Veja que o módulo View.js agora exporta uma classe: a View. Mas atenção, sabemos que MensagemView será usada por NegociacaoController, sendo assim, precisamos também usar export para exportar a classe:

import {View} from './View';

export class MensagemView extends View {

   // código omitido
}
Agora, vamos fazer a mesma coisa com NegociacoesView. Primeiro, vamos verificar suas dependências. Ela depende de View e também de DateHelper. Então, primeiro, vamos alterar DateHelper.js para que exporte a classe DateHelper:

export class DateHelper {

  // código omitido
}
Agora sim, podemos alterar NegociacoesView.js:

import {DateHelper} from '../helpers/DateHelper';
import {View} from './View';

// exportamos, porque é usada em NegociacaoController.js

export class NegociacoesView extends View {

    // código omitido
} 
Bom, os módulos da pasta aluraframe/client/js/app/views já foram todos alterados. Agora, vamos para a pasta aluraframe/client/js/app/services.

Vamos começar pelo módulo HttpService.js. Ele não depende de classes de outros módulos, sendo assim, não precisamos usar a instrução import. Mas o módulo precisa exportar a classe HttpService porque ela é usada por NegociacaoService.

export class HttpService {
    /* código omitido */    
}
Agora, vamos analisar o módulo NegociacaoService.js. Ele depende de HttpService, de Negociacao, pois instancia negociação, de ConnectionFactory e NegociacaoDao. Primeiro, vamos fazer com que o módulo Negociacao.js exporte a classe Negociacao.

export class Negociacao {
}    
Agora, vamos atacar o módulo ConnectionFactory. Você deve lembrar que implementamos o module pattern para esconder algumas variáveis do programador e exportar apenas a classe. Como estamos usando o sistema de módulos do ES6 podemos simplificar bastante nosso código. Hoje ela está assim:

var ConnectionFactory = (function() {

    let stores = ['negociacoes'];
    let version = 9;
    let dbName = 'aluraframe';
    let connection = null;
    let close = null;

    return  class ConnectionFactory {


        // código omitido
    }
})();
Como módulos do ES6 já escondem do mundo externos variáveis e classes, podemos simplesmente remover a IIFE que utilizamos e exportar apenas a classe como já fizemos com outras classes:

let stores = ['negociacoes'];
let version = 9;
let dbName = 'aluraframe';
let connection = null;
let close = null;

export  class ConnectionFactory {

    // código omitido
}
Agora, precisamos fazer com que o módulo NegociacaoDao.js importe Negociacao e exporte a classe NegociacaoDao:

import {Negociacao} from '../models/Negociacao';

export class NegociacaoDao {

    // código omitido 
}
Então, agora podemos alterar NegociacaoService:

import {HttpService} from './HttpService';
import {Negociacao} from '../models/Negociacao';
import {ConnectionFactory} from './ConnectionFactory';
import {NegociacaoDao} from '../dao/NegociacaoDao';

export class NegociacaoService {
// código omitido
}
Vamos alterar ProxyFactory. Ela não depende de outra classe, só deve exportar:

export class ProxyFactory {
    // código omitido
}    
export class Mensagem {
    // código omitido
}
export class ListaNegociacoes {
    // código omitido
}
Dentro de aluraframe/client/js/app/helpers faltou modificar o módulo Bind. Ele depende de ProxyFactory:

import {ProxyFactory} from '../services/ProxyFactory';

export class Bind {
    // código omitido
}
Por fim, falta o móduloaluraframe/client/js/app/controllers/NegociacaoController.js. Esta sim, dependerá de vários módulos:

import {Mensagem} from '../models/Mensagem';
import {Negociacao} from '../models/Negociacao';
import {ListaNegociacoes} from '../models/ListaNegociacoes';
import {NegociacoesView} from '../views/NegociacoesView';
import {MensagemView} from '../views/MensagemView';
import {NegociacaoService} from '../services/NegociacaoService';
import {DateHelper} from '../helpers/DateHelper';
import {Bind} from '../helpers/Bind';

export class NegociacaoController {

    // código omitido
}
Bom, agora, precisamos remover a instância de negociacaoController de index.html, pois ela não ficará mais no escopo global.

Veja que com isso, não podemos mais associar o evento clique do botão adiciona com o apaga ou com a controller, porque não há outra negociacaoControllerno escopo global. A página index.html ficará assim:

<!DOCTYPE html>
<html>
<head>
   <!-- código omitido -->   
</head>
<body class="container">

    <!-- código omitido -->

    <form class="form"">

        <!-- código omitido -->

        <button class="btn btn-primary" type="submit">Incluir</button>
    </form>

    <div class="text-center">
        <button class="btn btn-primary text-center" type="button">
            Apagar
        </button>
    </div> 
    <br>
    <br>

    <div id="negociacoesView"></div> 
</body>
</html>
Mas como associaremos a submissão do formulário à chamada do método adiciona() de NegociacaoController?

O primeiro passo é indicarmos qual será o primeiro módulo a ser carregado pela aplicação. Criaremos o módulo aluframe/client/js/app-es6/boot.js. Ele importará NegociacaoController:

import {NegociacaoController} from './controllers/NegociacaoController';
let negociacaoController = new NegociacaoController();
A instância de NegociacaoController não estará no escopo global, sendo assim, precisaremos adicionar manualmente para o formulário e o botão que apaga as negociações a chamada dos métodos da nossa instância:

import {NegociacaoController} from './controllers/NegociacaoController';

var negociacaoController = new NegociacaoController();

document.querySelector('.form').onsubmit = negociacaoController.adiciona;
document.querySelector('button[type=button]').onclick = negociacaoController.apaga;
Veja que para o evento onsubmit do formulário associamos o método adiciona(), contudo nosso código não funcionará. O this dos métodos deixaram de ser a instância negociacaoController e passarão a ser o elemento do DOM ao qual foram associados. Para resolvermos isso, podemos usar a conhecida função bind():

import {NegociacaoController} from './controllers/NegociacaoController';

var negociacaoController = new NegociacaoController();

document.querySelector('.form').onsubmit = negociacaoController.adiciona.bind(negociacaoController);
document.querySelector('button[type=button]').onclick = negociacaoController.apaga.bind(negociacaoController);
Perfeito. Agora que temos todos os módulos configurados, precisamos configurar nosso loader. Seu papel será carregar boot.js. Como boot.js depende NegociacaoController.js, o loader entende que deve baixar esse script e quando ver que este módulo depende de outros sairá baixando e resolverá todas as dependências. A vantagem disso é que não precisaremos importar mais scripts em nossa página! Apenas precisaremos importar o loader e indicar para ele que boot.js será o primeiro a ser carregado.

Vamos baixar nosso loader, o Systemjs usando o Terminal e dentro da pasta aluraframe/client:

npm install systemjs@0.19.31 --save 
Com o script baixado, vamos importá-lo como único script em index.html:

    <!-- código anterior omitido -->
    <script src="node_modules/systemjs/dist/system.js"></script>
</body>
</html>
Agora, vamos indicar para o loader que boot.js será o primeiro módulo a ser carregado:

    <!-- código anterior omitido -->
    <script src="node_modules/systemjs/dist/system.js"></script>
    <script>
        System.defaultJSExtensions = true; // permite omitir a extensão .js dos imports
        System.import('js/app/boot').catch(function(err){ 
            console.error(err);
        });
    </script>
</body>
</html>
Indicamos em System.import que boot.js será o primeiro módulo a ser carregado. Observe que não precisamos mais nos preocupar com a ordem de carregamentos de scripts, o loader vai resolver tudo para nós.

Vamos parar o babel e rodá-lo novamente para que compile nossos módulos. Em seguida, carregaremos nosso projeto que deve continuar funcionando. Se você tentar imprimir no console o nome de uma de nossas classes, inclusive a instância de negociacaoController, o resultado será undefined. Lembre-se que agora não trabalhamos mais com variáveis globais e não há mais o risco de colisão. Além disso, não precisamos mais nos preocupar com a ordem de carregamentos dos scripts.
***********************************************************
09-
***********************************************************
10-
***********************************************************
11-
***********************************************************
12-
***********************************************************
13-
***********************************************************
14-
***********************************************************