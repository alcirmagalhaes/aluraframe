01-Escopo global e carregamento de scripts = dor de cabeça
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui e continuar seus estudos.

Atenção: o projeto não possui a pasta aluraframe/client/node_modules e você precisará baixar as dependências abrindo o Terminal na pasta aluraframe/client para em seguida executar o comando npm install. Este comando lerá seu arquivo package.json e baixará todas dependências listadas nele.

Fizemos coisas fantásticas usando o JavaScript, mas não atacamos uma das grandes fraquezas da linguagem: o escopo global e o carregamento de script. Nos aprofundaremos sobre tais assuntos.

Dentro da pasta app-es6, criaremos uma outra pasta que receberá o nome lib. Nesta, criaremos um arquivo chamado datex.js, na qual terá uma biblioteca baixada da internet com alguns métodos de data que o nosso DateHelper não tem: dateToString() e stringToDate().

class DateHelper {

    dateToString(date) {
        /* faz algo */
    }

    stringToDate(string) {
        /* faz algo */
    }
}
Temos os métodos dateToString() e stringToDate(). Podemos adicionar ainda outras que nos auxiliaram a trabalhar com datas. Em seguida, importaremos este script como o último da lista index.html.

<div id="negociacoesView"></div>
<script src="js/app/polyfill/fetch.js"></script>
<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script src="js/app/dao/NegociacaoDao.js"></script>
<script src="js/app/lib/datex.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
O Babel está rodando e depois, compilará o arquivo, jogando-o dentro de app. Mas quando a página carregar no navegador, teremos uma mensagem de erro.

mensagem de erro

Por que tivemos um erro e a aplicação parou de funcionar? Na lib que baixamos, temos uma classe chamada DateHelper - e nós já tínhamos um arquivo com mesmo nome em helpers:

Class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instanciada');
    }

//...
Como esta definição de classe está no escopo global, quando o script datex é carregado, o DateHelper deste irá sobrescrever o anterior. Isto é das grandes limitações do JS - o mesmo ocorre com variáveis e funções que estão no escopo global. É impossível usar as duas classes DateHelpers simultaneamente. Outro problema é que quando importamos os scripts da nossa página, eles são colocados em determinada ordem. Lembre-se que o carregamento de View deve vir antes de NegociacaoView e MensagemView, porque NegociacaoView estende View. Então, se ocasionalmente carregarmos os scripts numa ordem contrária, teremos um erro de execução e a aplicação irá parar de funcionar. O desenvolvedor precisará ficar atendo sobre a ordem de dependência.

A plataforma Node.js resolveu este problema adotando padrão CommonJS para criação de módulos, ainda há bibliotecas como RequireJS que usam o padrão AMD (Assincronous Module Definition). Contudo, o ES2015 especificou seu próprio sistema de módulos que resolve tanto o problema do escopo global quanto o de carregamento de scripts.

Nesta aula, nós usaremos o sistema de módulos do ECMAScript 2015, que nos ajudará a resolver os dois problemas.
***********************************************************
02-ES2015 e módulos
Vamos precisar seguir uma série de etapas para usar o sistema de módulos do ECMAScript 2015. Mas a primeira coisa que faremos - e ainda será insuficiente - será converter todos os scripts feitos para o sistema.

Começaremos pela classe View.js, que é dependência da classe MensagemView. O que faremos? No módulo do ES6, todos os scripts também serão. Isto significa que todo o conteúdo dentro do arquivo JS não será acessível para outros e não estará no escopo global. Se tivéssemos ativado o sistema de módulo do ES 6, nenhuma definição de classe estaria no escopo global e a aplicação não funcionaria. Por exemplo, se MensagemView quiser utilizar a View, teremos que importar a classe View para o módulo View.js:

export class View{

    constructor(elemento) {

      this._elemento = elemento;

    }

    template() {

        throw new Error('O método template deve ser implementado');

    }

    update(model) {

        this._elemento.innerHTML = this.template(model);
    }
}
Se incluirmos a palavra export na classe, quando o MensagemView.js tentar utilizar a View, ele não conseguirá fazer a importação. Faremos isto a seguir:

import {View} from './View';

export class MensagemView extends View {

    constructor(elemento) {

        super(elemento);
    }

    template(model) {

        return model.texto ? `<p class="alert alert-info">${model.texto}</p>` : `<p></p>`;
    }
}
Nós explicitamos que queremos importar algo do módulo View. Relembrando, cada script é considerado um módulo por padrão e todo conteúdo não cairá no escopo global. Como View está na mesma pasta que MensagemView, usamos apenas o ./, sem precisar especificar a extensão no fim. Também, especificamos dentro das chaves o que queremos importar (View). Observe que também exportamos o MensagemView, porque ela será importada pelo NegociacaoController.js.

Repetiremos o processo de importação e exportação em NegociacaoView.js:

import {View} from './View';
export class NegocicaoView extends View {

    constructor(elemento) {

        super(elemento);
    }
//...
E depois, adicionaremos o export em DateHelper.js:

export class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instaciada');
    }
//...
Outros arquivos precisam da classe HttpService, iremos exportá-la:

export class HttpService {

    _handleErrors(res) {
        if(!res.ok) throw new Error(res.statusText);
        return res;
    }
//...
Faremos o mesmo em NegociacaoService.js. Observe que também importaremos o HttpService:

import {HttpService} from './HttpService';
 export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
NegociacaoService depende da definição de classe de HttpService que estamos importando. A próxima alteração será em ProxyFactory.js:

 export class ProxyFactory {

      static create(objeto, props, acao) {
          return new Proxy(objeto, {

              get(target, prop, receiver) {

                  if(props.includes(prop) && ProxyFactory._ehFuncao(target[prop])) {

                    console.log(`interceptando ${prop}`);
                    let retorno = Reflect.apply(target[prop], target, arguments);
                    acao(target);
                    return retorno;
                  }
              }
            }
//...
***********************************************************
03-Refatorando nosso código com import e export
Temos um caso atípico com a classe ConnectionFactory. Nela, criamos o Model Pattern para exportá-la no escopo global. Mas escondemos algumas variáveis:

var ConnectionFactory = (function () {

      const stores = ['negociacoes'];
      const version = 4;
      const dbName = 'aluraframe';

      var connection = null;

      var close = null;

      return class ConnectionFactory {

          constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
          }
//...
Como todo arquivo JS é um módulo, o conteúdo não será mais acessível. Apenas o que é exportável será acessível para outros módulos. Em vez do return, vamos usar o export para a classe:

const stores = ['negociacoes'];
const version = 4;
const dbName = 'aluraframe';

let connection = null;

let close = null;

export class ConnectionFactory {

    constructor() {

        throw new Error('Não é possível criar instâncias de ConnectionFactory');
    }
//...
Observe que também substituímos o var pelo let, porque as variáveis não vão mais cair no escopo global. Em seguida, faremos alterações no arquivo NegociacaoDao:

import {Negociacao} from '../models/Negociacao';

export class NegociacaoDao {

    constructor(connection) {

        this._connection = connection;
        this._store - 'negociacoes';
    }
//...
Adicionaremos o export e import em Bind.js:

import {ProxyFactory} from '../services/ProxyFactory';

export class Bind {

    constructor(model, view, ...props) {

        let proxy = ProxyFactory.create(model, props, model =>
            view.update(model));

            view.update(model);
    }
}
Voltaremos em NegociacaoService para fazer uma modificação que deixamos escapar. Adicionaremos mais duas importações:

import {HttpService} from './HttpService';
import {ConnectionFactory} from './ConnectionFactory';
import {NegociacaoDao} from '../dao/NegociacaoDao';

export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
Depois, iremos inserir o export em ListaNegociacoes.js:

export class ListaNegociacoes {

    constructor() {

        this._negociacoes = [];
 }
//...
Faremos o mesmo em Mensagem.js:

export class Mensagem {

    constructor(texto) {

        this._texto = texto || '';
    }
//...
Temos que exportar também em Negociacao.js:

export class Negociacao {

    constructor(data, quantidade, valor) {

      this._data = new Date(data.getTime());
      this._quantidade = quantidade;
      this._valor = valor;
      Object.freeze(this);
    }
//...
As próximas alterações serão em NegociacaoController:

import {ListaNegociacoes} from '../models/ListaNegociacoes';
import {Mensagem} from '../models/Mensagem';
import {NegociacoesView} from '../views/NegociacoesView';
import {MensagemView} from '../views/MensagemView';
import {NegociacaoService} from '../services/NegociacaoService';
import {DateHelper} from '../helpers/DateHelper';
import {Bind} from '../helpers/Bind';
import {Negociacao} from '../models/Negociacao';

class NegociacaoController {

    constructor() {

       let $ = document.querySelector.bind(document);
//...
Observe que a Controller tem várias dependências.

Nós fizemos diversas modificações nos arquivos, no entanto, se executarmos o código, ele ainda não funcionará. Usamos a sintaxe do ES6 (de importação e exportação de módulos), mas entenderemos por que isso ainda não é o suficiente.
***********************************************************
04-SystemJs
Faltou adicionarmos uma importação ao arquivo NegociacaoService.js:

import {HttpService} from './HttpService';
import {ConnectionFactory} from './ConnectionFactory';
import {NegociacaoDao} from '../dao/NegociacaoDao';
import {Negociacao} from '../models/Negociacao';

export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
Agora, fizemos todas as importações necessárias. Mas por que o código não funciona como está? Porque a especificação ES2015 define o import e export, além de que cada script é um módulo independente. No entanto, não definimos como estes módulos devem ser carregados no navegador. Não existe um consenso... Precisamos que os scripts sejam carregados em uma determinada ordem no seu sistema, definindo apenas o primeiro. A partir deste, serão carregados os demais. O responsável pelo processo é loader, porém, não existe um padrão nos navegadores. Para resolver a questão, teremos que escolher uma biblioteca de terceiro que atue como um loader de script. Uma biblioteca muito famosa é System JS. Nós iremos baixá-lo pelo NPM do Node.JS, e iremos colocá-lo na pasta node_modules.

Em seguida, vamos parar o Terminal. Dentro da pasta client, instalaremos o System JS.

npm install systemjs@0.19.31 --save
O SystemJS é um script que precisa ser carregado com a aplicação. O processo de instalação é bem rápido. Então, dentro da pasta node_modules encontraremos o systemjs. Depois, importaremos o script no index.html, o arquivo ficará logo no início:

<div id="negociacoesView"></div>
<script src="node_modules/systemjs/dist/system.js"></script>
<script src="js/app/polyfill/fetch.js"></script>
<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script src="js/app/dao/NegociacaoDao.js"></script>
<script src="js/app/dao/datex.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
Importamos o loader. Porém, ao adicionarmos o responsável pela importação dos scripts, não precisaremos mais importar todos os demais:

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
Nós vamos especificar para o systemjs qual será o primeiro módulo carregado, e automaticamente, ele baixará os demais scripts na ordem de dependência. Ou seja, o desenvolvedor não precisará mais se preocupar com a ordem. Porém, falta indicar o primeiro módulo. Faremos a seguinte configuração:

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    System.defaultJSExtensions = true;
    System.import('js/app/boot').catch(function(err){
        console.error(err);
    });
</script>
<script>
    var negociacaoController = new NegociacaoController();  
</script>
O systemjs tem a variável global System. Quando definimos true para defaultJSExtensions, isto nos permite omitir as extensões JS dos imports. Como em NegociacaoController.js, que fizemos as importações sem adicionar a extensão js:

import {ListaNegociacoes} from '../modelo/ListaNegociacoes';
import {Mensagem} from '../modelo/Mensagem';
import {NegociacaoView} from '../view/NegociacaoView';
import {MensagemView} from '../view/MensagemView';
import {NegociacaoService} from '../services/NegociacaoService';
import {DateHelper} from '../helpers/DateHelper';
import {Bind} from '../helpers/Bind';
import {Negociacao} from '../models/Negociacao';
De volta ao index.html, especificamos com System qual será o primeiro módulo carregado: no caso, será o boot.js que criaremos a seguir. Dentro da pasta app-es6:

arquivo boot

Este será o primeiro arquivo a ser carregado. Também não fará mais sentido termos o NegociacaoController no escopo global, por isso, iremos removê-lo.

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    System.defaultJSExtensions = true;
    System.import('js/app/boot').catch(function(err){
        console.error(err);
    });
</script>
Conseguimos apagar diversos scripts que precisam ser carregados manualmente.
***********************************************************
05-O módulo boot.js
Conseguimos remover inúmeros scripts do index.html:

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    System.defaultJSExtensions = true;
    System.import('js/app/boot').catch(function(err){
        console.error(err);
    });
</script>
Se você analisar a lib, perceberá que ela não segue o sistema de módulos do ES6. Resolveremos isto mais adiante. Vamos adicionar a variável negociacaoController, no entanto, ela está em um escopo privado. Não temos mais o negociacaoController no escopo global... Para resolver a questão, não associaremos mais os eventos na View.

Importamos a lib do system.js e fizemos a configuração mínima, especificando que omitiremos as extensões dos arquivos e qual será o primeiro módulo a ser carregado. Agora, começaremos a escrever o arquivo boot.js:

import {NegociacaoController} from './controllers/NegociacaoController';
import {} from './polyfill/fetch';

let negociacaoController = new NegociacaoController();
Primeiramente, importamos o NegociacaoController e carregamos o polyfill, para que ele seja executado. No entanto, o negociacaoController está em um escopo privado. No arquivo index.html, por exemplo, chamamos negociacaoController e depois o método apaga():

<div class="text-center">
    <button onclick="negociacaoController.apaga()" class="btn btn-primary text-center" type="button">
        Apagar
    </button>
</div>
Como não temos mais negociacaoController no escopo global, deixaremos de associar o evento de onde ele era utilizado diretamente na View. No caso, o trecho referente ao botão "Apagar" ficará assim:

<div class="text-center">
    <button class="btn btn-primary text-center" type="button">
        Apagar
    </button>
</div>
Em seguida, vamos inserir as classes do index no boot.js. Usaremos o querySelector():

import {NegociacaoController} from './controllers/NegociacaoController';
import {} from './polyfill/fetch';

let negociacaoController = new NegociacaoController();

document.querySelector('.form').onsubmit = negociacaoController.adiciona.bind(negociacaoController);
document.querySelector('[type=button]').onclick = negociacaoController.apaga.bind(negociacaoController);
O porquê do uso do bind já foi visto anteriormente. Se não o incluíssemos, o this do adiciona não seria mais o negociacaoController. Escolhemos uma solução tradicional.
***********************************************************
06-Babel e transcompilação de módulos
O arquivo boot.js instanciará a controller, sendo responsável por associar os métodos do NegociacaoController com os eventos da View. Porém, o nosso código ainda não vai funcionar. Isto porque estamos usando como loader o system.js, por isso, os módulos que o Babel transcompila realizarão a ação usando a sintaxe do mesmo arquivo para auxiliar a importação.

O transpiler é importante neste processo porque ele mudará o código dos módulos para adequá-los ao loader. De volta ao Terminal, na pasta client, instalaremos o novo módulo - um plugin do Babel.

npm install babel-plugin-transform-es2015-modules-systemjs@6.9.0 --save-dev
O plugin transforma o código do ES2015 para usar o SystemJS. É fundamental instalá-lo no Babel para que tudo funcione corretamente.

Talvez, você tenha achado "burocrático" usar o módulo do ES6. Eu concordo...

Após fazermos a gravação do plugin, vamos configurar para que o Babel utilize o recurso recém instalado, no arquivo .babelrc .

{
   "presets" : ["es2015"],
   "plugins" : ["transform-es2015-modules-systemjs"]
}
Sem a configuração, o Babel não compilará os módulos adequadamente para a importação no System.js. Em seguida, no Terminal, vamos fazer a compilação com o comando build:

npm run build
O processo de compilação funcionará corretamente:

compilação completa

Se analisarmos os arquivos gerados pelo transpiler, localizados na pasta app, veremos que aparecerá uma sintaxe nova. Por exemplo, no arquivo NegociacaoDao, encontraremos o System.register aparecendo no seguinte trecho:

System.register([], function(_export, _context) {
    "use strict";

    var _createClass, NegociacaoDao;

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
//...
Conseguimos importar o loader. Depois, no Terminal, deixaremos o watch ligado.

npm run watch
Ao recarregarmos a página, ela não funcionará. No Console, veremos diversas mensagens de erro.

Mensagens de erro

Não foi encontrado o ListaNegociacoes, Mensagem, além de outros arquivos. Teremos que fazer algumas correções nos caminhos das importações do NegociacaoController.js. Onde escrevemos modelo, substituiremos por models. Também modificaremos de view para views e NegociacaoView para NegociacoesView:

import {ListaNegociacoes} from '../models/ListaNegociacoes';
import {Mensagem} from '../models/Mensagem';
import {NegociacoesView} from '../views/NegociacoesView';
import {MensagemView} from '../views/MensagemView';
import {NegociacaoService} from '../services/NegociacaoService';
import {DateHelper} from '../helpers/DateHelper';
import {Bind} from '../helpers/Bind';
import {Negociacao} from '../models/Negociacao';

export class NegociacaoController {

    constructor() {}

//...
Observe que faltou também adicionar o export no NegociacaoController para que este possa ser importado pelo boot.js. Depois, em NegociacoesView.js, importaremos o DateHelper:

import {View} from './View';
import {DateHelper} from '../helpers/DateHelper';

export class NegociacoesView extends View {

  constructor(elemento) {

      super(elemento);
  }
//...
Apesar do erro, não nós que importamos o scripts. Foi o System.JS quem realizou as importações. Com as alterações, no Console já não veremos nenhuma mensagem de erro.

negociações importadas

Se cadastrarmos uma nova negociação, ela será importada corretamente. Agora a nossa aplicação inteira está usando o sistema de módulos do ES2015.
***********************************************************
07-Delegação de eventos
Nossa aplicação parece estar funcionando, migramos para o sistema de módulos do ECMAScript 2015. No entanto, quando tentamos ordenar os dados das colunas, já não somos bem-sucedidos na tarefa. Se abrimos o Console, veremos diversas mensagens de que NegociacaoController não está definido.

negociacaoController is not defined

Se analisarmos o NegociacaoView, veremos que adicionamos o evento onclick chamando o negociacaoController.

<thead>
    <tr>
        <th onclick="negociacaoController.ordena('data')">DATA</th>
        <th onclick="negociacaoController.ordena('quantidade')">QUANTIDADE</th>
        <th onclick="negociacaoController.ordena('valor')">VALOR</th>
        <th onclick="negociacaoController.ordena('volume')">VOLUME</th>
    </tr>
</thead>
Como ocorreu anteriormente, tivemos problemas porque o NegociacaoController não faz mais parte do escopo global. Para que a aplicação possa funcionar, teremos que encontrar alguma forma de importar o arquivo. No entanto, não podemos simplesmente importar o NegociacaoController.

import {View} from './View';
import {DateHelper} from '../helpers/DateHelper';
import {NegociacaoController} from '../controllers/NegociacaoController'

export class NegociacoesView extends View {

  constructor(elemento) {

      super(elemento);
  }
//...
Se fizermos isto, teremos um nova instância de negociação e isso nos trará problemas. Ao tentarmos ordenar as negociações, elas não terão os dados incluídos ou alterados. Isto significa que a solução é ter acesso a mesma instância. Como faremos isto? No arquivo NegociacaoController.js, não exportaremos mais a classe NegociacaoController. Iremos remover a palavra export:

class NegociacaoController {

    constructor() `{

        let $ = document.querySelector.bind(document);

        this._inputData = $('#data');
        this._inputQuantidade = $('#quantidade');
        this._inputValor = $('#valor');
//...
No entanto, se não exportamos, ninguém poderá usar seu conteúdo. A solução será exportar uma função que criaremos a seguir: currentInstance():

let negociacaoController = new NegociacaoController();

export function currentInstance() {

    return negociacaoController;

}
Dentro do módulo, teremos a variável negociacaoController e que só existirá na nele. Quando a função for chamada, retornaremos a instância negociacaoController. Agora importaremos uma única instância. Faremos alterações em boots.js, adicionando o currentInstance:


import {currentInstance} from './controllers/NegociacaoController';
import {} from '/polyfill/fetch';

let negociacaoController = currentInstance();

document.querySelector('.form').onsubmit = negociacaoController.adiciona.bind(negociacaoController);
document.querySelector('[type=button]').onclick = negociacaoController.apaga.bind(negociacaoController);
A função nos retornará a instância de negociacaoController do módulo. Também importaremos o currentInstance em NegociacaoView.js.

import {View} from './View';
import {DateHelper} from '../helpers/DateHelper';
import {currentInstance} from '../controlers/NegociacaoController';

export class NegociacaoView extends View{

    constructor(elemento) {

        super(elemento);
    }
//...
Depois, trabalharemos com a delegação de eventos. Começaremos removendo o onclick do arquivo.

<thead>
    <tr>

      <th>DATA</th>
      <th>QUANTIDADE</th>
      <th>VALOR</th>
      <th>VOLUME</th>

    </tr>
</thead>
Quando clicarmos na coluna (na tag <th>), o JavaScript possui um sistema de eventos chamado event bubbling. Com ele, ao clicarmos, o evento "subirá" até a tag <tr> - que é o pai - e seguirá subindo até o

, perguntando se todos respondem pelo evento do clique. Nós vamos especificar que, se o evento de clique chegar até onegociacoesView, ele responderá ao evento da`:
<div id="negociacoesView"></div>
Se não fizermos isto, cada <th> terá que responder pelo evento. Em NegociacoesView, vamos adicionar o event.target dentro do if:

export class NegociacoesView extends View {

    constructor(elemento) {

        super(elemento);

        elemento.addEventListener('click', function(event) {

            if(event.target.nodeName == 'TH') {

                currentInstance().ordena(event.target.textContent.toLowerCase());
            }
          })
    }
}
Nós adicionaremos o nome de cada <th> e vamos converter para cada caso (toLowerCase()). Se clicamos na TH, ela não estará preparada para o esforço... O evento subirá de hierarquia até chegar em elemento, então, perguntará se o alvo (target) era uma TH. Como a resposta será sim, pegaremos a instância atual da Controller, e chamaremos o ordena() passando o nome da th - indicado pelo event.target.textContent.

Se executarmos a página, veremos que o código funciona. Os dados também serão ordenados quando clicarmos em um coluna da tabela.

dados ordenados

O sistema de módulos do ECMAScript 2015 também nos permite exportar instâncias, por meio da chamada da função currentInstance. Com isto, não temos mais nada quebrando na aplicação e terminamos o projeto com o código totalmente convertido.


***********************************************************
08-
***********************************************************
09-
***********************************************************
10-
***********************************************************
11-
***********************************************************
12-
***********************************************************
13-
***********************************************************
14-
***********************************************************