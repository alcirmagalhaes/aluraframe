01-Escopo global e carregamento de scripts = dor de cabeça
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui e continuar seus estudos.

Atenção: o projeto não possui a pasta aluraframe/client/node_modules e você precisará baixar as dependências abrindo o Terminal na pasta aluraframe/client para em seguida executar o comando npm install. Este comando lerá seu arquivo package.json e baixará todas dependências listadas nele.

Fizemos coisas fantásticas usando o JavaScript, mas não atacamos uma das grandes fraquezas da linguagem: o escopo global e o carregamento de script. Nos aprofundaremos sobre tais assuntos.

Dentro da pasta app-es6, criaremos uma outra pasta que receberá o nome lib. Nesta, criaremos um arquivo chamado datex.js, na qual terá uma biblioteca baixada da internet com alguns métodos de data que o nosso DateHelper não tem: dateToString() e stringToDate().

class DateHelper {

    dateToString(date) {
        /* faz algo */
    }

    stringToDate(string) {
        /* faz algo */
    }
}
Temos os métodos dateToString() e stringToDate(). Podemos adicionar ainda outras que nos auxiliaram a trabalhar com datas. Em seguida, importaremos este script como o último da lista index.html.

<div id="negociacoesView"></div>
<script src="js/app/polyfill/fetch.js"></script>
<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script src="js/app/dao/NegociacaoDao.js"></script>
<script src="js/app/lib/datex.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
O Babel está rodando e depois, compilará o arquivo, jogando-o dentro de app. Mas quando a página carregar no navegador, teremos uma mensagem de erro.

mensagem de erro

Por que tivemos um erro e a aplicação parou de funcionar? Na lib que baixamos, temos uma classe chamada DateHelper - e nós já tínhamos um arquivo com mesmo nome em helpers:

Class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instanciada');
    }

//...
Como esta definição de classe está no escopo global, quando o script datex é carregado, o DateHelper deste irá sobrescrever o anterior. Isto é das grandes limitações do JS - o mesmo ocorre com variáveis e funções que estão no escopo global. É impossível usar as duas classes DateHelpers simultaneamente. Outro problema é que quando importamos os scripts da nossa página, eles são colocados em determinada ordem. Lembre-se que o carregamento de View deve vir antes de NegociacaoView e MensagemView, porque NegociacaoView estende View. Então, se ocasionalmente carregarmos os scripts numa ordem contrária, teremos um erro de execução e a aplicação irá parar de funcionar. O desenvolvedor precisará ficar atendo sobre a ordem de dependência.

A plataforma Node.js resolveu este problema adotando padrão CommonJS para criação de módulos, ainda há bibliotecas como RequireJS que usam o padrão AMD (Assincronous Module Definition). Contudo, o ES2015 especificou seu próprio sistema de módulos que resolve tanto o problema do escopo global quanto o de carregamento de scripts.

Nesta aula, nós usaremos o sistema de módulos do ECMAScript 2015, que nos ajudará a resolver os dois problemas.
***********************************************************
02-ES2015 e módulos
Vamos precisar seguir uma série de etapas para usar o sistema de módulos do ECMAScript 2015. Mas a primeira coisa que faremos - e ainda será insuficiente - será converter todos os scripts feitos para o sistema.

Começaremos pela classe View.js, que é dependência da classe MensagemView. O que faremos? No módulo do ES6, todos os scripts também serão. Isto significa que todo o conteúdo dentro do arquivo JS não será acessível para outros e não estará no escopo global. Se tivéssemos ativado o sistema de módulo do ES 6, nenhuma definição de classe estaria no escopo global e a aplicação não funcionaria. Por exemplo, se MensagemView quiser utilizar a View, teremos que importar a classe View para o módulo View.js:

export class View{

    constructor(elemento) {

      this._elemento = elemento;

    }

    template() {

        throw new Error('O método template deve ser implementado');

    }

    update(model) {

        this._elemento.innerHTML = this.template(model);
    }
}
Se incluirmos a palavra export na classe, quando o MensagemView.js tentar utilizar a View, ele não conseguirá fazer a importação. Faremos isto a seguir:

import {View} from './View';

export class MensagemView extends View {

    constructor(elemento) {

        super(elemento);
    }

    template(model) {

        return model.texto ? `<p class="alert alert-info">${model.texto}</p>` : `<p></p>`;
    }
}
Nós explicitamos que queremos importar algo do módulo View. Relembrando, cada script é considerado um módulo por padrão e todo conteúdo não cairá no escopo global. Como View está na mesma pasta que MensagemView, usamos apenas o ./, sem precisar especificar a extensão no fim. Também, especificamos dentro das chaves o que queremos importar (View). Observe que também exportamos o MensagemView, porque ela será importada pelo NegociacaoController.js.

Repetiremos o processo de importação e exportação em NegociacaoView.js:

import {View} from './View';
export class NegocicaoView extends View {

    constructor(elemento) {

        super(elemento);
    }
//...
E depois, adicionaremos o export em DateHelper.js:

export class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instaciada');
    }
//...
Outros arquivos precisam da classe HttpService, iremos exportá-la:

export class HttpService {

    _handleErrors(res) {
        if(!res.ok) throw new Error(res.statusText);
        return res;
    }
//...
Faremos o mesmo em NegociacaoService.js. Observe que também importaremos o HttpService:

import {HttpService} from './HttpService';
 export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
NegociacaoService depende da definição de classe de HttpService que estamos importando. A próxima alteração será em ProxyFactory.js:

 export class ProxyFactory {

      static create(objeto, props, acao) {
          return new Proxy(objeto, {

              get(target, prop, receiver) {

                  if(props.includes(prop) && ProxyFactory._ehFuncao(target[prop])) {

                    console.log(`interceptando ${prop}`);
                    let retorno = Reflect.apply(target[prop], target, arguments);
                    acao(target);
                    return retorno;
                  }
              }
            }
//...
***********************************************************
03-
***********************************************************
04-
***********************************************************
05-
***********************************************************
06-
***********************************************************
07-
***********************************************************
08-
***********************************************************
09-
***********************************************************
10-
***********************************************************
11-
***********************************************************
12-
***********************************************************
13-
***********************************************************
14-
***********************************************************