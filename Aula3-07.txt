01-Escopo global e carregamento de scripts = dor de cabeça
Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto até aqui e continuar seus estudos.

Atenção: o projeto não possui a pasta aluraframe/client/node_modules e você precisará baixar as dependências abrindo o Terminal na pasta aluraframe/client para em seguida executar o comando npm install. Este comando lerá seu arquivo package.json e baixará todas dependências listadas nele.

Fizemos coisas fantásticas usando o JavaScript, mas não atacamos uma das grandes fraquezas da linguagem: o escopo global e o carregamento de script. Nos aprofundaremos sobre tais assuntos.

Dentro da pasta app-es6, criaremos uma outra pasta que receberá o nome lib. Nesta, criaremos um arquivo chamado datex.js, na qual terá uma biblioteca baixada da internet com alguns métodos de data que o nosso DateHelper não tem: dateToString() e stringToDate().

class DateHelper {

    dateToString(date) {
        /* faz algo */
    }

    stringToDate(string) {
        /* faz algo */
    }
}
Temos os métodos dateToString() e stringToDate(). Podemos adicionar ainda outras que nos auxiliaram a trabalhar com datas. Em seguida, importaremos este script como o último da lista index.html.

<div id="negociacoesView"></div>
<script src="js/app/polyfill/fetch.js"></script>
<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script src="js/app/dao/NegociacaoDao.js"></script>
<script src="js/app/lib/datex.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
O Babel está rodando e depois, compilará o arquivo, jogando-o dentro de app. Mas quando a página carregar no navegador, teremos uma mensagem de erro.

mensagem de erro

Por que tivemos um erro e a aplicação parou de funcionar? Na lib que baixamos, temos uma classe chamada DateHelper - e nós já tínhamos um arquivo com mesmo nome em helpers:

Class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instanciada');
    }

//...
Como esta definição de classe está no escopo global, quando o script datex é carregado, o DateHelper deste irá sobrescrever o anterior. Isto é das grandes limitações do JS - o mesmo ocorre com variáveis e funções que estão no escopo global. É impossível usar as duas classes DateHelpers simultaneamente. Outro problema é que quando importamos os scripts da nossa página, eles são colocados em determinada ordem. Lembre-se que o carregamento de View deve vir antes de NegociacaoView e MensagemView, porque NegociacaoView estende View. Então, se ocasionalmente carregarmos os scripts numa ordem contrária, teremos um erro de execução e a aplicação irá parar de funcionar. O desenvolvedor precisará ficar atendo sobre a ordem de dependência.

A plataforma Node.js resolveu este problema adotando padrão CommonJS para criação de módulos, ainda há bibliotecas como RequireJS que usam o padrão AMD (Assincronous Module Definition). Contudo, o ES2015 especificou seu próprio sistema de módulos que resolve tanto o problema do escopo global quanto o de carregamento de scripts.

Nesta aula, nós usaremos o sistema de módulos do ECMAScript 2015, que nos ajudará a resolver os dois problemas.
***********************************************************
02-ES2015 e módulos
Vamos precisar seguir uma série de etapas para usar o sistema de módulos do ECMAScript 2015. Mas a primeira coisa que faremos - e ainda será insuficiente - será converter todos os scripts feitos para o sistema.

Começaremos pela classe View.js, que é dependência da classe MensagemView. O que faremos? No módulo do ES6, todos os scripts também serão. Isto significa que todo o conteúdo dentro do arquivo JS não será acessível para outros e não estará no escopo global. Se tivéssemos ativado o sistema de módulo do ES 6, nenhuma definição de classe estaria no escopo global e a aplicação não funcionaria. Por exemplo, se MensagemView quiser utilizar a View, teremos que importar a classe View para o módulo View.js:

export class View{

    constructor(elemento) {

      this._elemento = elemento;

    }

    template() {

        throw new Error('O método template deve ser implementado');

    }

    update(model) {

        this._elemento.innerHTML = this.template(model);
    }
}
Se incluirmos a palavra export na classe, quando o MensagemView.js tentar utilizar a View, ele não conseguirá fazer a importação. Faremos isto a seguir:

import {View} from './View';

export class MensagemView extends View {

    constructor(elemento) {

        super(elemento);
    }

    template(model) {

        return model.texto ? `<p class="alert alert-info">${model.texto}</p>` : `<p></p>`;
    }
}
Nós explicitamos que queremos importar algo do módulo View. Relembrando, cada script é considerado um módulo por padrão e todo conteúdo não cairá no escopo global. Como View está na mesma pasta que MensagemView, usamos apenas o ./, sem precisar especificar a extensão no fim. Também, especificamos dentro das chaves o que queremos importar (View). Observe que também exportamos o MensagemView, porque ela será importada pelo NegociacaoController.js.

Repetiremos o processo de importação e exportação em NegociacaoView.js:

import {View} from './View';
export class NegocicaoView extends View {

    constructor(elemento) {

        super(elemento);
    }
//...
E depois, adicionaremos o export em DateHelper.js:

export class DateHelper {

    constructor() {

        throw new Error('Esta classe não pode ser instaciada');
    }
//...
Outros arquivos precisam da classe HttpService, iremos exportá-la:

export class HttpService {

    _handleErrors(res) {
        if(!res.ok) throw new Error(res.statusText);
        return res;
    }
//...
Faremos o mesmo em NegociacaoService.js. Observe que também importaremos o HttpService:

import {HttpService} from './HttpService';
 export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
NegociacaoService depende da definição de classe de HttpService que estamos importando. A próxima alteração será em ProxyFactory.js:

 export class ProxyFactory {

      static create(objeto, props, acao) {
          return new Proxy(objeto, {

              get(target, prop, receiver) {

                  if(props.includes(prop) && ProxyFactory._ehFuncao(target[prop])) {

                    console.log(`interceptando ${prop}`);
                    let retorno = Reflect.apply(target[prop], target, arguments);
                    acao(target);
                    return retorno;
                  }
              }
            }
//...
***********************************************************
03-Refatorando nosso código com import e export
Temos um caso atípico com a classe ConnectionFactory. Nela, criamos o Model Pattern para exportá-la no escopo global. Mas escondemos algumas variáveis:

var ConnectionFactory = (function () {

      const stores = ['negociacoes'];
      const version = 4;
      const dbName = 'aluraframe';

      var connection = null;

      var close = null;

      return class ConnectionFactory {

          constructor() {

              throw new Error('Não é possível criar instâncias de ConnectionFactory');
          }
//...
Como todo arquivo JS é um módulo, o conteúdo não será mais acessível. Apenas o que é exportável será acessível para outros módulos. Em vez do return, vamos usar o export para a classe:

const stores = ['negociacoes'];
const version = 4;
const dbName = 'aluraframe';

let connection = null;

let close = null;

export class ConnectionFactory {

    constructor() {

        throw new Error('Não é possível criar instâncias de ConnectionFactory');
    }
//...
Observe que também substituímos o var pelo let, porque as variáveis não vão mais cair no escopo global. Em seguida, faremos alterações no arquivo NegociacaoDao:

import {Negociacao} from '../models/Negociacao';

export class NegociacaoDao {

    constructor(connection) {

        this._connection = connection;
        this._store - 'negociacoes';
    }
//...
Adicionaremos o export e import em Bind.js:

import {ProxyFactory} from '../services/ProxyFactory';

export class Bind {

    constructor(model, view, ...props) {

        let proxy = ProxyFactory.create(model, props, model =>
            view.update(model));

            view.update(model);
    }
}
Voltaremos em NegociacaoService para fazer uma modificação que deixamos escapar. Adicionaremos mais duas importações:

import {HttpService} from './HttpService';
import {ConnectionFactory} from './ConnectionFactory';
import {NegociacaoDao} from '../dao/NegociacaoDao';

export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
Depois, iremos inserir o export em ListaNegociacoes.js:

export class ListaNegociacoes {

    constructor() {

        this._negociacoes = [];
 }
//...
Faremos o mesmo em Mensagem.js:

export class Mensagem {

    constructor(texto) {

        this._texto = texto || '';
    }
//...
Temos que exportar também em Negociacao.js:

export class Negociacao {

    constructor(data, quantidade, valor) {

      this._data = new Date(data.getTime());
      this._quantidade = quantidade;
      this._valor = valor;
      Object.freeze(this);
    }
//...
As próximas alterações serão em NegociacaoController:

import {ListaNegociacoes} from '../models/ListaNegociacoes';
import {Mensagem} from '../models/Mensagem';
import {NegociacoesView} from '../views/NegociacoesView';
import {MensagemView} from '../views/MensagemView';
import {NegociacaoService} from '../services/NegociacaoService';
import {DateHelper} from '../helpers/DateHelper';
import {Bind} from '../helpers/Bind';
import {Negociacao} from '../models/Negociacao';

class NegociacaoController {

    constructor() {

       let $ = document.querySelector.bind(document);
//...
Observe que a Controller tem várias dependências.

Nós fizemos diversas modificações nos arquivos, no entanto, se executarmos o código, ele ainda não funcionará. Usamos a sintaxe do ES6 (de importação e exportação de módulos), mas entenderemos por que isso ainda não é o suficiente.
***********************************************************
04-SystemJs
Faltou adicionarmos uma importação ao arquivo NegociacaoService.js:

import {HttpService} from './HttpService';
import {ConnectionFactory} from './ConnectionFactory';
import {NegociacaoDao} from '../dao/NegociacaoDao';
import {Negociacao} from '../models/Negociacao';

export class NegociacaoService {

      constructor(){

          this._http = new HttpService()
      }
 //...
Agora, fizemos todas as importações necessárias. Mas por que o código não funciona como está? Porque a especificação ES2015 define o import e export, além de que cada script é um módulo independente. No entanto, não definimos como estes módulos devem ser carregados no navegador. Não existe um consenso... Precisamos que os scripts sejam carregados em uma determinada ordem no seu sistema, definindo apenas o primeiro. A partir deste, serão carregados os demais. O responsável pelo processo é loader, porém, não existe um padrão nos navegadores. Para resolver a questão, teremos que escolher uma biblioteca de terceiro que atue como um loader de script. Uma biblioteca muito famosa é System JS. Nós iremos baixá-lo pelo NPM do Node.JS, e iremos colocá-lo na pasta node_modules.

Em seguida, vamos parar o Terminal. Dentro da pasta client, instalaremos o System JS.

npm install systemjs@0.19.31 --save
O SystemJS é um script que precisa ser carregado com a aplicação. O processo de instalação é bem rápido. Então, dentro da pasta node_modules encontraremos o systemjs. Depois, importaremos o script no index.html, o arquivo ficará logo no início:

<div id="negociacoesView"></div>
<script src="node_modules/systemjs/dist/system.js"></script>
<script src="js/app/polyfill/fetch.js"></script>
<script src="js/app/models/Negociacao.js"></script>
<script src="js/app/models/ListaNegociacoes.js"></script>
<script src="js/app/models/Mensagem.js"></script>
<script src="js/app/controllers/NegociacaoController.js"></script>
<script src="js/app/helpers/DateHelper.js"></script>
<script src="js/app/views/View.js"></script>
<script src="js/app/views/NegociacoesView.js"></script>
<script src="js/app/views/MensagemView.js"></script>
<script src="js/app/services/ProxyFactory.js"></script>
<script src="js/app/helpers/Bind.js"></script>
<script src="js/app/services/NegociacaoService.js"></script>
<script src="js/app/services/HttpService.js"></script>
<script src="js/app/services/ConnectionFactory.js"></script>
<script src="js/app/dao/NegociacaoDao.js"></script>
<script src="js/app/dao/datex.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
Importamos o loader. Porém, ao adicionarmos o responsável pela importação dos scripts, não precisaremos mais importar todos os demais:

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    var negociacaoController = new NegociacaoController();          
</script>
Nós vamos especificar para o systemjs qual será o primeiro módulo carregado, e automaticamente, ele baixará os demais scripts na ordem de dependência. Ou seja, o desenvolvedor não precisará mais se preocupar com a ordem. Porém, falta indicar o primeiro módulo. Faremos a seguinte configuração:

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    System.defaultJSExtensions = true;
    System.import('js/app/boot').catch(function(err){
        console.error(err);
    });
</script>
<script>
    var negociacaoController = new NegociacaoController();  
</script>
O systemjs tem a variável global System. Quando definimos true para defaultJSExtensions, isto nos permite omitir as extensões JS dos imports. Como em NegociacaoController.js, que fizemos as importações sem adicionar a extensão js:

import {ListaNegociacoes} from '../modelo/ListaNegociacoes';
import {Mensagem} from '../modelo/Mensagem';
import {NegociacaoView} from '../view/NegociacaoView';
import {MensagemView} from '../view/MensagemView';
import {NegociacaoService} from '../services/NegociacaoService';
import {DateHelper} from '../helpers/DateHelper';
import {Bind} from '../helpers/Bind';
import {Negociacao} from '../models/Negociacao';
De volta ao index.html, especificamos com System qual será o primeiro módulo carregado: no caso, será o boot.js que criaremos a seguir. Dentro da pasta app-es6:

arquivo boot

Este será o primeiro arquivo a ser carregado. Também não fará mais sentido termos o NegociacaoController no escopo global, por isso, iremos removê-lo.

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    System.defaultJSExtensions = true;
    System.import('js/app/boot').catch(function(err){
        console.error(err);
    });
</script>
Conseguimos apagar diversos scripts que precisam ser carregados manualmente.
***********************************************************
05-O módulo boot.js
Conseguimos remover inúmeros scripts do index.html:

<div id="negociacoesView"></div>

<script src="node_modules/systemjs/dist/system.js"></script>
<script>
    System.defaultJSExtensions = true;
    System.import('js/app/boot').catch(function(err){
        console.error(err);
    });
</script>
Se você analisar a lib, perceberá que ela não segue o sistema de módulos do ES6. Resolveremos isto mais adiante. Vamos adicionar a variável negociacaoController, no entanto, ela está em um escopo privado. Não temos mais o negociacaoController no escopo global... Para resolver a questão, não associaremos mais os eventos na View.

Importamos a lib do system.js e fizemos a configuração mínima, especificando que omitiremos as extensões dos arquivos e qual será o primeiro módulo a ser carregado. Agora, começaremos a escrever o arquivo boot.js:

import {NegociacaoController} from './controllers/NegociacaoController';
import {} from './polyfill/fetch';

let negociacaoController = new NegociacaoController();
Primeiramente, importamos o NegociacaoController e carregamos o polyfill, para que ele seja executado. No entanto, o negociacaoController está em um escopo privado. No arquivo index.html, por exemplo, chamamos negociacaoController e depois o método apaga():

<div class="text-center">
    <button onclick="negociacaoController.apaga()" class="btn btn-primary text-center" type="button">
        Apagar
    </button>
</div>
Como não temos mais negociacaoController no escopo global, deixaremos de associar o evento de onde ele era utilizado diretamente na View. No caso, o trecho referente ao botão "Apagar" ficará assim:

<div class="text-center">
    <button class="btn btn-primary text-center" type="button">
        Apagar
    </button>
</div>
Em seguida, vamos inserir as classes do index no boot.js. Usaremos o querySelector():

import {NegociacaoController} from './controllers/NegociacaoController';
import {} from './polyfill/fetch';

let negociacaoController = new NegociacaoController();

document.querySelector('.form').onsubmit = negociacaoController.adiciona.bind(negociacaoController);
document.querySelector('[type=button]').onclick = negociacaoController.apaga.bind(negociacaoController);
O porquê do uso do bind já foi visto anteriormente. Se não o incluíssemos, o this do adiciona não seria mais o negociacaoController. Escolhemos uma solução tradicional.
***********************************************************
06-
***********************************************************
07-
***********************************************************
08-
***********************************************************
09-
***********************************************************
10-
***********************************************************
11-
***********************************************************
12-
***********************************************************
13-
***********************************************************
14-
***********************************************************